<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <title>research!rsc: Semantic Import Versioning (Go &amp; Versioning, Part 3)</title>
    <link rel="alternate" type="application/atom+xml" title="research!rsc - Atom" href="http://research.swtch.com/feed.atom" />
    
<meta name="viewport" content="width=device-width, initial-scale=1">
<link href='https://fonts.googleapis.com/css?family=Inconsolata:400,700' rel='stylesheet' type='text/css'>
<script type="text/javascript" src="https://use.typekit.com/skm6yij.js"></script>
<script type="text/javascript">try{Typekit.load();}catch(e){}</script>
<style>
  body {
    padding: 0;
    margin: 0;
    font-size: 100%;
    font-family: 'Minion Pro';
  }
  @media print {
    img {page-break-inside: avoid;}
    div.nosplit {page-break-inside: avoid;}
  }
  img.center {
    display: block;
    margin: 0 auto;
  }
  .pad {
    padding-top: 1em;
    padding-bottom: 1em;
  }
  a.anchor, a.back, a.footnote {
    color: black !important;
    text-decoration: none !important;
  }
  a.back {
    font-size: 50%;
  }
  @media print {
    a.back {display: none;}
  }
  .header {
    height: 1.25em;
    background-color: #dff;
    margin: 0;
    padding: 0.1em 0.1em 0.2em;
    border-top: 1px solid black;
    border-bottom: 1px solid #8ff;
  }
  .header h3 {
    margin: 0;
    padding: 0 2em;
    display: inline-block;
    padding-right: 2em;
    font-style: italic;
    font-size: 90%;
  }
  .rss {
    float: right;
    padding-top: 0.2em;
    padding-right: 2em;
    display: none;
  }
  .toc {
    margin-top: 2em;
  }
  .toc-title {
    font-family: "caflisch-script-pro";
    font-size: 300%;
    line-height: 50%;
  }
  .toc-subtitle {
    display: block;
    margin-bottom: 1em;
    font-size: 83%;
  }
  @media only screen and (max-width: 550px) { .toc-subtitle { display: none; } }
  .header h3 a {
    color: black;
  }
  .header h4 {
    margin: 0;
    padding: 0;
    display: inline-block;
    font-weight: normal;
    font-size: 83%;
  }
  @media only screen and (max-width: 550px) { .header h4 { display: none; } }
  .main {
    padding: 0 2em;
  }
  @media only screen and (max-width: 479px) { .article { font-size: 120%; } }
  .article h1 {
    text-align: center;
    font-size: 200%;
  }
  .copyright {
    font-size: 83%;
  }
  .subtitle {
      font-size: 65%;
  }
  .normal {
    font-size: medium;
    font-weight: normal;
  }
  .when {
    text-align: center;
    font-size: 100%;
    margin: 0;
    padding: 0;
  }
  .when p {
    margin: 0;
    padding: 0;
  }
  .article h2 {
    font-size: 125%;
    padding-top: 0.25em;
  }
  .article h3 {
    font-size: 100%;
  }
  pre {
    margin-left: 4em;
    margin-right: 4em;
  }
  pre, code {
    font-family: 'Inconsolata', monospace;
    font-size: 100%;
  }
  .footer {
    margin-top: 10px;
    font-size: 83%;
    font-family: sans-serif;
  }
  .comments {
    margin-top: 2em;
    background-color: #ffe;
    border-top: 1px solid #aa4;
    border-left: 1px solid #aa4;
    border-right: 1px solid #aa4;
  }
  .comments-header {
    padding: 0 5px 0 5px;
  }
  .comments-header p {
    padding: 0;
    margin: 3px 0 0 0;
  }
  .comments-body {
    padding: 5px 5px 5px 5px;
  }
  #plus-comments {
    border-bottom: 1px dotted #ccc;
  }
  .plus-comment {
    width: 100%;
    font-size: 14px;
    border-top: 1px dotted #ccc;
  }
  .me {
    background-color: #eec;
  }
  .plus-comment ul {
    margin: 0;
    padding: 0;
    list-style: none;
    width: 100%;
    display: inline-block;
  }
  .comment-when {
    color:#999;
    width:auto;
    padding:0 5px;
  }
  .old {
    font-size: 83%;
  }
  .plus-comment ul li {
    display: inline-block;
    vertical-align: top;
    margin-top: 5px;
    margin-bottom: 5px;
    padding: 0;
  }
  .plus-icon {
    width: 45px;
  }
  .plus-img {
    float: left;
    margin: 4px 4px 4px 4px;
    width: 32px;
    height: 32px;
  }
  .plus-comment p {
    margin: 0;
    padding: 0;
  }
  .plus-clear {
    clear: left;
  }
  .toc-when {
    font-size: 83%;
    color: #999;
  }
  .toc {
    list-style: none;
  }
  .toc li {
    margin-bottom: 0.5em;
  }
  .toc-head {
    margin-bottom: 1em !important;
    font-size: 117%;
  }
  .toc-summary {
    margin-left: 2em;
  }
  .favorite {
    font-weight: bold;
  }
  .article p, .article ol {
    line-height: 144%;
  }
  sup, sub {
    vertical-align: baseline;
    position: relative;
    font-size: 83%;
  }
  sup {
    bottom: 1ex;
  }
  sub {
    top: 0.8ex;
  }

  .main {
    position: relative;
    margin: 0 auto;
    padding: 0;
    width: 900px;
  }
  @media only screen and (min-width: 768px) and (max-width: 959px) { .main { width: 708px; } }
  @media only screen and (min-width: 640px) and (max-width: 767px) { .main { width: 580px; } }
  @media only screen and (min-width: 480px) and (max-width: 639px) { .main { width: 420px; } }
  @media only screen and (max-width: 479px) { .main { width: 300px; } }

</style>

  </head>
  <body>
    
<div class="header">
  <h3><a href="/">research!rsc</a></h3>
  <h4>Thoughts and links about programming,
    by <a href="https://swtch.com/~rsc/" rel="author">Russ Cox</a> </h4>
  <a class="rss" href="/feed.atom"><img src="/feed-icon-14x14.png" /></a>
</div>

    <div class="main">
      <div class="article">
        <h1>Semantic Import Versioning
        
        <div class="subtitle">(<i><a href="vgo">Go &amp; Versioning</a>, Part 3</i>)</div>
        
        <div class="normal">
        <div class="when">
          
            Posted on Wednesday, February 21, 2018.
            
           <font size="-1"><a href="vgo-import.pdf">PDF</a></font>
        </div>
        </div>
        </h1>
        

<p>
How do you deploy an incompatible change to an existing package?
This is the fundamental challenge, the fundamental decision,
in any package management system.
The answer decides the complexity of the resulting system
It decides how easy or difficult package management will be to use.
(It also decides how easy or difficult package management will be to
implement, but the user experience is more important.)

<p>
To answer this question, this post first presents the <i>import compatibility rule</i> for Go:<blockquote>

<p>
<i>If an old package and a new package have the same import path,</i>
<br><i>the new package must be backwards compatible with the old package.</i></blockquote>

<p>
We've argued for this principle from the start of Go, but we haven't given
it a name or such a direct statement.

<p>
The import compatibility rule dramatically simplifies the experience of
using incompatible versions of a package.
When each different version has a different import path,
there is no ambiguity about the intended semantics of a
given import statement.
This makes it easier for both developers and tools to understand Go programs.

<p>
Developers today expect to use semantic versions to describe
packages, so we adopt them into the model.
Specifically, a module <code>my/thing</code> is imported as <code>my/thing</code> for v0,
the incompatibility period when breaking changes are expected
and not protected against,
and then also during v1, the first stable major version.
But when it's time to add v2, instead of redefining the meaning
of the now-stable <code>my/thing</code>, we give it a new name: <code>my/thing/v2</code>.

<p>
<img name="impver" class="center pad" width=458 height=223 src="impver.png" srcset="impver.png 1x, impver@1.5x.png 1.5x, impver@2x.png 2x, impver@3x.png 3x, impver@4x.png 4x">

<p>
I call this convention <i>semantic import versioning</i>, the result of
following the import compatibility rule while using semantic
versioning.

<p>
A year ago, I believed that putting versions in import paths
like this was ugly, undesirable, and probably avoidable.
But over the past year, I've come to understand just how
much clarity and simplicity they bring to the system.
In this post I hope to give you a sense of why I changed my mind.
<a class=anchor href="#dependency_story"><h2 id="dependency_story">A Dependency Story</h2></a>


<p>
To make the discussion concrete, consider the following story.
The story is hypothetical, of course, but it's motivated by a real problem.
When <code>dep</code> was released, the team at Google that wrote the OAuth2
package asked me how they should go about introducing some incompatible
improvements they've wanted to do for a long time.
The more I thought about it, the more I realized that this was
not as easy as it sounded, at least not without semantic import
versioning.
<a class=anchor href="#prologue"><h3 id="prologue">Prologue</h3></a>


<p>
From the perspective of a package management tool, there are Authors of code and Users of code.
Alice, Anna, and Amy are Authors of different code packages.
Alice works at Google and wrote the OAuth2 package.
Amy works at Microsoft and wrote the Azure client libraries.
Anna works at Amazon and wrote the AWS client libraries.
Ugo is the User of all these packages. He’s working on the ultimate cloud app, Unity,
which uses all of those packages and others.

<p>
As the Authors, Alice, Anna, and Amy need to be able to write and release new
versions of their packages.
Each version of a package specifies a required version for each of its dependencies.

<p>
As the User, Ugo needs to be able to build Unity with these other packages;
he needs control over exactly which versions are used in a particular build;
and he needs to be able to update to new versions when he chooses.

<p>
There’s more that our friends might expect from a package management
tool, especially around discovery, testing, portability, and helpful diagnostics,
of course, but those are not relevant to the story.

<p>
As our story opens, Ugo’s Unity build dependencies look like:

<p>
<img name="deps-a1-short2" class="center pad" width=550 height=351 src="deps-a1-short2.png" srcset="deps-a1-short2.png 1x, deps-a1-short2@1.5x.png 1.5x, deps-a1-short2@2x.png 2x, deps-a1-short2@3x.png 3x, deps-a1-short2@4x.png 4x">
<a class=anchor href="#chapter_1"><h3 id="chapter_1">Chapter 1</h3></a>


<p>
Everyone is writing software independently.

<p>
At Google, Alice has been busy designing a new,
simpler, easier-to-use API for the OAuth2 package.
It can still do everything that the old package can do,
but with half the API surface.
She releases it as OAuth2 r2.
(The ‘r’ here stands for revision.
For now, the revision numbers don’t indicate anything other than sequencing:
in particular, they’re not semantic versions.)

<p>
At Microsoft, Amy is on a well-deserved long vacation,
and her team decides not to make any changes related
to OAuth2 r2 until she returns.
The Azure package will keep using OAuth2 r1 for now.

<p>
At Amazon, Anna finds that using OAuth2 r2 will let her
delete a lot of ugly code from the implementation of AWS r1,
so she changes AWS to use OAuth2 r2.
She fixes a few bugs along the way and issues the result as AWS r2.

<p>
Ugo gets a bug report about behavior on Azure and tracks it down to a bug
in the Azure client libraries.
Amy already released a fix for that bug in Azure r2 before leaving for vacation.
Ugo adds a test case to Unity, confirms that it fails,
and asks the package management tool to update to Azure r2.

<p>
After the update, Ugo's build looks like:

<p>
<img name="deps-a1.5" class="center pad" width=550 height=427 src="deps-a1.5.png" srcset="deps-a1.5.png 1x, deps-a1.5@1.5x.png 1.5x, deps-a1.5@2x.png 2x, deps-a1.5@3x.png 3x, deps-a1.5@4x.png 4x">

<p>
He confirms that the new test passes and that all his old tests still pass.
He locks in the Azure update and ships an updated Unity.
<a class=anchor href="#chapter_2"><h3 id="chapter_2">Chapter 2</h3></a>


<p>
To much fanfare, Amazon launches their new cloud offering, Amazon Zeta Functions.
In preparation for the launch,
Anna added Zeta support to the AWS package, which she now releases as AWS r3.

<p>
When Ugo hears about Amazon Zeta, he writes some test programs
and is so excited about how well they work that he skips lunch to update Unity.
Today’s update does not go as well as the last one.
Ugo wants to build Unity with Zeta support using
Azure r2 and AWS r3, the latest version of each.
But Azure r2 needs OAuth2 r1 (not r2), while AWS r3 needs OAuth2 r2 (not r1).
Classic diamond dependency, right?
Ugo doesn’t care what it is. He just wants to build Unity.

<p>
Worse, it doesn’t appear to be anyone’s fault.
Alice wrote a better OAuth2 package.
Amy fixed some Azure bugs and went on vacation.
Anna decided AWS should use the new OAuth2
(an internal implementation detail)
and later added Zeta support.
Ugo wants Unity to use the latest Azure and AWS packages.
It’s very hard to say any of them did something wrong.
If these people aren’t wrong, then maybe the package manager is.
We’ve been assuming that there can be only one
version of OAuth2 in Ugo’s Unity build. Maybe that’s the problem:
maybe the package manager should allow different versions to be included in a single
build.
This example would seem to indicate that it must.

<p>
Ugo is still stuck, so he searches StackOverflow and finds out
about the package manager’s <code>-fmultiverse</code> flag,
which allows multiple versions, so that his program builds as:

<p>
<img name="deps-a2-short" class="center pad" width=550 height=351 src="deps-a2-short.png" srcset="deps-a2-short.png 1x, deps-a2-short@1.5x.png 1.5x, deps-a2-short@2x.png 2x, deps-a2-short@3x.png 3x, deps-a2-short@4x.png 4x">

<p>
Ugo tries this. It doesn’t work.
Digging further into the problem, Ugo discovers that both
Azure and AWS are using a popular OAuth2 middleware library
called Moauth that simplifies part of the OAuth2 processing.
Moauth is not a complete API replacement: users still import OAuth2
directly, but they use Moauth to simplify some of the API calls.
The details that Moauth helps with didn’t change from OAuth2 r1 to r2,
so Moauth r1 (the only version that exists) is compatible with either.
Both Azure r2 and AWS r3 use Moauth r1.
That works fine in programs using only Azure or only AWS,
but Ugo’s Unity build actually looks like:

<p>
<img name="deps-a3-short" class="center pad" width=550 height=454 src="deps-a3-short.png" srcset="deps-a3-short.png 1x, deps-a3-short@1.5x.png 1.5x, deps-a3-short@2x.png 2x, deps-a3-short@3x.png 3x, deps-a3-short@4x.png 4x">

<p>
Unity needs both copies of OAuth2, but then which one does Moauth import?

<p>
In order to make the build work, it would seem that we need two identical
copies of Moauth: one that imports OAuth2 r1, for use by Azure,
and a second that imports OAuth2 r2, for use by AWS.
A quick StackOverflow check shows that the package manager
has a flag for that: <code>-fclone</code>. Using this flag, Ugo’s program builds as:

<p>
<img name="deps-a4-short" class="center pad" width=550 height=451 src="deps-a4-short.png" srcset="deps-a4-short.png 1x, deps-a4-short@1.5x.png 1.5x, deps-a4-short@2x.png 2x, deps-a4-short@3x.png 3x, deps-a4-short@4x.png 4x">

<p>
This actually works and passes its tests,
although Ugo now wonders if there are more problems lurking.
He heads home for a late dinner.
<a class=anchor href="#chapter_3"><h3 id="chapter_3">Chapter 3</h3></a>


<p>
Back at Microsoft, Amy has returned from vacation.
She decides that Azure can keep using OAuth2 r1 for a while longer,
but she realizes that it would help users to let them pass
Moauth tokens directly into the Azure API.
She adds this to the Azure package in a backwards-compatible way and
releases Azure r3.
Over at Amazon, Anna likes the Azure package’s new Moauth-based API
and adds a similar API to the AWS package,
releasing AWS r4.

<p>
Ugo sees these changes and decides to update to the latest version
of both Azure and AWS in order to use the Moauth-based APIs.
This time he blocks off an afternoon.
First he tentatively updates the Azure and AWS packages
without modifying Unity at all. His program builds!

<p>
Excited, Ugo changes Unity to use the Moauth-based Azure API, and that builds too.
When he changes Unity to also use the Moauth-based AWS API, though, the build fails.
Perplexed, he reverts his Azure changes, leaving only the AWS changes, and the build succeeds.
He puts the Azure changes back, and the build fails again.
Ugo returns to StackOverflow.

<p>
Ugo learns that when using just one Moauth-based API (in this case, Azure) with <code>-fmultiverse</code> <code>-fclone</code>,
Unity implicitly builds as:

<p>
<img name="deps-a5-short" class="center pad" width=596 height=451 src="deps-a5-short.png" srcset="deps-a5-short.png 1x, deps-a5-short@1.5x.png 1.5x, deps-a5-short@2x.png 2x, deps-a5-short@3x.png 3x, deps-a5-short@4x.png 4x">

<p>
but when he is using both Moauth-based APIs, the single <code>import</code> <code>"moauth"</code> in Unity
is ambiguous. Since Unity is the main package, it cannot be cloned (in contrast to Moauth itself):

<p>
<img name="deps-a6-short" class="center pad" width=628 height=451 src="deps-a6-short.png" srcset="deps-a6-short.png 1x, deps-a6-short@1.5x.png 1.5x, deps-a6-short@2x.png 2x, deps-a6-short@3x.png 3x, deps-a6-short@4x.png 4x">

<p>
A comment on StackOverflow suggests moving the Moauth import into two different
packages and having Unity import them instead. Ugo tries this and, incredibly, it works:

<p>
<img name="deps-a7-short" class="center pad" width=561 height=601 src="deps-a7-short.png" srcset="deps-a7-short.png 1x, deps-a7-short@1.5x.png 1.5x, deps-a7-short@2x.png 2x, deps-a7-short@3x.png 3x, deps-a7-short@4x.png 4x">

<p>
Ugo makes it home on time. He’s not terribly happy with his package manager,
but he’s now a big fan of StackOverflow.
<a class=anchor href="#retelling_with_semantic_versioning"><h2 id="retelling_with_semantic_versioning">A Retelling with Semantic Versioning</h2></a>


<p>
Let’s wave a magic wand and retell the story with semantic versions,
assuming that the package manager uses them instead of the
original story’s ‘r’ numbers.

<p>
Here’s what changes:
<ul>
<li>
OAuth2 r1 becomes OAuth2 1.0.0.
<li>
Moauth r1 becomes Moauth 1.0.0.
<li>
Azure r1 becomes Azure 1.0.0.
<li>
AWS r1 becomes AWS 1.0.0.
<li>
OAuth2 r2 becomes OAuth2 2.0.0 (partly incompatible API).
<li>
Azure r2 becomes Azure 1.0.1 (bug fix).
<li>
AWS r2 becomes AWS 1.0.1 (bug fix, internal use of OAuth2 2.0.0).
<li>
AWS r3 becomes AWS 1.1.0 (feature update: add Zeta).
<li>
Azure r3 becomes Azure 1.1.0 (feature update: add Moauth APIs).
<li>
AWS r4 becomes AWS 1.2.0 (feature update: add Moauth APIs).</ul>


<p>
<i>Nothing else about the story changes.</i>
Ugo still runs into the same build problems,
and he still has to turn to StackOverflow to learn about build flags
and refactoring techniques just to keep Unity building.
According to semver, though, Ugo should have had no
trouble at all with any of his updates: not one of the packages
that Unity imports changed its major version
during the story.
Only OAuth2 did, deep in Unity's dependency tree.
Unity itself does not import OAuth2.
What went wrong?

<p>
The problem here is that the semver spec is really not
much more than a way to choose and compare version strings.
It says nothing else.
In particular, it says nothing about how to handle incompatible changes
after incrementing the major version number.

<p>
The most valuable part of semver is the encouragement
to make backwards-compatible changes when possible.
The FAQ correctly notes:<blockquote>

<p>
“Incompatible changes should not be introduced lightly to software
that has a lot of dependent code. The cost that must be incurred to
upgrade can be significant. Having to bump major versions to
release incompatible changes means you’ll think through the
impact of your changes and evaluate the cost/benefit ratio involved.”</blockquote>

<p>
I certainly agree that “incompatible changes should not be introduced lightly.”
Where I think semver falls short is the idea that “having to bump major versions”
is a step that will make you “think through the impact of your changes
and evaluate the cost/benefit ratio involved.”
Quite the opposite: it’s far too easy to read semver as implying that
as long as you increment the major version when you make an
incompatible change, everything else will work out.
The example shows that this is not the case.

<p>
From Alice’s point of view, the OAuth2 API needed backwards-incompatible changes,
and when she made them, semver seemed to promise it would be fine to release
an incompatible OAuth2 package, provided she gave it version 2.0.0.
But that semver-approved change triggered the cascade of problems
that befell Ugo and Unity.

<p>
Semantic versions are an important way for authors to convey expectations to users,
but that’s all they are.
By itself, it can’t be expected to solve these larger build problems.
Instead, let’s look at an approach that does solve the build problems.
Afterward, we can consider how to fit semver into that approach.
<a class=anchor href="#retelling_with_import_versioning"><h3 id="retelling_with_import_versioning">A Retelling with Import Versioning</h3></a>


<p>
Once again, let’s retell the story,
this time using the import compatibility rule:<blockquote>

<p>
<i>In Go, if an old package and a new package have the same import path,
<br>the new package must be backwards compatible with the old package.</i></blockquote>

<p>
Now the plot changes are more significant. The story starts out the same way,
but in Chapter 1, when Alice decides to create a new, partly incompatible OAuth2 API,
she cannot use <code>"oauth2"</code> as its import path. Instead, she names the new version Pocoauth
and gives it the import path <code>"pocoauth"</code>.
Presented with two different OAuth2 packages, Moe (the author of Moauth) must write
a second package, Moauth for Pocoauth, which he names
Pocomoauth and gives the import path <code>"pocomoauth"</code>.
When Anna updates the AWS package to the new OAuth2 API,
she also changes the import paths in that code from <code>"oauth2"</code> to <code>"pocoauth"</code>
and from <code>"moauth"</code> to <code>"pocomoauth"</code>.
Then the story proceeds as before, with the release of AWS r2 and AWS r3.

<p>
In Chapter 2, when Ugo eagerly adopts Amazon Zeta,
everything just works.
The imports in all the packages code exactly match what needs to be built.
He doesn’t have to look up special flags on StackOverflow,
and he’s only five minutes late to lunch.

<p>
<img name="deps-b1-short" class="center pad" width=550 height=517 src="deps-b1-short.png" srcset="deps-b1-short.png 1x, deps-b1-short@1.5x.png 1.5x, deps-b1-short@2x.png 2x, deps-b1-short@3x.png 3x, deps-b1-short@4x.png 4x">

<p>
In Chapter 3, Amy adds Moauth-based APIs to Azure
while Anna adds equivalent Pocomoauth-based APIs to AWS.

<p>
When Ugo decides to update both Azure and AWS, again there’s no problem.
His updated program builds without any special refactoring:

<p>
<img name="deps-b2-short" class="center pad" width=550 height=467 src="deps-b2-short.png" srcset="deps-b2-short.png 1x, deps-b2-short@1.5x.png 1.5x, deps-b2-short@2x.png 2x, deps-b2-short@3x.png 3x, deps-b2-short@4x.png 4x">

<p>
At the end of this version of the story, Ugo doesn’t even think about his
package manager. It just works; he barely notices that it’s there.

<p>
In contrast to the semantic versioning translation of the story,
the use of import versioning here changed two critical
details.
First, when Alice introduced her backwards-incompatible OAuth2 API,
she had to release it as a new package (Pocoauth).
Second, because Moe’s wrapper package Moauth exposed the OAuth2 package’s
type definitions in its own API, Alice’s release of a new package
forced Moe’s release of a new package (Pocomoauth).
Ugo’s final Unity build went well
because Alice’s and Moe’s package splits created
exactly the structure needed to keep clients like Unity building and running.
Instead of Ugo and users like him needing incomplete package manager complexity like
<code>-fmultiverse</code> <code>-fclone</code>
aided by extraneous refactorings,
the import compatibility rule pushes a small amount of
additional work onto package authors,
and all users benefit.

<p>
There is certainly a cost to needing to introduce a new name
for each backwards-incompatible API change, but as the semver FAQ says,
that cost should encourage authors to more clearly consider the impact of
such changes and whether they are truly necessary.
And in the case of Import Versioning, the cost pays for significant benefits to users.

<p>
An advantage of Import Versioning here is that package names
and import paths are well-understood concepts for Go developers.
If you tell an author that making a backwards-incompatible change requires
creating a different package with a different import path,
then—without any special knowledge of versioning—the author can reason through
the implications on client packages:
clients are going to need to change their own imports one at a time;
Moauth is not going to work with the new package;
and so on.

<p>
Able to predict the effects on users more clearly, authors might well
make different, better decisions about their changes.
Alice might look for way to introduce the new, cleaner API
into the original OAuth2 package alongside the existing APIs, to avoid a package split.
Moe might look more carefully at whether he can use interfaces
to make Moauth support both OAuth2 and Pocoauth,
avoiding a new Pocomoauth package.
Amy might decide it’s worth updating to Pocoauth and Pocomoauth
instead of exposing the fact that the Azure APIs use outdated
OAuth2 and Moauth packages.
Anna might have tried to make the AWS APIs allow either Moauth or
Pocomoauth, to make it easier for Azure users to switch.

<p>
In contrast, the implications of a semver “major version bump” are far less clear
and do not exert the same kind of design pressure on authors.
To be clear, this approach creates a bit more work for authors,
but that work is justified by delivering significant benefits to users.
In general, this balance makes sense, because
packages aim to have many more users than authors,
and hopefully all packages at least have as many users
as they do authors.
<a class=anchor href="#semantic_import_versioning"><h3 id="semantic_import_versioning">Semantic Import Versioning</h3></a>


<p>
The previous section showed how import versioning leads to
simple, predictable builds during updates.
But choosing a new name at every backwards-incompatible change
is difficult and unhelpful to users.
Given the choice between OAuth2 and Pocoauth, which should Amy use?
Without further investigation, there’s no way to know.
In contrast, semantic versioning makes this easy: OAuth2 2.0.0 is clearly
the intended replacement for OAuth2 1.0.0.

<p>
We can use semantic versioning <i>and</i> follow the import compatibility rule
by including the major version in the import path.
Instead of needing to invent a cute but unrelated new name like Pocoauth,
Alice can call her new API OAuth2 2.0.0, with the new import path <code>"oauth2/v2"</code>.
The same for Moe: Moauth 2.0.0 (imported as <code>"moauth/v2"</code>)
can be the helper package for OAuth2 2.0.0,
just as Moauth 1.0.0 was the helper package for OAuth2 1.0.0.

<p>
When Ugo adds Zeta support in Chapter 2, his build looks like:

<p>
<img name="deps-c1-short" class="center pad" width=567 height=467 src="deps-c1-short.png" srcset="deps-c1-short.png 1x, deps-c1-short@1.5x.png 1.5x, deps-c1-short@2x.png 2x, deps-c1-short@3x.png 3x, deps-c1-short@4x.png 4x">

<p>
Because <code>"moauth"</code> and <code>"moauth/v2"</code> are simply different packages,
it is perfectly clear to Ugo what he needs to do to use
<code>"moauth"</code> with Azure and <code>"moauth/v2"</code> with AWS:
import both.

<p>
<img name="deps-c2-short" class="center pad" width=550 height=467 src="deps-c2-short.png" srcset="deps-c2-short.png 1x, deps-c2-short@1.5x.png 1.5x, deps-c2-short@2x.png 2x, deps-c2-short@3x.png 3x, deps-c2-short@4x.png 4x">

<p>
For compatibility with existing Go usage and as a small encouragement
not to make backwards-incompatible API changes, I am assuming here that
major version 1 is omitted from import paths: <code>import</code> <code>"moauth"</code>, not <code>"moauth/v1"</code>.
Similarly, major version 0, which explicitly disavows compatibility,
is also omitted from import paths.
The idea here is that by using a v0 dependency, users are explicitly acknowledging
the possibility of breakage and taking on the responsibility to
deal with it when they choose to update.
(Of course, it's then important that updates don't happen
automatically.
We'll see in the next post how minimal version selection helps with that.)
<a class=anchor href="#functional_names_immutable_meanings"><h2 id="functional_names_immutable_meanings">Functional Names &amp; Immutable Meanings</h2></a>


<p>
Twenty years ago, Rob Pike and I were modifying the internals of a Plan 9 C library,
and Rob taught me the rule of thumb that when you change a function’s behavior,
you also change its name.
The old name had one meaning.
By using a different meaning for the new name
and eliminating the old one,
we ensured the compiler would complain loudly about every
piece of code that needed to be examined and updated,
instead of silently compiling incorrect code.
And if people had their own programs using the
function, they'd get a compile-time failure
instead of a long debugging session.
In today's world of distributed version control,
that last problem is magnified,
making the name change even more important.
A merge of concurrently-written code expecting the old semantics
should not silently get the new semantics instead.

<p>
Of course, deleting an old function works only when all the uses
can be found, or when users understand that they are responsible
for keeping up with changes, as was the case in a research
system like Plan 9.
For exported APIs, it's usually much better to leave the old name
and old behavior intact and only add a new name with new behavior.
Rich Hickey made the point in his “<a href="https://www.youtube.com/watch?v=oyLBGkS5ICk">Spec-ulation</a>” talk in 2016
that this approach of only adding new names and behaviors, never removing old
names or redefining their meanings,
is exactly what functional programming encourages with respect to
individual variables or data structures.
The functional approach brings benefits in clarity and predictability
in small-scale programming, and the benefits are even larger when
applied, as in the import compatibility rule, to whole APIs:
dependency hell is really just mutability hell writ large.
That’s just one small observation in the talk; the whole thing is worth watching.

<p>
In the early days of “<code>go</code> <code>get</code>”, when people asked about making backwards-incompatible changes,
our response—based
on intuition derived from years of experience with these kinds of software changes—was to give
the import versioning rule, but without a clear explanation why this
approach was better than not putting the major version in the import paths.
Go 1.2 added a FAQ entry about package versioning that gave this basic advice
(unchanged as of Go 1.10):<blockquote>

<p>
<i>Packages intended for public use should try to maintain backwards compatibility as they evolve.
The <a href="https://golang.org/doc/go1compat.html">Go 1 compatibility guidelines</a> are a good reference here:
don't remove exported names,
encourage tagged composite literals, and so on.
If different functionality is required, add a new name instead of changing an old one.
If a complete break is required, create a new package with a new import path.</i></blockquote>

<p>
One motivation for this blog post is to show, using a clear, believable
example, why following the rule is so important.
<a class=anchor href="#avoiding_singleton_problems"><h2 id="avoiding_singleton_problems">Avoiding Singleton Problems</h2></a>


<p>
One common objection to the semantic import versioning approach
is that package authors today expect that there is only ever one copy
of their package in a given build.
Allowing multiple packages at different major versions
may cause problems due to unintended duplications of singletons.
An example would be registering an HTTP handler.
If <code>my/thing</code> registers an HTTP handler for <code>/debug/my/thing</code>,
then having two copies of the package will result in duplicate
registrations, which causes a panic at registration time.
Another problem would be if there were two HTTP stacks in
the program.
Clearly only one HTTP stack can listen on port 80;
we wouldn't want half the program registering handlers
that will not be used.
Go developers are already running into problems like this
due to vendoring inside vendored packages.

<p>
Moving to <code>vgo</code> and semantic import versioning
clarifies and simplifies the current situation though.
Instead of the uncontrolled duplication caused by
vendoring inside vendoring, authors will have a guarantee
that there is only one instance of each major version of their packages.
By including the major version into the import path,
it should be clearer to authors that <code>my/thing</code> and <code>my/thing/v2</code>
are different and need to be able to coexist.
Perhaps that means exporting debug information for v2 on
<code>/debug/my/thing/v2</code>.
Or perhaps it means coordinating.
Maybe v2 can take charge of registering the handler
but also provide a hook for v1 to supply information
to display on the page.
This would mean <code>my/thing</code> importing <code>my/thing/v2</code>
or vice versa;
with different import paths, that's easy to do
and easy to understand.
In contrast, if both v1 and v2 are <code>my/thing</code>
it's hard to comprehend what it means for one to
import its own import path and get the other.
<a class=anchor href="#automatic_api_updates"><h2 id="automatic_api_updates">Automatic API Updates</h2></a>


<p>
One of the key reasons to allow both v1 and v2 of a package to coexist in a
large program is to make it possible to upgrade the clients of that package
one at a time and still have a buildable result.
This is specific instance of the more general problem of
gradual code repair.
(See my 2016 article, “<a href="https://talks.golang.org/2016/refactor.article">Codebase Refactoring (with help from Go)</a>,”
for more on that problem.)

<p>
In addition to keeping programs building, semantic import versioning
has a significant benefit to gradual code repair, which I touched on
in the previous section:
one major version of a package can import and be written in terms of another.
It is trivial for the v2 API to be written as a wrapper of the
v1 implementation, or vice versa.
This lets them share the code and, with appropriate design choices
and perhaps use of type aliases, might even allow clients using v1 and v2 to interoperate.
It may also help resolve a key technical problem in defining automatic API updates.

<p>
Before Go 1, we relied heavily on <code>go</code> <code>fix</code>, which users ran after
updating to a new Go release and finding their programs no longer compiled.
Updating code that doesn’t compile
makes it impossible to use most of our program analysis
tools, which require that their inputs are valid programs.
Also, we’ve wondered how to allow authors of
packages outside the Go standard library to supply “fixes” specific
to their own API updates.
The ability to name and work with multiple incompatible versions of a package
in a single program suggests a possible solution:
if a v1 API function can be implemented as a wrapper around the v2 API,
the wrapper implementation can double as the fix specification.
For example, suppose v1 of an API has functions <code>EnableFoo</code> and <code>DisableFoo</code>
and v2 replaces the pair with a single <code>SetFoo(enabled</code> <code>bool)</code>.
After v2 is released, v1 can be implemented as a wrapper around v2:
<pre>package p // v1

import v2 "p/v2"

func EnableFoo() {
	//go:fix
	v2.SetFoo(true)
}

func DisableFoo() {
	//go:fix
	v2.SetFoo(false)
}
</pre>


<p>
The special <code>//go:fix</code> comments would indicate to <code>go</code> <code>fix</code> that the
wrapper body that follows should be inlined into the call site.
Then running <code>go</code> <code>fix</code> would rewrite calls to v1 <code>EnableFoo</code> to v2 <code>SetFoo(true)</code>.
The rewrite is easily specified and type-checked, since it is plain Go code.
Even better, the rewrite is clearly safe:
v1 <code>EnableFoo</code> is <i>already</i> calling v2 <code>SetFoo(true)</code>,
so rewriting the call site plainly does not change the meaning of the program.

<p>
It is plausible that <code>go</code> <code>fix</code> might use symbolic execution
to fix even the reverse API change, from a v1 with <code>SetFoo</code> to a v2 with <code>EnableFoo</code> and <code>DisableFoo</code>.
The v1 <code>SetFoo</code> implementation could read:
<pre>package q // v1

import v2 "q/v2"

func SetFoo(enabled bool) {
	if enabled {
		//go:fix
		v2.EnableFoo()
	} else {
		//go:fix
		v2.DisableFoo()
	}
}
</pre>


<p>
and then <code>go</code> <code>fix</code> would update <code>SetFoo(true)</code> to <code>EnableFoo()</code> and <code>SetFoo(false)</code> to <code>DisableFoo()</code>.
This kind of fix would even apply to API updates within a single major version.
For example, v1 could be deprecating (but keeping) <code>SetFoo</code> and introducing <code>EnableFoo</code> and <code>DisableFoo</code>.
The same kind of fix would help callers move away from the deprecated API.

<p>
To be clear, this is not implemented today,
but it seems promising, and this kind of tooling is made possible
by giving different things different names.
These examples demonstrate the power of having durable, immutable names
attached to specific code behavior.
We need only follow the
rule that when you make a change to something, you also change its name.
<a class=anchor href="#committing_to_compatibility"><h2 id="committing_to_compatibility">Committing to Compatibility</h2></a>


<p>
Semantic import versioning is more work for authors of packages.
They can't just decide to issue v2, walk away from v1,
and leave users like Ugo to deal with the fallout.
But authors who do that are hurting their users.
It seems to me a good thing if the system makes it harder
to hurt users and instead naturally steers authors toward
behaviors that don't hurt users.

<p>
More generally, Sam Boyer talked at GopherCon 2017
about how package managers moderate our social interactions,
the collaboration of people building software.
We get to decide.
Do we want to work in a community built around a system that optimizes for
compatibility, smooth transitions, and working well together?
Or do we want to work in a community built around a system that optimizes for
creating and describing incompatibility,
that makes it acceptable for authors to break users' programs?
Import versioning, and in particular handling semantic versioning
by lifting the semantic major version into the import path,
is how we can make sure we work in the first kind of community.

<p>
Let's commit to compatibility.
      </div>
      
      
      <div id="disqus_thread"></div>
      <script>
      var disqus_config = function () {
          this.page.url = "https://research.swtch.com/vgo-import";  
          this.page.identifier = "blog/vgo-import"; 
      };
      (function() { 
          var d = document, s = d.createElement('script');
          s.src = '//swtch.disqus.com/embed.js';
          s.setAttribute('data-timestamp', +new Date());
          (d.head || d.body).appendChild(s);
      })();
      </script>
      <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
      </div>
      
    </div>

    
<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
var pageTracker = _gat._getTracker("UA-3319603-2");
pageTracker._initData();
pageTracker._trackPageview();
</script>

    
    
  </body>
</html>
















