<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <title>research!rsc: Defining Go Modules (Go &amp; Versioning, Part 6)</title>
    <link rel="alternate" type="application/atom+xml" title="research!rsc - Atom" href="http://research.swtch.com/feed.atom" />
    
<meta name="viewport" content="width=device-width, initial-scale=1">
<link href='https://fonts.googleapis.com/css?family=Inconsolata:400,700' rel='stylesheet' type='text/css'>
<script type="text/javascript" src="https://use.typekit.com/skm6yij.js"></script>
<script type="text/javascript">try{Typekit.load();}catch(e){}</script>
<style>
  body {
    padding: 0;
    margin: 0;
    font-size: 100%;
    font-family: 'Minion Pro';
  }
  @media print {
    img {page-break-inside: avoid;}
    div.nosplit {page-break-inside: avoid;}
  }
  img.center {
    display: block;
    margin: 0 auto;
  }
  .pad {
    padding-top: 1em;
    padding-bottom: 1em;
  }
  a.anchor, a.back, a.footnote {
    color: black !important;
    text-decoration: none !important;
  }
  a.back {
    font-size: 50%;
  }
  @media print {
    a.back {display: none;}
  }
  .header {
    height: 1.25em;
    background-color: #dff;
    margin: 0;
    padding: 0.1em 0.1em 0.2em;
    border-top: 1px solid black;
    border-bottom: 1px solid #8ff;
  }
  .header h3 {
    margin: 0;
    padding: 0 2em;
    display: inline-block;
    padding-right: 2em;
    font-style: italic;
    font-size: 90%;
  }
  .rss {
    float: right;
    padding-top: 0.2em;
    padding-right: 2em;
    display: none;
  }
  .toc {
    margin-top: 2em;
  }
  .toc-title {
    font-family: "caflisch-script-pro";
    font-size: 300%;
    line-height: 50%;
  }
  .toc-subtitle {
    display: block;
    margin-bottom: 1em;
    font-size: 83%;
  }
  @media only screen and (max-width: 550px) { .toc-subtitle { display: none; } }
  .header h3 a {
    color: black;
  }
  .header h4 {
    margin: 0;
    padding: 0;
    display: inline-block;
    font-weight: normal;
    font-size: 83%;
  }
  @media only screen and (max-width: 550px) { .header h4 { display: none; } }
  .main {
    padding: 0 2em;
  }
  @media only screen and (max-width: 479px) { .article { font-size: 120%; } }
  .article h1 {
    text-align: center;
    font-size: 200%;
  }
  .copyright {
    font-size: 83%;
  }
  .subtitle {
      font-size: 65%;
  }
  .normal {
    font-size: medium;
    font-weight: normal;
  }
  .when {
    text-align: center;
    font-size: 100%;
    margin: 0;
    padding: 0;
  }
  .when p {
    margin: 0;
    padding: 0;
  }
  .article h2 {
    font-size: 125%;
    padding-top: 0.25em;
  }
  .article h3 {
    font-size: 100%;
  }
  pre {
    margin-left: 4em;
    margin-right: 4em;
  }
  pre, code {
    font-family: 'Inconsolata', monospace;
    font-size: 100%;
  }
  .footer {
    margin-top: 10px;
    font-size: 83%;
    font-family: sans-serif;
  }
  .comments {
    margin-top: 2em;
    background-color: #ffe;
    border-top: 1px solid #aa4;
    border-left: 1px solid #aa4;
    border-right: 1px solid #aa4;
  }
  .comments-header {
    padding: 0 5px 0 5px;
  }
  .comments-header p {
    padding: 0;
    margin: 3px 0 0 0;
  }
  .comments-body {
    padding: 5px 5px 5px 5px;
  }
  #plus-comments {
    border-bottom: 1px dotted #ccc;
  }
  .plus-comment {
    width: 100%;
    font-size: 14px;
    border-top: 1px dotted #ccc;
  }
  .me {
    background-color: #eec;
  }
  .plus-comment ul {
    margin: 0;
    padding: 0;
    list-style: none;
    width: 100%;
    display: inline-block;
  }
  .comment-when {
    color:#999;
    width:auto;
    padding:0 5px;
  }
  .old {
    font-size: 83%;
  }
  .plus-comment ul li {
    display: inline-block;
    vertical-align: top;
    margin-top: 5px;
    margin-bottom: 5px;
    padding: 0;
  }
  .plus-icon {
    width: 45px;
  }
  .plus-img {
    float: left;
    margin: 4px 4px 4px 4px;
    width: 32px;
    height: 32px;
  }
  .plus-comment p {
    margin: 0;
    padding: 0;
  }
  .plus-clear {
    clear: left;
  }
  .toc-when {
    font-size: 83%;
    color: #999;
  }
  .toc {
    list-style: none;
  }
  .toc li {
    margin-bottom: 0.5em;
  }
  .toc-head {
    margin-bottom: 1em !important;
    font-size: 117%;
  }
  .toc-summary {
    margin-left: 2em;
  }
  .favorite {
    font-weight: bold;
  }
  .article p, .article ol {
    line-height: 144%;
  }
  sup, sub {
    vertical-align: baseline;
    position: relative;
    font-size: 83%;
  }
  sup {
    bottom: 1ex;
  }
  sub {
    top: 0.8ex;
  }

  .main {
    position: relative;
    margin: 0 auto;
    padding: 0;
    width: 900px;
  }
  @media only screen and (min-width: 768px) and (max-width: 959px) { .main { width: 708px; } }
  @media only screen and (min-width: 640px) and (max-width: 767px) { .main { width: 580px; } }
  @media only screen and (min-width: 480px) and (max-width: 639px) { .main { width: 420px; } }
  @media only screen and (max-width: 479px) { .main { width: 300px; } }

</style>

  </head>
  <body>
    
<div class="header">
  <h3><a href="/">research!rsc</a></h3>
  <h4>Thoughts and links about programming,
    by <a href="https://swtch.com/~rsc/" rel="author">Russ Cox</a> </h4>
  <a class="rss" href="/feed.atom"><img src="/feed-icon-14x14.png" /></a>
</div>

    <div class="main">
      <div class="article">
        <h1>Defining Go Modules
        
        <div class="subtitle">(<i><a href="vgo">Go &amp; Versioning</a>, Part 6</i>)</div>
        
        <div class="normal">
        <div class="when">
          
            Posted on Thursday, February 22, 2018.
            
           <font size="-1"><a href="vgo-module.pdf">PDF</a></font>
        </div>
        </div>
        </h1>
        

<p>
As introduced in the <a href="vgo-intro">overview post</a>, a Go <i>module</i>
is a collection of packages versioned as a unit,
along with a <code>go.mod</code> file listing other required modules.
The move to modules is an opportunity for us to revisit and fix
many details of how the <code>go</code> command manages source code.
The current <code>go</code> <code>get</code> model will be about ten years old when we
retire it in favor of modules.
We need to make sure that the module design will serve us
well for the next decade. In particular:
<ul>
<li>


<p>
We want to encourage more developers to tag releases of their
packages, instead of expecting that
users will just pick a commit hash that looks good to them.
Tagging explicit releases makes clear what is expected to be
useful to others and what is still under development.
At the same time, it must still be possible—although maybe not convenient—to request specific
commits.
<li>


<p>
We want to move away from invoking version control
tools such as <code>bzr</code>, <code>fossil</code>, <code>git</code>, <code>hg</code>, and <code>svn</code> to download source code.
These fragment the ecosystem: packages developed using Bazaar or
Fossil, for example, are effectively unavailable to users who cannot
or choose not to install these tools.
The version control tools have also been a source of <a href="https://golang.org/issue/22131">exciting</a> <a href="https://www.mercurial-scm.org/wiki/WhatsNew/Archive#Mercurial_3.2.3_.282014-12-18.29">security</a> <a href="https://git-blame.blogspot.com/2014/12/git-1856-195-205-214-and-221-and.html">problems</a>.
It would be good to move them outside the security perimeter.
<li>


<p>
We want to allow multiple modules to be developed in a single
source code repository but versioned independently.
While most developers will likely keep working with one module per repo,
larger projects might benefit from having multiple modules in a single repo.
For example, we'd like to keep <code>golang.org/x/text</code> a single repository
but be able to version experimental new packages separately
from established packages.
<li>


<p>
We want to make it easy for individuals and companies to
put caching proxies in front of <code>go</code> <code>get</code> downloads, whether for availability
(use a local copy to ensure the download works tomorrow)
or security
(vet packages before they can be used inside a company).
<li>


<p>
We want to make it possible, at some future point, to introduce
a shared proxy for use by the Go community, similar in spirit
to those used by Rust, Node, and other languages.
At the same time, the design must work well without assuming
such a proxy or registry.
<li>


<p>
We want to eliminate vendor directories. They were introduced
for reproducibility and availability, but we now have better
mechanisms.
Reproducibility is handled by proper versioning, and availability
is handled by caching proxies.</ul>


<p>
This post presents the parts of the <code>vgo</code> design that address
these issues.
Everything here is preliminary: we will change the design
if we find that it is not right.
<a class=anchor href="#versioned_releases"><h2 id="versioned_releases">Versioned Releases</h2></a>


<p>
Abstraction boundaries let projects scale.
Originally, all Go packages could be imported by all other Go packages.
We introduced the <a href="https://golang.org/s/go14internal"><code>internal</code> directory convention</a>
in Go 1.4 to eliminate the problem that
developers who chose to structure a program as multiple packages
had to worry about other users importing and depending on details of
helper packages never meant for public use.

<p>
The Go community has a similar visibility problem now with
repository commits.
Today, it's very common for users to identify package versions
by commit identifiers (usually Git hashes),
with the result that developers who structure work as a sequence
of commits need to worry, at least in the back of their mind,
about users pinning to any of those commits,
which again were never meant for public use.
We need to change the expectations in the Go open source community,
to establish a norm that authors tag releases and users prefer those.

<p>
I don't think this point, that users should be choosing from versions
issued by authors instead of picking out individual commits
from the Git history, is particularly controversial.
The difficult part is shifting the norm.
We need to make it easy for authors to tag commits
and easy for users to use those tags.

<p>
The most common way authors share code today is on code hosting sites,
especially GitHub.
For code on GitHub, all authors will need to do is tag a commit
and push the tag.
We also plan to provide a tool, maybe called <code>go</code> <code>release</code>,
to compare different versions of a module
for API compatibility at the type level, to catch inadvertent
breaking changes that are visible in the type system,
and also to help authors decide between issuing
should be a minor release (because it adds new API or changes many lines of code)
or only a patch release.

<p>
For users, <code>vgo</code> itself operates entirely in terms of tagged versions.
However, we know that at least during the transition from old practices to new,
and perhaps indefinitely as a way to bootstrap new projects,
an escape hatch will be necessary, to allow specifying a commit.
This is possible in <code>vgo</code>, but it has been designed so as to
make users prefer explicitly tagged versions.

<p>
Specifically, <code>vgo</code> understands the special pseudo-version
<code>v0.0.0-</code><i>yyyymmddhhmmss</i><code>-</code><i>commit</i>
as referring to the given commit identifier,
which is typically a shortened Git hash
and which must have a commit time matching the (UTC) timestamp.
This form is a valid semantic version string
for a prerelease of v0.0.0.
For example, this pair of <code>Gopkg.toml</code> stanzas:
<pre>[[projects]]
  name = "google.golang.org/appengine"
  packages = [
    "internal",
    "internal/base",
    "internal/datastore",
    "internal/log",
    "internal/remote_api",
    "internal/urlfetch",
    "urlfetch"
  ]
  revision = "150dc57a1b433e64154302bdc40b6bb8aefa313a"
  version = "v1.0.0"

[[projects]]
  branch = "master"
  name = "github.com/google/go-github"
  packages = ["github"]
  revision = "922ceac0585d40f97d283d921f872fc50480e06e"
</pre>


<p>
correspond to these <code>go.mod</code> lines:
<pre>require (
	"google.golang.org/appengine" v1.0.0
	"github.com/google/go-github" v0.0.0-20180116225909-922ceac0585d
)
</pre>


<p>
The pseudo-version form is chosen so that the standard
semver precedence rules compare two pseudo-versions by commit time,
because the timestamp encoding makes string comparison match time comparison.
The form also ensures that <code>vgo</code> will always prefer a tagged semantic version
over an untagged pseudo-version,
beacuse even if v0.0.1 is very old, it has a greater semver precedence than any v0.0.0 prerelease.
(Note also that this matches the choice made by <code>dep</code> when adding a new
dependency to a project.)
And of course pseudo-version strings are unwieldy:
they stand out in <code>go.mod</code> files and <code>vgo</code> <code>list</code> <code>-m</code> output.
All these inconveniences help encourage authors and users
to prefer explicitly tagged versions,
a bit like the extra step of having to write <code>import</code> <code>"unsafe"</code>
encourages developers to prefer writing safe code.
<a class=anchor href="#go.mod_file"><h2 id="go.mod_file">The <code>go.mod</code> File</h2></a>


<p>
A module version is defined by a tree of source files.
The <code>go.mod</code> file describes the module and also indicates the root directory.
When <code>vgo</code> is run in a directory, it looks in the current
directory and then successive parents to find the <code>go.mod</code>
marking the root.

<p>
The file format is line-oriented, with <code>//</code> comments only.
Each line holds a single directive, which is a single verb
(<code>module</code>, <code>require</code>, <code>exclude</code>, or <code>replace</code>, as defined by
<a href="vgo-mvs">minimum version selection</a>),
followed by arguments:
<pre>module "my/thing"
require "other/thing" v1.0.2
require "new/thing" v2.3.4
exclude "old/thing" v1.2.3
replace "bad/thing" v1.4.5 =&gt; "good/thing" v1.4.5
</pre>


<p>
The leading verb can be factored out of adjacent lines,
leading to a block, like in Go imports:
<pre>require (
	"new/thing" v2.3.4
	"old/thing" v1.2.3
)
</pre>


<p>
My goals for the file format were that it be (1) clear and simple,
(2) easy for people to read, edit, manipulate, and diff,
(3) easy for programs like <code>vgo</code> to read, modify, and write back,
preserving comments and general structure,
and
(4) have room for limited future growth.
I looked at JSON, TOML, XML, and YAML but none of them
seemed to have those four properties all at once.
For example, the approach used in <code>Gopkg.toml</code> above
leads to three lines for each requirement,
making them harder to skim, sort, and diff.
Instead I designed a minimal format reminiscent
of the top of a Go program, but hopefully not close enough to be
confusing.
I adapted an existing comment-friendly parser.

<p>
The eventual <code>go</code> command integration may change the
file format, perhaps even adopting a more standard framing,
but for compatibility we will keep the ability to read today's
<code>go.mod</code> files, just as <code>vgo</code> can also read requirement information from
<code>GLOCKFILE</code>, <code>Godeps/Godeps.json</code>, <code>Gopkg.lock</code>, <code>dependencies.tsv</code>,
<code>glide.lock</code>, <code>vendor.conf</code>, <code>vendor.yml</code>, <code>vendor/manifest</code>,
and <code>vendor/vendor.json</code> files.
<a class=anchor href="#from_repository_to_modules"><h2 id="from_repository_to_modules">From Repository to Modules</h2></a>


<p>
Developers work in version control systems,
and clearly <code>vgo</code> must make that as easy as possible.
It is not reasonable to expect developers to prepare
module archives themselves, for example.
Instead, <code>vgo</code> makes it easy to export modules
directly from any version control repository
following some basic, unobtrusive conventions.

<p>
To start, it suffices to create a repository
and tag a commit, using a semver-formatted tag like <code>v0.1.0</code>.
The leading <code>v</code> is required, and having three numbers is also required.
Although <code>vgo</code> itself accepts shorthands like <code>v0.1</code> on the command
line, the canonical form <code>v0.1.0</code> must be used
in repository tags, to avoid ambiguity.
Only the tag is required.
In order to use commits made without use of <code>vgo</code>,
a <code>go.mod</code> file is not strictly required at this point.
Creating new tagged commits creates new module versions.
Easy.

<p>
When developers reach v2, semantic import versioning
means that a <code>/v2/</code> is added to the import path
at the end of the module root prefix: <code>my/thing/v2/sub/pkg</code>.
There are good reasons for this convention, as described in the <a href="vgo-import">earlier post</a>,
but it is still a departure from existing tools.
Realizing this, <code>vgo</code> will not use any v2 or later tag
in a source code repository without first checking that it
has a <code>go.mod</code> with a module path declaration ending in that
major version
(for example, <code>module</code> <code>"my/thing/v2"</code>).
<code>Vgo</code> uses that declaration as evidence that the author
is using semantic import versioning
to name packages within that module.
This is especially important for multi-package modules,
since the import paths within the module must
contain the <code>/v2/</code> element to avoid referring back to the v1 module.

<p>
We expect that most developers will prefer to follow
the usual “major branch” convention,
in which different major versions live in different branches.
In this case,
the root directory in a v2 branch would
have a <code>go.mod</code> indicating v2, like this:

<p>
<img name="gitmod-1" class="center pad" width=591 height=416 src="gitmod-1.png" srcset="gitmod-1.png 1x, gitmod-1@1.5x.png 1.5x, gitmod-1@2x.png 2x, gitmod-1@3x.png 3x, gitmod-1@4x.png 4x">

<p>
This is roughly how most developers already work.
In the picture, the v1.0.0 tag points to a commit that predates <code>vgo</code>.
It has no <code>go.mod</code> file at all, and that works fine.
In the commit tagged v1.0.1,
the author has added a <code>go.mod</code> file
that says <code>module</code> <code>"my/thing"</code>.
After that commit, however, the author forks
a new v2 development branch.
In addition to whatever code changes prompted v2
(including the replacement of <code>bar</code> with <code>quux</code>),
the <code>go.mod</code> in that new branch is updated
to say <code>module</code> <code>"my/thing/v2"</code>.
The branches can then proceed independently.
In truth, <code>vgo</code> really has no idea about branches.
It just resolves the tag to a commit and then looks
at the <code>go.mod</code> file in the commit.
Again, the <code>go.mod</code> file is required for v2 and later
so that <code>vgo</code> can use the <code>module</code> line
as a sign that the code has been written
with semantic import versioning in mind,
so the imports in <code>foo</code> say <code>my/thing/v2/foo/quux</code>,
not <code>my/thing/foo/quux</code>.

<p>
As an alternative, <code>vgo</code> also supports a
“major subdirectory” convention,
in which major versions above v1
are developed in subdirectories:

<p>
<img name="gitmod-2" class="center pad" width=376 height=768 src="gitmod-2.png" srcset="gitmod-2.png 1x, gitmod-2@1.5x.png 1.5x, gitmod-2@2x.png 2x, gitmod-2@3x.png 3x, gitmod-2@4x.png 4x">

<p>
In this case, v2.0.0 is created not by forking the whole tree
into a separate branch but by copying it into a subdirectory.
Again the <code>go.mod</code> must be updated to say
<code>"my/thing/v2"</code>.
Afterward, v1.x.x tags pointing at commits address the files
in the root directory, excluding <code>v2/</code>,
while v2.x.x tags pointing at commits address the files
in the <code>v2/</code> subdirectory only.
The <code>go.mod</code> file lets <code>vgo</code> distinguishes the two cases.
It would also be meaningful to have a v1.x.x and a v2.x.x tag
pointing at the same commit: they would
address different subtrees of the commit.

<p>
We expect that developers may feel strongly about
choosing one convention or the other.
Instead of taking sides, <code>vgo</code> supports both.
Note that for major versions above v2,
the major subdirectory approach may
provide a more graceful transition for users of <code>go</code> <code>get</code>.
On the other hand, users of <code>dep</code> or vendoring tools
should be able to consume repositories using either convention.
Certainly we will make sure <code>dep</code> can.
<a class=anchor href="#multiple-module_repositories"><h3 id="multiple-module_repositories">Multiple-Module Repositories</h3></a>


<p>
Developers may also find it useful to maintain a collection of
modules in a single source code repository.
We want <code>vgo</code> to support this possibility.
In general, there is already wide variation in how different
developers, teams, projects, and companies apply
source control, and we do not believe it is productive to
impose a single mapping like “one repository equals one module”
onto all developers.
Having some flexibility here should also help <code>vgo</code> adapt
as best practices around souce control continue to change.

<p>
In the major subdirectory convention,
<code>v2/</code> contains the module <code>"my/thing/v2"</code>.
A natural extension is to allow subdirectories
not named for major versions.
For example, we could add a <code>blue/</code> subdirectory
that contains the module <code>"my/thing/blue"</code>,
confirmed by a <code>blue/go.mod</code> file with that module path.
In this case, the source control commit tags addressing that module
would take the form <code>blue/v1.x.x</code>.
Similarly, the tag <code>blue/v2.x.x</code> would address the <code>blue/v2/</code> subdirectory.
The existence of the <code>blue/go.mod</code> file excludes the <code>blue/</code> tree
from the outer <code>my/thing</code> module.

<p>
In the Go project, we intend to explore using this convention to allow
repositories like <code>golang.org/x/text</code> to define multiple,
independent modules.
This lets us retain the convenience of coarse-grained source control
but still promote different subtrees to v1 at different times.
<a class=anchor href="#deprecated_versions"><h3 id="deprecated_versions">Deprecated Versions</h3></a>


<p>
Authors also need to be able to deprecate a version,
to indicate that it should not be used anymore.
This is not yet implemented in the <code>vgo</code> prototype,
but one way it could work would be to define that
on code hosting sites, the existence of a tag v1.0.0+deprecated
(ideally pointing at the same commit as v1.0.0)
would indicate that the commit is deprecated.
It is of course important not to remove the tag entirely,
because that will break builds.
Deprecated modules would be highlighted in some way
in <code>vgo</code> <code>list</code> <code>-m</code> <code>-u</code> output (“show me my modules and information
about updates”),
so that users would know to update.

<p>
Also, because programs will have access to their own module
lists and versions at runtime, a program could also be configured
to check its own module versions against some chosen authority
and self-report in some way when it is running deprecated versions.
Again, the details here are not worked out,
but it's a good example of something that's possible
once developers and tools share a vocabulary for
describing versions.
<a class=anchor href="#publishing"><h3 id="publishing">Publishing</h3></a>


<p>
Given a source control repository,
developers need to be able to
publish it in a form that <code>vgo</code> can consume.
In the general case, we will provide a command that authors run to
turn their source control repositories into file trees that can be
served to <code>vgo</code> by any web server capable of serving static files.
Similar to current <code>go</code> <code>get</code>, <code>vgo</code> expects a page with a <code>&lt;meta&gt;</code> tag
to help translate from a module name to the tree of files
for that module.
For example, to look up <code>swtch.com/testmod</code>, the <code>vgo</code> command
fetches the usual page:
<pre>$ curl -sSL 'https://swtch.com/testmod?go-get=1'
&lt;!DOCTYPE html&gt;
&lt;meta name="go-import" content="swtch.com/testmod mod https://storage.googleapis.com/gomodules/rsc"&gt;
Nothing to see here.
$ 
</pre>


<p>
The <code>mod</code> server type indicates that modules are served
in a file tree at that base URL.
The relevant files at <i>storage.googleapis.com/gomodules/rsc</i> in this simple case are:
<ul>
<li>
<a href="https://storage.googleapis.com/gomodules/rsc/swtch.com/testmod/@v/list"><code>.../swtch.com/testmod/@v/list</code></a>
<li>
<a href="https://storage.googleapis.com/gomodules/rsc/swtch.com/testmod/@v/v1.0.0.info"><code>.../swtch.com/testmod/@v/v1.0.0.info</code></a>
<li>
<a href="https://storage.googleapis.com/gomodules/rsc/swtch.com/testmod/@v/v1.0.0.mod"><code>.../swtch.com/testmod/@v/v1.0.0.mod</code></a>
<li>
<a href="https://storage.googleapis.com/gomodules/rsc/swtch.com/testmod/@v/v1.0.0.zip"><code>.../swtch.com/testmod/@v/v1.0.0.zip</code></a></ul>


<p>
The exact meaning of these URLs is discussed in the “Download Protocol” section later in the post.
<a class=anchor href="#code_hosting_sites"><h3 id="code_hosting_sites">Code Hosting Sites</h3></a>


<p>
A huge amount of development happens on code hosting sites,
and we want that work to integrate into <code>vgo</code> as smoothly as possible.
Instead of expecting developers to publish modules elsewhere,
<code>vgo</code> will have support for reading the information it needs
from those sites directly, using their HTTP-based APIs.
In general, archive downloads can be significantly faster than
the existing version control checkouts.
For example, working on a laptop with a gigabit internet connection,
it takes 10 seconds to download the
<a href="https://github.com/cockroachdb/cockroach">CockroachDB source tree</a>
as a zip file from GitHub
but almost four minutes to <code>git</code> <code>clone</code> it.
Sites need only provide an archive of any form that can be fetched
with a simple HTTP GET.
Gerrit servers, for example, only support downloading gzipped tar files.
<code>Vgo</code> translates downloaded archives into the standard form.

<p>
The initial prototype only includes support for GitHub and the Go project's Gerrit server,
but we will add support for Bitbucket and other major hosting sites too,
before shipping anything in the main Go toolchain.

<p>
With the combination of the lightweight repository conventions,
which mostly match what developers are already doing,
and the support for known code hosting sites,
we expect that most open source activity will be unaffected by
the move to modules,
other than simply adding a <code>go.mod</code> to each repository.

<p>
Companies taking advantage of old <code>go</code> <code>get</code>'s direct use of
<code>git</code> and other source control tools will need to adjust.
Perhaps it would make sense to write a proxy that serves
the <code>vgo</code> expectations but using version control tools.
Companies could then run one of those to produce
an experience much like using the open source hosting sites.
<a class=anchor href="#module_archives"><h2 id="module_archives">Module Archives</h2></a>


<p>
The mapping from repositories to modules is a bit complex,
because the way developers use source control varies.
The end goal is to map all that complexity down
into a common, single format for Go modules
for use by proxies or other code consumers
(for example, <i>godoc.org</i> or any code checking tools).

<p>
The standard format in the <code>vgo</code> prototype is zip archives
in which all paths begin
with the module path and version.
For example, after running <code>vgo</code> <code>get</code> of
<code>rsc.io/quote</code> v1.5.2,
you can find the zip file in <code>vgo</code>'s download cache:
<pre>$ unzip -l $GOPATH/src/v/cache/rsc.io/quote/@v/v1.5.2.zip
     1479  00-00-1980 00:00   rsc.io/quote@v1.5.2/LICENSE
      131  00-00-1980 00:00   rsc.io/quote@v1.5.2/README.md
      240  00-00-1980 00:00   rsc.io/quote@v1.5.2/buggy/buggy_test.go
       55  00-00-1980 00:00   rsc.io/quote@v1.5.2/go.mod
      793  00-00-1980 00:00   rsc.io/quote@v1.5.2/quote.go
      917  00-00-1980 00:00   rsc.io/quote@v1.5.2/quote_test.go
$ 
</pre>


<p>
I used zip because it is well-specified, widely supported, and
cleanly extensible if needed, and it allows random access to individual files.
(In contrast, tar files, the other obvious choice, are none of these things and don't.)
<a class=anchor href="#download_protocol"><h2 id="download_protocol">Download Protocol</h2></a>


<p>
To download information about modules, as well as the modules themselves,
the <code>vgo</code> prototype issues only simple HTTP GET requests.
A key design goal was to make it possible to serve modules from
static hosting sites, so the requests have no URL query parameters.

<p>
As we saw earlier, custom domains can specify that a module
is hosted at a particular base URL.
As implemented in <code>vgo</code> today (but, like all of <code>vgo</code>, subject to change),
that module-hosting server must serve four request forms:
<ul>
<li>
<code>GET</code> <i>baseURL</i><code>/</code><i>module</i><code>/@v/list</code> fetches a list of all known versions, one per line.
<li>
<code>GET</code> <i>baseURL</i><code>/</code><i>module</i><code>/@v/</code><i>version</i><code>.info</code> fetches JSON-formatted metadata about that version.
<li>
<code>GET</code> <i>baseURL</i><code>/</code><i>module</i><code>/@v/</code><i>version</i><code>.mod</code> fetches the <code>go.mod</code> file for that version.
<li>
<code>GET</code> <i>baseURL</i><code>/</code><i>module</i><code>/@v/</code><i>version</i><code>.zip</code> fetches the zip file for that version.</ul>


<p>
The JSON information served in the <i>version</i><code>.info</code> form will likely evolve,
but today it corresponds to this struct:
<pre>type RevInfo struct {
	Version string    // version string
	Name    string    // complete ID in underlying repository
	Short   string    // shortened ID, for use in pseudo-version
	Time    time.Time // commit time
}
</pre>


<p>
The <code>vgo</code> <code>list</code> <code>-m</code> <code>-u</code> command shows the commit time of each available update
by using the <code>Time</code> field.

<p>
A general module-hosting server may optionally respond to <i>version</i><code>.info</code> requests for non-semver versions as well.
A <code>vgo</code> command like
<pre>vgo get my/thing/v2@1459def
</pre>


<p>
will fetch <code>1459def.info</code> and then derive a pseudo-version using the <code>Time</code> and <code>Short</code> fields.

<p>
There are two more optional request forms:
<ul>
<li>
<code>GET</code> <i>baseURL</i><code>/</code><i>module</i><code>/@t/</code><i>yyyymmddhhmmss</i> returns the <code>.info</code> JSON for the latest version
at or before the given timestamp.
<li>
<code>GET</code> <i>baseURL</i><code>/</code><i>module</i><code>/@t/</code><i>yyyymmddhhmmss</i><code>/</code><i>branch</i> does the same, but limiting
the search to commits on a given branch.</ul>


<p>
These support the use of untagged commits in <code>vgo</code>.
If <code>vgo</code> is adding a module and finds no tagged commits at all,
it uses the first form to find the latest commit as of now.
It does the same when looking for available updates,
assuming there are still no tagged commits.
The branch-limited form is used for the internal simulation of <i>gopkg.in</i>.
These forms also support the command line syntaxes:
<pre>vgo get my/thing/v2@2018-02-01T15:34:45
vgo get my/thing/v2@2018-02-01T15:34:45@branch
</pre>


<p>
These might be a mistake, but they're in the prototype today, so I'm mentioning them.
<a class=anchor href="#proxy_servers"><h2 id="proxy_servers">Proxy Servers</h2></a>


<p>
Both individuals and companies may prefer to download Go modules from
proxy servers, whether for efficiency, availability, security, license compliance,
or any other reason.
Having a standard Go module format
and a standard download protocol,
as described in the last two sections,
makes it trivial to introduce support for proxies.
If the <code>$GOPROXY</code> environment variable is set,
<code>vgo</code> fetches all modules from the server at the
given base URL,
not from their usual locations.
For easy debugging, <code>$GOPROXY</code> can even be a <code>file:///</code> URL pointing at a local tree.

<p>
We intend to write a basic proxy server that serves from
<code>vgo</code>'s own local cache, downloading new modules as needed.
Sharing such a proxy among a set of computers would help reduce
redundant downloads from the proxy’s users but more importantly
would ensure future availability, even if the original copies disappear.
The proxy will also have an option not to allow downloads of new modules.
In this mode, the proxy would limit the available modules to exactly
those whitelisted by the proxy administrator.
Both proxy modes are frequently requested features in corporate environments.

<p>
Perhaps some day it would make sense to establish a distributed collection
of proxy servers used by default in <code>go</code> <code>get</code>, to ensure module availability
and fast downloads for Go developers worldwide. But not yet.
Today, we are focused on making sure that <code>go</code> <code>get</code> works as well as it
can without assuming any kind of central proxy servers.
<a class=anchor href="#end_of_vendoring"><h2 id="end_of_vendoring">The End of Vendoring</h2></a>


<p>
Vendor directories serve two purposes.
First, they specify by their contents the exact version of the
dependencies to use during <code>go</code> <code>build</code>.
Second, they ensure the availability of those dependencies,
even if the original copies disappear.
On the other hand, vendor directories are also difficult to manage
and bloat the repositories in which they appear.
With the <code>go.mod</code> file specifying the exact version
of dependencies to use during <code>vgo</code> <code>build</code>,
and with proxy servers for ensuring availability,
vendor directories are now almost entirely redundant.
They can, however, serve one final purpose:
to enable a smooth transition to the new versioned world.

<p>
When building a module, <code>vgo</code> (and later <code>go</code>)
will completely ignore vendored dependencies;
those dependencies will also not be included in
the module's zip file.
To make it possible for authors to move to <code>vgo</code> and <code>go.mod</code>
while still supporting users who haven't converted,
the new <code>vgo</code> <code>vendor</code> command populates a module's
vendor directory with the packages users need
to reproduce the <code>vgo</code>-based build.
<a class=anchor href="#whats_next"><h2 id="whats_next">What's Next?</h2></a>


<p>
The details here may be revised, but today's <code>go.mod</code> files
will be understood by any future tooling.
Please start tagging your packages with release tags;
add <code>go.mod</code> files if that makes sense for your project.

<p>
The next post in the series will cover changes to the
<code>go</code> tool command line experience.
      </div>
      
      
      <div id="disqus_thread"></div>
      <script>
      var disqus_config = function () {
          this.page.url = "https://research.swtch.com/vgo-module";  
          this.page.identifier = "blog/vgo-module"; 
      };
      (function() { 
          var d = document, s = d.createElement('script');
          s.src = '//swtch.disqus.com/embed.js';
          s.setAttribute('data-timestamp', +new Date());
          (d.head || d.body).appendChild(s);
      })();
      </script>
      <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
      </div>
      
    </div>

    
<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
var pageTracker = _gat._getTracker("UA-3319603-2");
pageTracker._initData();
pageTracker._trackPageview();
</script>

    
    
  </body>
</html>
















