<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <title>research!rsc: Versioned Go Commands (Go &amp; Versioning, Part 7)</title>
    <link rel="alternate" type="application/atom+xml" title="research!rsc - Atom" href="http://research.swtch.com/feed.atom" />
    
<meta name="viewport" content="width=device-width, initial-scale=1">
<link href='https://fonts.googleapis.com/css?family=Inconsolata:400,700' rel='stylesheet' type='text/css'>
<script type="text/javascript" src="https://use.typekit.com/skm6yij.js"></script>
<script type="text/javascript">try{Typekit.load();}catch(e){}</script>
<style>
  body {
    padding: 0;
    margin: 0;
    font-size: 100%;
    font-family: 'Minion Pro';
  }
  @media print {
    img {page-break-inside: avoid;}
    div.nosplit {page-break-inside: avoid;}
  }
  img.center {
    display: block;
    margin: 0 auto;
  }
  .pad {
    padding-top: 1em;
    padding-bottom: 1em;
  }
  a.anchor, a.back, a.footnote {
    color: black !important;
    text-decoration: none !important;
  }
  a.back {
    font-size: 50%;
  }
  @media print {
    a.back {display: none;}
  }
  .header {
    height: 1.25em;
    background-color: #dff;
    margin: 0;
    padding: 0.1em 0.1em 0.2em;
    border-top: 1px solid black;
    border-bottom: 1px solid #8ff;
  }
  .header h3 {
    margin: 0;
    padding: 0 2em;
    display: inline-block;
    padding-right: 2em;
    font-style: italic;
    font-size: 90%;
  }
  .rss {
    float: right;
    padding-top: 0.2em;
    padding-right: 2em;
    display: none;
  }
  .toc {
    margin-top: 2em;
  }
  .toc-title {
    font-family: "caflisch-script-pro";
    font-size: 300%;
    line-height: 50%;
  }
  .toc-subtitle {
    display: block;
    margin-bottom: 1em;
    font-size: 83%;
  }
  @media only screen and (max-width: 550px) { .toc-subtitle { display: none; } }
  .header h3 a {
    color: black;
  }
  .header h4 {
    margin: 0;
    padding: 0;
    display: inline-block;
    font-weight: normal;
    font-size: 83%;
  }
  @media only screen and (max-width: 550px) { .header h4 { display: none; } }
  .main {
    padding: 0 2em;
  }
  @media only screen and (max-width: 479px) { .article { font-size: 120%; } }
  .article h1 {
    text-align: center;
    font-size: 200%;
  }
  .copyright {
    font-size: 83%;
  }
  .subtitle {
      font-size: 65%;
  }
  .normal {
    font-size: medium;
    font-weight: normal;
  }
  .when {
    text-align: center;
    font-size: 100%;
    margin: 0;
    padding: 0;
  }
  .when p {
    margin: 0;
    padding: 0;
  }
  .article h2 {
    font-size: 125%;
    padding-top: 0.25em;
  }
  .article h3 {
    font-size: 100%;
  }
  pre {
    margin-left: 4em;
    margin-right: 4em;
  }
  pre, code {
    font-family: 'Inconsolata', monospace;
    font-size: 100%;
  }
  .footer {
    margin-top: 10px;
    font-size: 83%;
    font-family: sans-serif;
  }
  .comments {
    margin-top: 2em;
    background-color: #ffe;
    border-top: 1px solid #aa4;
    border-left: 1px solid #aa4;
    border-right: 1px solid #aa4;
  }
  .comments-header {
    padding: 0 5px 0 5px;
  }
  .comments-header p {
    padding: 0;
    margin: 3px 0 0 0;
  }
  .comments-body {
    padding: 5px 5px 5px 5px;
  }
  #plus-comments {
    border-bottom: 1px dotted #ccc;
  }
  .plus-comment {
    width: 100%;
    font-size: 14px;
    border-top: 1px dotted #ccc;
  }
  .me {
    background-color: #eec;
  }
  .plus-comment ul {
    margin: 0;
    padding: 0;
    list-style: none;
    width: 100%;
    display: inline-block;
  }
  .comment-when {
    color:#999;
    width:auto;
    padding:0 5px;
  }
  .old {
    font-size: 83%;
  }
  .plus-comment ul li {
    display: inline-block;
    vertical-align: top;
    margin-top: 5px;
    margin-bottom: 5px;
    padding: 0;
  }
  .plus-icon {
    width: 45px;
  }
  .plus-img {
    float: left;
    margin: 4px 4px 4px 4px;
    width: 32px;
    height: 32px;
  }
  .plus-comment p {
    margin: 0;
    padding: 0;
  }
  .plus-clear {
    clear: left;
  }
  .toc-when {
    font-size: 83%;
    color: #999;
  }
  .toc {
    list-style: none;
  }
  .toc li {
    margin-bottom: 0.5em;
  }
  .toc-head {
    margin-bottom: 1em !important;
    font-size: 117%;
  }
  .toc-summary {
    margin-left: 2em;
  }
  .favorite {
    font-weight: bold;
  }
  .article p, .article ol {
    line-height: 144%;
  }
  sup, sub {
    vertical-align: baseline;
    position: relative;
    font-size: 83%;
  }
  sup {
    bottom: 1ex;
  }
  sub {
    top: 0.8ex;
  }

  .main {
    position: relative;
    margin: 0 auto;
    padding: 0;
    width: 900px;
  }
  @media only screen and (min-width: 768px) and (max-width: 959px) { .main { width: 708px; } }
  @media only screen and (min-width: 640px) and (max-width: 767px) { .main { width: 580px; } }
  @media only screen and (min-width: 480px) and (max-width: 639px) { .main { width: 420px; } }
  @media only screen and (max-width: 479px) { .main { width: 300px; } }

</style>

  </head>
  <body>
    
<div class="header">
  <h3><a href="/">research!rsc</a></h3>
  <h4>Thoughts and links about programming,
    by <a href="https://swtch.com/~rsc/" rel="author">Russ Cox</a> </h4>
  <a class="rss" href="/feed.atom"><img src="/feed-icon-14x14.png" /></a>
</div>

    <div class="main">
      <div class="article">
        <h1>Versioned Go Commands
        
        <div class="subtitle">(<i><a href="vgo">Go &amp; Versioning</a>, Part 7</i>)</div>
        
        <div class="normal">
        <div class="when">
          
            Posted on Friday, February 23, 2018.
            
           <font size="-1"><a href="vgo-cmd.pdf">PDF</a></font>
        </div>
        </div>
        </h1>
        

<p>
What does it mean to add versioning to the <code>go</code> command?
The <a href="vgo-intro">overview post</a> gave a preview,
but the followup posts focused mainly on underlying
details: <a href="vgo-import">the import compatibility rule</a>,
<a href="vgo-mvs">minimal version selection</a>,
and <a href="vgo-module">defining go modules</a>.
With those better understood, this post examines the
details of how versioning affects the <code>go</code> command line
and the reasons for those changes.

<p>
The major changes are:
<ul>
<li>


<p>
All commands (<code>go</code> <code>build</code>, <code>go</code> <code>run</code>, and so on)
will download imported source code automatically,
if the necessary version is not already present
in the download cache on the local system.
<li>


<p>
The <code>go</code> <code>get</code> command will serve mainly to change
which version of a package should be used in future
build commands.
<li>


<p>
The <code>go</code> <code>list</code> command will add access to module
information.
<li>


<p>
A new <code>go</code> <code>release</code> command will automate some of the
work a module author should do when tagging a new release,
such as checking API compatibility.
<li>


<p>
The <code>all</code> pattern is redefined to make sense in the
world of modules.
<li>


<p>
Developers can and will be encouraged to work in
directories outside the GOPATH tree.</ul>


<p>
All these changes are implemented in the <code>vgo</code> prototype.

<p>
Deciding exactly how a build system should work is hard.
The introduction of new build caching in Go 1.10 prompted some
important, difficult decisions about the meaning of <code>go</code> commands,
and the introduction of versioning does too.
Before I explain some of the decisions, I want to start by
explaining a guiding principle that I've found helpful recently,
which I call the isolation rule:<blockquote>

<p>
<i>The result of a build command should depend only on the
source files that are its logical inputs, never on
hidden state left behind by previous build commands.)</i>

<p>
<i>That is, what a command does in isolation—on a
clean system loaded with only the relevant input
source files—is what it should do all the time,
no matter what else has happened on the system recently.</i></blockquote>

<p>
To see the wisdom of this rule, let me retell an old build story
and show how the isolation rule explains what happened.
<a class=anchor href="#old_build_story"><h2 id="old_build_story">An Old Build Story</h2></a>


<p>
Long ago, when compilers and computers were very slow,
developers had scripts to build their whole programs from scratch,
but if they were just modifying one source file,
they might save time by manually recompiling just that file
and then relinking the overall program,
avoiding the cost of recompiling all the source files that
hadn't changed.
These manual incremental builds were fast but error-prone:
if you forgot to recompile a source file that you'd modified,
the link of the final executable would use an out-of-date object file,
the executable would demonstrate buggy behavior,
and you might spend a long time staring at the (correct!) source code
looking for a bug that you'd already fixed.

<p>
<a href="https://www.princeton.edu/~hos/mike/transcripts/feldman.htm">Stu Feldman once explained</a> what it was like in the early 1970s
when he spent a few months working on a few-thousand-line Ratfor program:<blockquote>

<p>
I would go home for dinner at six or so, recompile the whole
world in the background, shut up, and then drive home.
It would take through the drive home and through dinner for
anything to happen.
This is because I kept making the classic error of
debugging a correct program, because you'd forget to
compile the change.</blockquote>

<p>
Transliterated to modern C tools (instead of Ratfor),
Feldman would work on a large program
by first compiling it from scratch:
<pre>$ rm -f *.o &amp;&amp; cc *.c &amp;&amp; ld *.o
</pre>


<p>
This build follows the isolation rule: starting from the same
source files, it produces the same result,
no matter what else has been run in that directory.

<p>
But then Feldman would make changes to specific source files
and recompile only the modified ones, to save time:
<pre>$ cc r2.c r3.c r5.c &amp;&amp; ld *.o
</pre>


<p>
This incremental build does not follow the isolation rule.
The correctness of the command depends on Feldman
remembering which files they modified, and it's easy to
forget one. But it was so much faster, everyone did it anyway,
resorting to routines like Feldman's daily “build during dinner”
to correct any mistakes.

<p>
Feldman continued:<blockquote>

<p>
Then one day, Steve Johnson came storming into my office in his usual way,
saying basically, “Goddamn it, I just spent the whole morning
debugging a correct program, again.
Why doesn't anybody do something like this? ...”</blockquote>

<p>
And that's the story of how Stu Feldman invented <code>make</code>.

<p>
<code>Make</code> was a major advance because it provided
fast, incremental builds that followed the isolation rule.
Isolation is important because it means the build
is properly abstracted: only the source code matters.
As a developer, you can make changes to source code and not even
think about details like stale object files.

<p>
However, the isolation rule is never an absolute.
There is always some area where it applies,
which I call the abstraction zone.
When you step out of the abstraction zone,
you are back to needing to keep state in your head.
For <code>make</code>, the abstraction zone is a single directory.
If you are working on a program made up of libraries
in multiple directories, traditional <code>make</code> is no help.
Most Unix programs in the 1970s fit in a single
directory, so it just wasn't important for <code>make</code>
to provide isolation semantics in multi-directory builds.
<a class=anchor href="#go_builds_and_the_isolation_rule"><h2 id="go_builds_and_the_isolation_rule">Go Builds and the Isolation Rule</h2></a>


<p>
One way to view the history of design bug fixes in the <code>go</code> command
is a sequence of steps extending its abstraction zone
to better match developer expectations.

<p>
One of the advances of the <code>go</code> command
was correct handling of source code spread across multiple
directories, extending the abstraction zone beyond what
<code>make</code> provided.
Go programs are almost always spread across
multiple directories, and when we used <code>make</code> it was
very common to forget to install a package in one directory
before trying to use it in another directory.
We were all too familiar with “the classic error of debugging a correct program.”
But even after fixing that,
there were still many ways to step out of the <code>go</code> command's
abstraction zone, with unfortunate consequences.

<p>
To take one example, if you had multiple directory trees
listed in GOPATH, builds in one tree blindly assumed that
installed packages in the others were up-to-date if present,
but it would rebuild them if missing.
This violation of the isolation rule caused
no end of mysterious problems
for projects using <code>godep</code>, which used a second GOPATH entry
to simulate vendor directories.
We fixed this in Go 1.5.

<p>
As another example, until very recently
command-line flags were not part of the abstraction zone.
If you start with a standard Go 1.9 distribution and run
<pre>$ go build hello.go
$ go install -a -gcflags=-N std
$ go build hello.go
</pre>


<p>
the second <code>go</code> <code>build</code> command produces a different
executable than the first.
The first <code>hello</code> is linked against an optimized build of the Go
and standard library,
while the second <code>hello</code> is linked against an unoptimized standard library.
This violation of the isolation rule led to widespread use
of <code>go</code> <code>build</code> <code>-a</code> (always rebuild everything),
to reestablish isolation semantics.
We fixed this in Go 1.10.

<p>
In both cases, the <code>go</code> command was “working as designed.”
These were the kinds of details that we always kept mental track of
when using other build systems,
so it seemed reasonable to us not to abstract them away.
In fact, when I designed the behavior, I thought it was feature that
<pre>$ go install -a -gcflags=-N std
$ go build hello.go
</pre>


<p>
let you build an optimized <code>hello</code>
against an unoptimized standard library,
and I sometimes took advantage of that.
But, on the whole, Go developers disagreed.
They did not expect to, nor want to, keep mental track of that state.
For me, the isolation rule is useful because it gives a
simple test that helps me
cut through any mental contamination left by years of using
less capable build systems:
every command should have only one meaning, no matter what
other commands have preceded it.

<p>
The isolation rule implies that some commands may need
to be made more complex, so one command can serve where
two commands did before.
For example, if you follow the isolation rule,
how <i>do</i> you build an optimized <code>hello</code>
against an unoptimized standard library?
We answered this in Go 1.10 by extending the <code>-gcflags</code>
argument to start with an optional pattern
that controls which packages the flags affect.
To build an optimized hello against an unoptimized standard library,
<code>go</code> <code>build</code> <code>-gcflags=std=-N</code> <code>hello.go</code>.

<p>
The isolation rule also implies that previously
context-dependent commands need to settle on one
context-independent meaning.
A good general rule seems to be to use the
one meaning that developers are most familiar with.
For example, a different variation of the flag problem
is:
<pre>$ go build -gcflags=-N hello.go
$ rm -rf $GOROOT/pkg
$ go build -gcflags=-N hello.go
</pre>


<p>
In Go 1.9, the first <code>go</code> <code>build</code> command builds an unoptimized hello
against the preinstalled, optimized standard library.
The second <code>go</code> <code>build</code> command finds no preinstalled
standard library, so it rebuilds the standard library,
and the <code>-gcflags</code> applies to all packages built during
the command, so the result is an unoptimized hello
built against an unoptimized standard library.
For Go 1.10, we had to choose which meaning is the one true meaning.

<p>
Our original thought was that in the absence of a restricting pattern
like <code>std=</code>, the <code>-gcflags=-N</code> should apply to all packages
in the build, so that this command would always build
an unoptimized hello against an unoptimized standard library.
But most developers expect this command to apply the <code>-gcflags=-N</code>
only to the argument of <code>go</code> <code>build</code>, namely <code>hello.go</code>,
because that's how it works in the common case,
when you have <i>not</i> just deleted <code>$GOROOT/pkg</code>.
We decided to preserve this expectation, defining that
when no pattern is given, the flags apply only to the
packages or files named on the build comamnd line.
In Go 1.10, building <code>hello.go</code> with <code>-gcflags=-N</code>
always builds an unoptimized hello against an optimized
standard library, even if <code>$GOROOT/pkg</code>
has been deleted and the standard library must be rebuilt
on the spot.
If you do want a completely unoptimized build, that's <code>-gcflags=all=-N</code>.

<p>
The isolation rule is also helpful for thinking through
the design questions that arise in a versioned <code>go</code> command.
Like in the flag decisions, some commands need to be
made more capable.
Others have multiple meanings now and must be
reduced to a single meaning.
<a class=anchor href="#automatic_downloads"><h2 id="automatic_downloads">Automatic Downloads</h2></a>


<p>
The most significant implication of the isolation rule
is that commands like <code>go</code> <code>build</code>, <code>go</code> <code>install</code>,
and <code>go</code> <code>test</code> should download versioned dependencies
as needed (that is, if not already downloaded and cached).

<p>
Suppose I have a brand new Go 1.10 installation
and I write this program to <code>hello.go</code>:
<pre>package main

import (
	"fmt"
	"rsc.io/quote"
)

func main() {
	fmt.Println(quote.Hello())
}
</pre>


<p>
This fails:
<pre>$ go run hello.go
hello.go:5: import "rsc.io/quote": import not found
$ 
</pre>


<p>
But this succeeds:
<pre>$ go get rsc.io/quote
$ go run hello.go
Hello, world.
$ 
</pre>


<p>
I can explain this.
After eight years of conditioning by use of <code>goinstall</code>
and <code>go</code> <code>get</code>, it seemed obvious to me that this behavior
was correct:
<code>go</code> <code>get</code> downloads <code>rsc.io/quote</code> for us and
stashes it away for use by future commands,
so <i>of course</i> that must happen before <code>go</code> <code>run</code>.
But I can explain the behavior of the optimization flag examples
in the previous section too,
and until a few months ago they also seemed obviously correct.
After more thought, I now believe
that any <code>go</code> command should be able to download
versioned dependencies as needed.
I changed my mind for a few reasons.

<p>
The first reason is the isolation rule.
The fact that every other design mistake I've made
in the <code>go</code> command violated the isolation rule
strongly suggests that requiring a prepatory
<code>go</code> <code>get</code> is a mistake too.

<p>
The second reason is that I've found it helpful
to think of the downloaded versioned source code as living
in a local cache that developers shouldn't need to
think about at all. If it's really a cache, cache misses
can't be failures.

<p>
The third reason is the mental bookkeeping required.
Today's <code>go</code> command expects developers
to keep track of which packages are and are not downloaded,
just as earlier <code>go</code> commands expected developers
to keep track of which compiler flags had been
used during the most recent package installs.
As programs grow and as we add more precision about
versioning, the mental burden will grow,
even though the <code>go</code> command is already tracking the same information.
For example, I think this hypothetical session
is a suboptimal developer experience:
<pre>$ git clone https://github.com/rsc/hello
$ cd hello
$ go build
go: rsc.io/sampler(v1.3.1) not installed
$ go get
go: installing rsc.io/sampler(v1.3.1)
$ go build
$ 
</pre>


<p>
If the command knows exactly what it needs, why make
the user do it?

<p>
The fourth reason is that build systems in other languages
already do this.
When you check out a Rust repo and build it,
<code>cargo</code> <code>build</code> automatically fetches the dependencies
as part of the build, no questions asked.

<p>
The fifth reason is that downloading on demand
allows downloading lazily, which in large programs
may mean not downloading many dependencies at all.
For example, the popular logging package
<code>github.com/sirupsen/logrus</code> depends on
<code>golang.org/x/sys</code>, but only when building on Solaris.
The eventual <code>go.mod</code> file in <code>logrus</code> would
list a specific version of <code>x/sys</code> as a dependency.
When <code>vgo</code> sees <code>logrus</code> in a project, it will
consult the <code>go.mod</code> file and determine which
version satisfies an <code>x/sys</code> import.
But all the users not building for Solaris
will never see an <code>x/sys</code> import, so they can avoid
the download of <code>x/sys</code> entirely.
This optimization will become more important
as the dependency graph grows.

<p>
I do expect resistance from developers who aren't yet ready
to think about builds that download code on demand.
We may need to make it possible to disable that with an
environment variable, but downloads should be enabled by default.
<a class=anchor href="#go_get"><h2 id="go_get">Changing Versions (<code>go</code> <code>get</code>)</h2></a>


<p>
Plain <code>go</code> <code>get</code>, without <code>-u</code>, violates the command isolation rule
and must be fixed.
Today:
<ul>
<li>
If GOPATH is empty, <code>go</code> <code>get</code> <code>rsc.io/quote</code> downloads and builds the latest version of <code>rsc.io/quote</code>
and its dependencies (for example, <code>rsc.io/sampler</code>).
<li>
If there is already a <code>rsc.io/quote</code> in GOPATH, from a <code>go</code> <code>get</code> last year, then
the new <code>go</code> <code>get</code> builds the old version.
<li>
If <code>rsc.io/sampler</code> is already in GOPATH but <code>rsc.io/quote</code> is not,
then <code>go</code> <code>get</code> downloads the latest <code>rsc.io/quote</code> and builds it
against the old copy of <code>rsc.io/sampler</code>.</ul>


<p>
Overall, <code>go</code> <code>get</code> depends on the state of GOPATH, which
breaks the command isolation rule.
We need to fix that.
Since <code>go</code> <code>get</code> has at least three meanings today,
we have some latitude in defining new behavior.
Today, <code>vgo</code> <code>get</code> fetches the latest version of the named modules
but then the exact versions of any dependencies requested by those modules,
subject to  <a href="vgo-mvs">minimal version selection</a>.
For example, <code>vgo</code> <code>get</code> <code>rsc.io/quote</code> always fetches the latest version of <code>rsc.io/quote</code>
and then builds it with the exact version of <code>rsc.io/sampler</code> that <code>rsc.io/quote</code> has requested.

<p>
<code>Vgo</code> also allows module versions to be specified on the command line:
<pre>$ vgo get rsc.io/quote@latest  # default
$ vgo get rsc.io/quote@v1.3.0
$ vgo get rsc.io/quote@'&lt;v1.6' # finds v1.5.2
</pre>


<p>
All of these also download (if not already cached)
the specific version of <code>rsc.io/sampler</code> named in <code>rsc.io/quote</code>'s <code>go.mod</code> file.
These commands modify the current module's <code>go.mod</code> file,
and in that sense they do influence the operation of future commands.
But that influence is through an explicit file that users are expected
to know about and edit, not through hidden cache state.
Note that if the version requested on the command line is
earlier than the one already in <code>go.mod</code>, then <code>vgo</code> <code>get</code>
does a downgrade, which will also downgrade other packages
if needed, again following <a href="vgo-mvs">minimal version selection</a>.

<p>
In contrast to plain <code>go</code> <code>get</code>, the <code>go</code> <code>get</code> <code>-u</code> command
behaves the same
no matter what the state of the GOPATH source cache:
it downloads the latest copy of the named packages
and the latest copy of all their dependencies.
Since it follows the command isolation rule,
we should keep the same behavior:
<code>vgo</code> <code>get</code> <code>-u</code> upgrades the named modules to their latest versions
and also upgrades all of their dependencies.

<p>
One idea that has come up in past few days is to introduce
a mode halfway between <code>vgo</code> <code>get</code> (download the exact dependencies
of the thing I asked for) and <code>vgo</code> <code>get</code> <code>-u</code> (download the latest dependencies).
If we believe that authors are conscientious about being very careful
with patch releases and only using them for critical, safe fixes,
then it might make sense to have a <code>vgo</code> <code>get</code> <code>-p</code>
that is like <code>vgo</code> <code>get</code> but then applies only patch-level upgrades.
For example, if <code>rsc.io/quote</code> requires <code>rsc.io/sampler</code> v1.3.0
but v1.3.1 and v1.4.0 are also available,
then <code>vgo</code> <code>get</code> <code>-p</code> <code>rsc.io/quote</code> would upgrade <code>rsc.io/sampler</code>
to v1.3.1, not v1.4.0.
If you think this would be useful, please let us know.

<p>
Of course, all the <code>vgo</code> <code>get</code> variants record the effect of their
additions and upgrades in the <code>go.mod</code> file.
In a sense, we've made these commands follow the isolation rule
by introducing <code>go.mod</code> as an explicit, visible input
replaces a previously implicit, hidden input: the state of the entire GOPATH.
<a class=anchor href="#module_information"><h2 id="module_information">Module Information (<code>go</code> <code>list</code>)</h2></a>


<p>
In addition to changing the versions being used,
we need to provide some way to inspect the current ones.
The <code>go</code> <code>list</code> command is already in charge of reporting
useful information:
<pre>$ go list -f {{.Dir}} rsc.io/quote
/Users/rsc/src/rsc.io/quote
$ go list -f {{context.ReleaseTags}}
[go1.1 go1.2 go1.3 go1.4 go1.5 go1.6 go1.7 go1.8 go1.9 go1.10]
$
</pre>


<p>
It probably makes sense to make module information available to
the format template, and we should also provide shorthands for
common operations like listing all the current module's dependencies.
The <code>vgo</code> prototype already provides correct information for packages
in dependency modules.
For example:
<pre>$ vgo list -f {{.Dir}} rsc.io/quote
/Users/rsc/src/v/rsc.io/quote@v1.5.2
$
</pre>


<p>
It also has a few shorthands. First, <code>vgo</code> <code>list</code> <code>-t</code> lists all available tagged versions of a module:
<pre>$ vgo list -t rsc.io/quote
rsc.io/quote
	v1.0.0
	v1.1.0
	v1.2.0
	v1.2.1
	v1.3.0
	v1.4.0
	v1.5.0
	v1.5.1
	v1.5.2
$ 
</pre>


<p>
Second, <code>vgo</code> <code>list</code> <code>-m</code> lists the current module
followed by its dependencies:
<pre>$ vgo list -m
MODULE                VERSION
github.com/you/hello  -
golang.org/x/text     v0.0.0-20170915032832-14c0d48ead0c
rsc.io/quote          v1.5.2
rsc.io/sampler        v1.3.0
$ 
</pre>


<p>
Finally, <code>vgo</code> <code>list</code> <code>-m</code> <code>-u</code> adds a column showing the latest version of each module:
<pre>$ vgo list -m -u
MODULE                VERSION                             LATEST
github.com/you/hello  -                                   -
golang.org/x/text     v0.0.0-20170915032832-14c0d48ead0c  v0.0.0-20180208041248-4e4a3210bb54
rsc.io/quote          v1.5.2 (2018-02-14 10:44)           -
rsc.io/sampler        v1.3.0 (2018-02-13 14:05)           v1.99.99 (2018-02-13 17:20)
$
</pre>


<p>
In the long term, these should be shorthands for more general support
in the format template, so that other programs can obtain the
information in other forms. Today they are just special cases.
<a class=anchor href="#preparing_new_versions"><h2 id="preparing_new_versions">Preparing New Versions (<code>go</code> <code>release</code>)</h2></a>


<p>
We want to encourage authors to issue tagged releases
of their modules, so we need to make that as easy as possible.
We intend to add a <code>go</code> <code>release</code> command that can take care
of as much of the bookkeeping as needed.
For example, it might:
<ul>
<li>


<p>
Check for backwards-incompatible type changes,
compared to the previous release.
We run a check like this when working on
the Go standard library, and it is very helpful.
<li>


<p>
Suggest whether this release should be a new point release
or a new minor release (because there's new API or
because many lines of code have changed).
Or perhaps always suggest a new minor release
unless the author asks for a point release,
to keep a potential <code>go</code> <code>get</code> <code>-p</code> useful.
<li>


<p>
Scan all source files in the module, even ones that
aren't normally built, to make sure that all imports
can be satisfied by the requirements listed in <code>go.mod</code>.
Referring back to the example in the download section,
this check would make sure that <code>logrus</code>'s
<code>go.mod</code> lists <code>x/sys</code>.</ul>


<p>
As new best practices for releases arise, we can add them to
<code>go</code> <code>release</code> so that authors always only have one step
to check whether their module is ready for a new release.
<a class=anchor href="#pattern_matching"><h2 id="pattern_matching">Pattern matching</h2></a>


<p>
Most <code>go</code> commands take a list of packages as arguments,
and that list can include patterns, like <code>rsc.io/...</code>
(all packages with import paths beginning with <code>rsc.io/</code>),
or <code>./...</code> (all packages in the current directory or
subdirectories), or <code>all</code> (all packages).
We need to check that these make sense in the new world of modules.

<p>
Originally, patterns did not treat vendor directories specially,
so that if <code>github.com/you/hello/vendor/rsc.io/quote</code> existed,
then <code>go</code> <code>test</code> <code>github.com/you/hello/...</code> matched and tested it,
as did <code>go</code> <code>test</code> <code>./...</code> when working in the <code>hello</code> source directory.
The argument in favor of matching vendored code was that
doing so avoided a special case and that it was actually useful
to test your dependencies, as configured in your project,
along with the rest of your project.
The argument against matching vendored code was that
many developers wanted an easy way to test just the
code in their projects, assuming that dependencies
have already been tested separately and are not changing.
In Go 1.9, respecting that argument, we changed the <code>...</code>
pattern not to walk into <code>vendor</code> directories,
so that <code>go</code> <code>test</code> <code>github.com/you/hello/...</code> does not
test vendored dependencies.
This sets up nicely for <code>vgo</code>, which naturally would not
match dependencies either, since they no longer live in
a subdirectory of the main project.
That is, there is no change in the behavior of <code>...</code> patterns
when moving from <code>go</code> to <code>vgo</code>, because that change
happened from Go 1.8 to Go 1.9 instead.

<p>
That leaves the pattern <code>all</code>.
When we first wrote the <code>go</code> command,
before <code>goinstall</code> and <code>go</code> <code>get</code>,
it made sense to talk about building or testing “all packages.”
Today, it makes much less sense:
most developers work in a GOPATH that has a mix of many
different things, including many packages downloaded
and forgotten about.
I expect that almost no one runs commands
like <code>go</code> <code>install</code> <code>all</code> or <code>go</code> <code>test</code> <code>all</code> anymore:
it catches too many things that don't matter.
The real problem is that <code>go</code> <code>test</code> <code>all</code> violates the isolation rule:
its meaning depends on the implicit state of GOPATH
set up by previous commands,
so no one depends on its meaning anymore.
In the <code>vgo</code> prototype, we have redefined <code>all</code>
to have a single, consistent meaning:
all the packages in the current module,
plus all the packages they depend on through one
a sequence of one or more imports.

<p>
The new <code>all</code> is exactly the packages a developer would need
to test in order to sanity check that a particular
combination of dependency versions work together,
but it leaves out nearby packages that don't matter in the current
module.
For example, in the <a href="vgo1">overview post</a>,
our <code>hello</code> module imported <code>rsc.io/quote</code>
but not any other packages,
and in particular not the buggy package <code>rsc.io/quote/buggy</code>.
Running <code>go</code> <code>test</code> <code>all</code> in the <code>hello</code> module
tests all packages in that module and then also
<code>rsc.io/quote</code>.
It omits <code>rsc.io/quote/buggy</code>, because
that one is not needed, even indirectly,
by the <code>hello</code> module, so it's irrelevant to test.
This definition of <code>all</code> restores repeatability,
and combined with Go 1.10's test caching,
it should make <code>go</code> <code>test</code> <code>all</code> more useful than it
ever has been.
<a class=anchor href="#working_outside_gopath"><h2 id="working_outside_gopath">Working outside GOPATH</h2></a>


<p>
If there can be multiple versions of a package
with a given import path, then it no longer makes sense
to require the active development version of that
package to reside in a specific directory.
What if I need to work on bug fixes for both v1.3 and v1.4
at the same time?
Clearly it must be possible to check out modules
in different locations.
In fact, at that point there's no need to work in GOPATH at all.

<p>
GOPATH was doing three things: it defined the
versions of dependencies (now in <code>go.mod</code>),
it held the source code for those dependencies
(now in a separate cache), and it provided a way
to infer the import path for code in a particular
directory (remove the leading <code>$GOPATH/src</code>).
As long as we have some mechanism to decide the import path
for the code in the current directory, we can stop
requiring that developers work in GOPATH.
That mechanism is the <code>go.mod</code> file's <code>module</code> directive.
If I'm a directory named <code>buggy</code> and <code>../go.mod</code> says:
<pre>module "rsc.io/quote"
</pre>


<p>
then my directory's import path must be <code>rsc.io/quote/buggy</code>.

<p>
The <code>vgo</code> prototype enables work outside GOPATH today,
as the examples
in the <a href="vgo-intro">overview post</a> showed.
In fact, when inferring a <code>go.mod</code> from other dependency
information, <code>vgo</code> will look for import comments
in the current directory or subdirectories to try to
get its bearings.
For example, this worked even before Upspin
had introduced a <code>go.mod</code> file:
<pre>$ cd $HOME
$ git clone https://github.com/upspin/upspin
$ cd upspin
$ vgo test -short ./...
</pre>


<p>
The <code>vgo</code> command inferred from import comments that the module
is named <code>upspin.io</code>, and it inferred a list of
dependency version requirements from <code>Gopkg.lock</code>.
<a class=anchor href="#whats_next"><h2 id="whats_next">What's Next?</h2></a>


<p>
This is the last of my initial posts about
the <code>vgo</code> design and prototype.
There is more to work out, but inflicting 67 pages
of posts on everyone seems like enough for one week.

<p>
I had planned to post a FAQ today and submit a Go proposal Monday,
but I will be away next week after Monday.
Rather than disappear for the first four days of official proposal
discussion, I think I will post the proposal when I return.
Please continue to ask questions on the mailing list threads
or on these posts
and to try the <code>vgo</code> prototype.

<p>
Thanks very much for all your interest and feedback so far.
It's very important to me that we all work together
to produce something that works well for Go developers
and that is easy for us all to switch to.

<p>
<b>Update</b>, March 20, 2018: The official Go proposal is at <a href="https://golang.org/issue/24301">https://golang.org/issue/24301</a>,
and the second comment on the issue will be the FAQ.
      </div>
      
      
      <div id="disqus_thread"></div>
      <script>
      var disqus_config = function () {
          this.page.url = "https://research.swtch.com/vgo-cmd";  
          this.page.identifier = "blog/vgo-cmd"; 
      };
      (function() { 
          var d = document, s = d.createElement('script');
          s.src = '//swtch.disqus.com/embed.js';
          s.setAttribute('data-timestamp', +new Date());
          (d.head || d.body).appendChild(s);
      })();
      </script>
      <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
      </div>
      
    </div>

    
<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
var pageTracker = _gat._getTracker("UA-3319603-2");
pageTracker._initData();
pageTracker._trackPageview();
</script>

    
    
  </body>
</html>
















