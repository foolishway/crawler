<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <title>research!rsc: Go&#39;s Package Name Space</title>
    <link rel="alternate" type="application/atom+xml" title="research!rsc - Atom" href="http://research.swtch.com/feed.atom" />
    
<meta name="viewport" content="width=device-width, initial-scale=1">
<link href='https://fonts.googleapis.com/css?family=Inconsolata:400,700' rel='stylesheet' type='text/css'>
<script type="text/javascript" src="https://use.typekit.com/skm6yij.js"></script>
<script type="text/javascript">try{Typekit.load();}catch(e){}</script>
<style>
  body {
    padding: 0;
    margin: 0;
    font-size: 100%;
    font-family: 'Minion Pro';
  }
  @media print {
    img {page-break-inside: avoid;}
    div.nosplit {page-break-inside: avoid;}
  }
  img.center {
    display: block;
    margin: 0 auto;
  }
  .pad {
    padding-top: 1em;
    padding-bottom: 1em;
  }
  a.anchor, a.back, a.footnote {
    color: black !important;
    text-decoration: none !important;
  }
  a.back {
    font-size: 50%;
  }
  @media print {
    a.back {display: none;}
  }
  .header {
    height: 1.25em;
    background-color: #dff;
    margin: 0;
    padding: 0.1em 0.1em 0.2em;
    border-top: 1px solid black;
    border-bottom: 1px solid #8ff;
  }
  .header h3 {
    margin: 0;
    padding: 0 2em;
    display: inline-block;
    padding-right: 2em;
    font-style: italic;
    font-size: 90%;
  }
  .rss {
    float: right;
    padding-top: 0.2em;
    padding-right: 2em;
    display: none;
  }
  .toc {
    margin-top: 2em;
  }
  .toc-title {
    font-family: "caflisch-script-pro";
    font-size: 300%;
    line-height: 50%;
  }
  .toc-subtitle {
    display: block;
    margin-bottom: 1em;
    font-size: 83%;
  }
  @media only screen and (max-width: 550px) { .toc-subtitle { display: none; } }
  .header h3 a {
    color: black;
  }
  .header h4 {
    margin: 0;
    padding: 0;
    display: inline-block;
    font-weight: normal;
    font-size: 83%;
  }
  @media only screen and (max-width: 550px) { .header h4 { display: none; } }
  .main {
    padding: 0 2em;
  }
  @media only screen and (max-width: 479px) { .article { font-size: 120%; } }
  .article h1 {
    text-align: center;
    font-size: 200%;
  }
  .copyright {
    font-size: 83%;
  }
  .subtitle {
      font-size: 65%;
  }
  .normal {
    font-size: medium;
    font-weight: normal;
  }
  .when {
    text-align: center;
    font-size: 100%;
    margin: 0;
    padding: 0;
  }
  .when p {
    margin: 0;
    padding: 0;
  }
  .article h2 {
    font-size: 125%;
    padding-top: 0.25em;
  }
  .article h3 {
    font-size: 100%;
  }
  pre {
    margin-left: 4em;
    margin-right: 4em;
  }
  pre, code {
    font-family: 'Inconsolata', monospace;
    font-size: 100%;
  }
  .footer {
    margin-top: 10px;
    font-size: 83%;
    font-family: sans-serif;
  }
  .comments {
    margin-top: 2em;
    background-color: #ffe;
    border-top: 1px solid #aa4;
    border-left: 1px solid #aa4;
    border-right: 1px solid #aa4;
  }
  .comments-header {
    padding: 0 5px 0 5px;
  }
  .comments-header p {
    padding: 0;
    margin: 3px 0 0 0;
  }
  .comments-body {
    padding: 5px 5px 5px 5px;
  }
  #plus-comments {
    border-bottom: 1px dotted #ccc;
  }
  .plus-comment {
    width: 100%;
    font-size: 14px;
    border-top: 1px dotted #ccc;
  }
  .me {
    background-color: #eec;
  }
  .plus-comment ul {
    margin: 0;
    padding: 0;
    list-style: none;
    width: 100%;
    display: inline-block;
  }
  .comment-when {
    color:#999;
    width:auto;
    padding:0 5px;
  }
  .old {
    font-size: 83%;
  }
  .plus-comment ul li {
    display: inline-block;
    vertical-align: top;
    margin-top: 5px;
    margin-bottom: 5px;
    padding: 0;
  }
  .plus-icon {
    width: 45px;
  }
  .plus-img {
    float: left;
    margin: 4px 4px 4px 4px;
    width: 32px;
    height: 32px;
  }
  .plus-comment p {
    margin: 0;
    padding: 0;
  }
  .plus-clear {
    clear: left;
  }
  .toc-when {
    font-size: 83%;
    color: #999;
  }
  .toc {
    list-style: none;
  }
  .toc li {
    margin-bottom: 0.5em;
  }
  .toc-head {
    margin-bottom: 1em !important;
    font-size: 117%;
  }
  .toc-summary {
    margin-left: 2em;
  }
  .favorite {
    font-weight: bold;
  }
  .article p, .article ol {
    line-height: 144%;
  }
  sup, sub {
    vertical-align: baseline;
    position: relative;
    font-size: 83%;
  }
  sup {
    bottom: 1ex;
  }
  sub {
    top: 0.8ex;
  }

  .main {
    position: relative;
    margin: 0 auto;
    padding: 0;
    width: 900px;
  }
  @media only screen and (min-width: 768px) and (max-width: 959px) { .main { width: 708px; } }
  @media only screen and (min-width: 640px) and (max-width: 767px) { .main { width: 580px; } }
  @media only screen and (min-width: 480px) and (max-width: 639px) { .main { width: 420px; } }
  @media only screen and (max-width: 479px) { .main { width: 300px; } }

</style>

  </head>
  <body>
    
<div class="header">
  <h3><a href="/">research!rsc</a></h3>
  <h4>Thoughts and links about programming,
    by <a href="https://swtch.com/~rsc/" rel="author">Russ Cox</a> </h4>
  <a class="rss" href="/feed.atom"><img src="/feed-icon-14x14.png" /></a>
</div>

    <div class="main">
      <div class="article">
        <h1>Go&#39;s Package Name Space
        
        <div class="normal">
        <div class="when">
          
            Posted on Tuesday, February 2, 2010.
            
          
        </div>
        </div>
        </h1>
        
<p><p class=lp>Go organizes programs into individual pieces called packages.
A package gets to pick a short name for itself, like <code>vector</code>,
even if the <code>import</code> statement must use a longer path like <code>"container/vector"</code>
to name the file where the compiled code is installed.
The early Go compilers used the package name as a unique identifier
during linking, so that <code>vector</code>'s <code>New</code> function
could be distinguished from <code>list</code>'s <code>New</code>.
In the final binary, one was <code>vector.New</code> and the other <code>list.New</code>.
As we started to fill out the standard library, it became clear that we needed
to do something about managing the package name space:
if multiple packages tried to be package <code>vector</code>,
their symbols would collide in the linker.
For a while we considered segmenting the name space,
reserving lower-case names for standard packages
and upper-case names for local packages.
(Since package names and object file names are 
conventionally the same, one reason not to do this
is that it would require a case-sensitive file system.)
</p>

<p class=pp>Other languages simply use longer names.
Both Java and Python tie the name to the directory in which
the package is found, as in <code>com.java.google.WebServer</code>
for the code in <code>com/java/google/WebServer.class</code>.
In practice this leads to unnecessarily long identifiers, something
Go tries to avoid.
It also ties the name to a particular mechanism for finding code: a file system.
One of the reasons that import paths are string constants in Go is
so that it is easy to substitute other notations, like URLs.
</p>

<p class=pp>Last spring, during a long discussion about how to divide up the
package name space,
Robert Griesemer cut the Gordian knot by suggesting that
we allow multiple packages to choose a single name and
fix the tool chain to cope.
The <a href="http://golang.org/doc/go_spec.html#Import_declarations">import statement</a> already allows introducing
a local alias for the package during the import, so there's no
linguistic reason package names have to be unique.
We all agreed that this was the right approach, but we weren't
sure how to implement it.
Other considerations, like the open source release,
took priority during most of 2009, but we recently returned to the problem.
</p>

<p class=pp>Ultimately, the linker needs some unique name for
each symbol in the program; the fundamental problem caused by
deciding that package names won't be unique is to find
another source of uniqueness that fits into the tool chain well.</p>

<p class=pp>The best approach* seems to be to use
the package's import path as the unique identifier,
since it must uniquely identify the package in the
import statement already.
Then <code>container/vector</code>'s <code>New</code> is 
<code>container/vector.New</code>.
But!  When you're compiling a package, 
how does the compiler know what the package's import path will be?
The package statement just says <code>vector</code>, and while
every compilation that imports <code>"container/vector"</code> knows the import path,
the compilation of <code>vector</code> itself does not,
because compilation is handled separately from
installing the binary in its final, importable location.
</p>

<p class=pp>Last week I changed the gc compiler suite to do this. 
My solution to the import path question
was to introduce a special
name syntax that refers to &ldquo;this package's import path.&rdquo;
Because the import paths
are string literals in the Go compiler metadata, I chose the empty string&#8212;<code>""</code>&#8212;as the
self-reference name.
Thus, in the object file for package <code>vector</code>, the local symbol
<code>New</code> is written <code>"".New</code>.
When the linker reads the object file, it knows what
import path it used to find the file.  It substitutes that path
for the <code>""</code>, producing, in this case, the unique name
<code>container/vector.New</code>.</p>

<p class=pp>Not embedding a package's final installed location
in its object file makes the object files easy to move
and duplicate.  For example,
consider this trivial package:</p>

<pre class=indent>
package seq
var n int
func Next() int {
    n++
    return n
}
</pre>

<p class=lp>It's valid for a Go program to import the same path multiple
times using different local names, but all the names end up referring
to the same package:
</p>

<pre class=indent>
package main

import (
    "fmt"
    s "seq" // changed to "seq1" later
    t "seq"
)

func main() {
    fmt.Println(s.Next(), s.Next(), t.Next(), t.Next())
}
</pre>

<p class=lp>prints <code>1 2 3 4</code>, because it all four calls are to the same <code>Next</code> function:</p>

<pre class=indent>
$ 6g seq.go
$ 6g -I. main.go
$ 6l -L. main.6
$ 6.out
1 2 3 4
$ 
</pre>

<p class=lp>But if we change one of the imports to say <code>"seq1"</code>
and then merely copy the <code>"seq"</code> binary to <code>"seq1"</code>,
we've created a distinct package, using lowly <code>cp</code> instead of a compiler:
</p>

<pre class=indent>
$ cp seq.6 seq1.6
$ ed main.go
120
/seq
 s "seq"
s/seq/seq1
 s "seq1"
wq
121
$ 6g -I. main.go
$ 6l -L. main.6
$ 6.out
1 2 1 2
$ 
</pre>

<p class=lp>Now the <code>s.Next</code> calls refer to <code>seq1.6</code>'s <code>Next</code>,
while the <code>t.Next</code> calls refer to <code>seq.6</code>'s <code>Next</code>.
Duplicating the object actually duplicated the code.
This is very different from the behavior of a traditional C compiler and linker.</p>

<p class=pp>A digression: the explicit <code>"".</code> prefix is not strictly necessary.
It would be cleaner
if the linker treated every symbol as needing to be qualified by the
import path, so that all the <code>"".</code> could be dropped.
But occasionally it's important to be able to break the rules,
for example to define a symbol that is logically in one package
be implemented in another.  For example,
the implementation of <a href="http://golang.org/pkg/unsafe/#Reflect"><code>unsafe.Reflect</code></a> is actually
in the binary for <a href="http://golang.org/pkg/runtime/">package <code>runtime</code></a>,
because that's where all the interface manipulation code lives:
</p>

<pre class=indent>
$ 6nm pkg/darwin_amd64/runtime.a|grep Reflect
iface.6: T unsafe.Reflect
$
</pre>

<p class=lp>
Another reason to use an explicit prefix is to admit
names with no prefix at all, as would be generated by legacy C code.
Otherwise, what should C's <code>printf</code> be in?
If the linker enforced a strict boundary between packages,
both of these examples would be impossible.
Most of the time that would be a good thing, but
systems languages do not have the luxury of stopping
at &ldquo;most of the time.&rdquo;
Last October, a few weeks before the public release of Go,
I changed the linker to insert import path qualifiers on all names
during linking, but it was too disruptive a change to commit
before the release.
Last week's implementation, which allows for semipermeable package boundaries,
is a much better fit for Go.
</p>

<p class=pp>This week Ian Lance Taylor is working on eliminating the
global package name space assumption in gccgo.
He'd like to avoid making changes to the linker,
which rules out introducing a &ldquo;this package&rdquo; notation like <code>""</code>.
Gccgo must be able to write objects that know their own import paths,
which means gccgo must know the import path at compile time.
But how?  There will be a new gccgo command line option, and the build system
will simply tell the compiler what the import path is.
</p>

<p class=pp>In retrospect, I wonder if the effort of <code>""</code> in
the gc tool chain was justified compared to adding an option.
The gc implementation is easier to use,
but it's not clear how important that will be.
Time will tell.
</p>

<br>
<p class=lp style="font-size: small;">
* An alternative approach would be to generate a
<a href="http://en.wikipedia.org/wiki/Globally_Unique_Identifier">random identifier</a> each time the compiler
is invoked and to use it for the package compiled by that run.
When other packages import the compiled package, they can
read the identifier and use it to generate references to that
package's symbols.
The most glaring problem with this approach is that
the symbol names you'd see while debugging would
be ugly, like <a href="http://en.wikipedia.org/wiki/Name_mangling">mangled C++ names</a> but worse.
Another problem is that it would break aggressive
incremental compilation: if <code>fmt</code> gets recompiled,
all packages that import it would have to be recompiled to pick
up the new identifier, even if the external interface hadn't changed.
It would be nice to avoid those recompilations, especially in large programs.
</p></p>





<div class="comments">
  <div class="comments-header old">
    <p>(Comments originally posted via Blogger.)</p>
  </div>
  <div class="comments-body">
    <div id="plus-comments">
 <div class="plus-comment"><ul><li class="plus-text">
    <p><a href='http://www.blogger.com/profile/06578159790743176316'>Brian Slesinsky</a> <span class="comment-when">(February 3, 2010 9:04 AM)</span> Thanks for the clear explanation! However, I have to make a few corrections about Java: it isn&#39;t true that Java packages tie a name to &quot;a particular mechanism for finding code: a file system.&quot;<br /><br />Java classes are often loaded from jar files, which in the case of applets are loaded over the network, so there&#39;s no reason why the machine running a JVM need have a traditional filesystem at all. It can cache jars and .class files using any convenient mechanism. In addition, Android and GWT take Java source as input but don&#39;t generate .class files at all.<br /><br />I think this shows the flexibility of the Java naming scheme. Java transparently supports loading code over the network without changing source code (in particular, import statements). It would be a mistake to put network identifiers into import statements because it would require editing source code in order to change where source code or object code are located. Instead, the strategy for finding source code is left to the build system where it can be conveniently overridden using developer-specific flags.<br /><br />Also, while there&#39;s a strong convention for locating Java source files in a particular directory hierarchy, this isn&#39;t strictly necessary. I wrote a Java source code indexer that scans a large directory tree for cross-references in Java source files, and it works find regardless of where the source files are located. Cross-references can be found simply by looking at the contents of Java source files for package names and import statements. This isn&#39;t true in the scheme you describe here, which seems unfortunate.</p>
 </li></ul></div>
    </div>
  </div>
</div>


      </div>
      
      
    </div>

    
<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
var pageTracker = _gat._getTracker("UA-3319603-2");
pageTracker._initData();
pageTracker._trackPageview();
</script>

    
    
  </body>
</html>
















