<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <title>research!rsc: Rotating Hashes</title>
    <link rel="alternate" type="application/atom+xml" title="research!rsc - Atom" href="http://research.swtch.com/feed.atom" />
    
<meta name="viewport" content="width=device-width, initial-scale=1">
<link href='https://fonts.googleapis.com/css?family=Inconsolata:400,700' rel='stylesheet' type='text/css'>
<script type="text/javascript" src="https://use.typekit.com/skm6yij.js"></script>
<script type="text/javascript">try{Typekit.load();}catch(e){}</script>
<style>
  body {
    padding: 0;
    margin: 0;
    font-size: 100%;
    font-family: 'Minion Pro';
  }
  @media print {
    img {page-break-inside: avoid;}
    div.nosplit {page-break-inside: avoid;}
  }
  img.center {
    display: block;
    margin: 0 auto;
  }
  .pad {
    padding-top: 1em;
    padding-bottom: 1em;
  }
  a.anchor, a.back, a.footnote {
    color: black !important;
    text-decoration: none !important;
  }
  a.back {
    font-size: 50%;
  }
  @media print {
    a.back {display: none;}
  }
  .header {
    height: 1.25em;
    background-color: #dff;
    margin: 0;
    padding: 0.1em 0.1em 0.2em;
    border-top: 1px solid black;
    border-bottom: 1px solid #8ff;
  }
  .header h3 {
    margin: 0;
    padding: 0 2em;
    display: inline-block;
    padding-right: 2em;
    font-style: italic;
    font-size: 90%;
  }
  .rss {
    float: right;
    padding-top: 0.2em;
    padding-right: 2em;
    display: none;
  }
  .toc {
    margin-top: 2em;
  }
  .toc-title {
    font-family: "caflisch-script-pro";
    font-size: 300%;
    line-height: 50%;
  }
  .toc-subtitle {
    display: block;
    margin-bottom: 1em;
    font-size: 83%;
  }
  @media only screen and (max-width: 550px) { .toc-subtitle { display: none; } }
  .header h3 a {
    color: black;
  }
  .header h4 {
    margin: 0;
    padding: 0;
    display: inline-block;
    font-weight: normal;
    font-size: 83%;
  }
  @media only screen and (max-width: 550px) { .header h4 { display: none; } }
  .main {
    padding: 0 2em;
  }
  @media only screen and (max-width: 479px) { .article { font-size: 120%; } }
  .article h1 {
    text-align: center;
    font-size: 200%;
  }
  .copyright {
    font-size: 83%;
  }
  .subtitle {
      font-size: 65%;
  }
  .normal {
    font-size: medium;
    font-weight: normal;
  }
  .when {
    text-align: center;
    font-size: 100%;
    margin: 0;
    padding: 0;
  }
  .when p {
    margin: 0;
    padding: 0;
  }
  .article h2 {
    font-size: 125%;
    padding-top: 0.25em;
  }
  .article h3 {
    font-size: 100%;
  }
  pre {
    margin-left: 4em;
    margin-right: 4em;
  }
  pre, code {
    font-family: 'Inconsolata', monospace;
    font-size: 100%;
  }
  .footer {
    margin-top: 10px;
    font-size: 83%;
    font-family: sans-serif;
  }
  .comments {
    margin-top: 2em;
    background-color: #ffe;
    border-top: 1px solid #aa4;
    border-left: 1px solid #aa4;
    border-right: 1px solid #aa4;
  }
  .comments-header {
    padding: 0 5px 0 5px;
  }
  .comments-header p {
    padding: 0;
    margin: 3px 0 0 0;
  }
  .comments-body {
    padding: 5px 5px 5px 5px;
  }
  #plus-comments {
    border-bottom: 1px dotted #ccc;
  }
  .plus-comment {
    width: 100%;
    font-size: 14px;
    border-top: 1px dotted #ccc;
  }
  .me {
    background-color: #eec;
  }
  .plus-comment ul {
    margin: 0;
    padding: 0;
    list-style: none;
    width: 100%;
    display: inline-block;
  }
  .comment-when {
    color:#999;
    width:auto;
    padding:0 5px;
  }
  .old {
    font-size: 83%;
  }
  .plus-comment ul li {
    display: inline-block;
    vertical-align: top;
    margin-top: 5px;
    margin-bottom: 5px;
    padding: 0;
  }
  .plus-icon {
    width: 45px;
  }
  .plus-img {
    float: left;
    margin: 4px 4px 4px 4px;
    width: 32px;
    height: 32px;
  }
  .plus-comment p {
    margin: 0;
    padding: 0;
  }
  .plus-clear {
    clear: left;
  }
  .toc-when {
    font-size: 83%;
    color: #999;
  }
  .toc {
    list-style: none;
  }
  .toc li {
    margin-bottom: 0.5em;
  }
  .toc-head {
    margin-bottom: 1em !important;
    font-size: 117%;
  }
  .toc-summary {
    margin-left: 2em;
  }
  .favorite {
    font-weight: bold;
  }
  .article p, .article ol {
    line-height: 144%;
  }
  sup, sub {
    vertical-align: baseline;
    position: relative;
    font-size: 83%;
  }
  sup {
    bottom: 1ex;
  }
  sub {
    top: 0.8ex;
  }

  .main {
    position: relative;
    margin: 0 auto;
    padding: 0;
    width: 900px;
  }
  @media only screen and (min-width: 768px) and (max-width: 959px) { .main { width: 708px; } }
  @media only screen and (min-width: 640px) and (max-width: 767px) { .main { width: 580px; } }
  @media only screen and (min-width: 480px) and (max-width: 639px) { .main { width: 420px; } }
  @media only screen and (max-width: 479px) { .main { width: 300px; } }

</style>

  </head>
  <body>
    
<div class="header">
  <h3><a href="/">research!rsc</a></h3>
  <h4>Thoughts and links about programming,
    by <a href="https://swtch.com/~rsc/" rel="author">Russ Cox</a> </h4>
  <a class="rss" href="/feed.atom"><img src="/feed-icon-14x14.png" /></a>
</div>

    <div class="main">
      <div class="article">
        <h1>Rotating Hashes
        
        <div class="normal">
        <div class="when">
          
            Posted on Wednesday, March 12, 2008.
            
          
        </div>
        </div>
        </h1>
        
<p><p class=lp>
Long ago, before hash tables (aka scatter storage files) 
were a fundamental data type like <code>int</code>,
programmers had to implement them by hand.  (Nowadays, manually-implemented
hash tables are rarely seen outside of historical reenactments like undergraduate
algorithms classes and C programs.)
Back then, there was fierce debate about how to handle hash collisions. 
</p>

<p class=pp>
One option, called direct chaining, makes each table slot a linked list head,
and then all the entries that hash to that slot are kept in the linked list
pointed to by the slot.  (Bonus points if you reorder the lists using the
<a href="http://www.nist.gov/dads/HTML/movefront.html">move to front heuristic</a>.)
</p>

<p class=pp>
Another option, called linear scanning or open addressing, is to try table entry <i>h</i>, and then if
that is full, try <i>h</i>+1, <i>h</i>+2, and so on until an empty slot is found.
This only works well if the table is sized so that it has some large
fraction (say, 1/4) of unused slots.
</p>

<p class=pp>
Direct chaining and linear scanning are still the most common 
collision resolution methods, but in the 1960s, more were explored.
Still another option is to use non-linear scanning, so that each
data item produces a sequence of hash values <i>h</i><sub>1</sub>, <i>h</i><sub>2</sub>, <i>h</i><sub>3</sub>, and those
table slots are tried in turn.  Two objects with the same <i>h</i><sub>1</sub> won't necessarily 
have the same <i>h</i><sub>2</sub>, unlike in linear scanning.  But hashing is a relatively
slow operation.  Is it worth the time and code to compute all those extra hash
functions?
</p>

<p class=pp>
This sets the stage for Doug McIlroy's 1963 <b><a href="http://doi.acm.org/10.1145/358141.358146">letter to the Communications
of the ACM Pracniques page</a></b>, describing a trick by Vic Vyssotsky:
</p>

<blockquote>
A VARIANT METHOD OF FILE SEARCHING<br><br>

<p class=pp>I would like to publicize a trick due to V. A. Vyssotsky for improving 
the efficiency of scatter storage files.</p>

<p class=pp>
Vyssotsky's idea, used in a remarkably short and elegant code for
the IBM 7090, is to continue random searching after the first probe fails:
</p>

<p class=lp>
 (1) From a data item, compute a pseudo-random address in the file.<br>
 (2) If the item is in this place, or if the place is empty, the job is done.<br>
 (3) If another item is there, probe again with a new address computed by
     another pseudo-random function, until the stock of pseudo-random functions
     has been exhausted.<br>
 (4) As a last resort, when all pseudo-random functions are exhausted, do a 
     linear search of the whole file for the item or a hole, whichever comes first.
</p>

<p class=pp>
In Vyssotsky's program, the later random functions are trivially obtained from
the first one.  He computes an <i>n</i>-bit function of which only the first
<i>m</i> bits are used as an address.  Later, random addresses are obtained by rotating
the same <i>n</i> bits.  After <i>n</i> probes he gives up and resorts to linear search.
</p>

<p class=pp>
More familiar methods of scatter storage employ chaning or linear search for
later probes.  Chaining is the most efficient method in terms of average number
of probes per item but pays a price in storage space for the chaining information.
Linear search is expensive in time.  Table I, comparing average number of probes
per item for these methods, is based on popular uniformity and independence assumptions:
</p>

<center>
TABLE I.  Average Number of Probes per Item
<table cellspacing=5>
<tr>
  <td align=center><i><font size=-1>Load Factor</font></i>
  <td align=center><i><font size=-1>Chaining [1]</font></i>
  <td align=center><i><font size=-1>Linear Search [2]</font></i>
  <td align=center><i><font size=-1>Random Search</font></i>
<tr>
  <td align=center>p
  <td align=center>1 + p/2
  <td align=center>1 + &#189;p/(1-p)
  <td align=center>-p<sup>-1</sup> log(1-p)
<tr>
  <td align=center>.50
  <td align=center>1.25
  <td align=center>1.5
  <td align=center>1.39
<tr>
  <td align=center>.75
  <td align=center>1.38
  <td align=center>2.5
  <td align=center>1.83
<tr>
  <td align=center>.90
  <td align=center>1.45
  <td align=center>5.5
  <td align=center>2.56
</table>
</center>

<p class=pp>
Chaining and random search have a clear edge.  If storage requirements permit, 
chaining is superior.  Vyssotsky's random search pays an attractively low time
penalty to achieve ultimate storage utilization in pressing situations.
</p>

<p class=pp>
A typical 7090 application used a file of two-word items.
Chaining would add an extra word or, with extra coding 
complexity to handle items of nonintegral word length, 
an extra half word per item.  Table II compares lookup times
for various file schemes given a certain amount of storage:
</p>

<center>
TABLE II.  Lookup Times for Various File Schemes
<table cellspacing=5>
<tr>
  <td align=center><i><font size=-1>Load Factor with<br>3-word items</font></i>
  <td align=center><i><font size=-1>Chaining<br>3-word</font></i>
  <td align=center><i><font size=-1>Chaining<br>2&#189;-word</font></i>
  <td align=center><i><font size=-1>Linear<br>2-word</font></i>
  <td align=center><i><font size=-1>Random<br>2-word</font></i>
<tr>
  <td align=center>0.6
  <td align=center>1.3
  <td align=center>1.25
  <td align=center>1.33
  <td align=center>1.30
<tr>
  <td align=center>0.8
  <td align=center>1.4
  <td align=center>1.33
  <td align=center>1.57
  <td align=center>1.49
<tr>
  <td align=center>1.0
  <td align=center>1.5
  <td align=center>1.42
  <td align=center>2.00
  <td align=center>1.65
<tr>
  <td align=center>1.2
  <td align=center>overflow
  <td align=center>1.50
  <td align=center>3.00
  <td align=center>2.01
<tr>
  <td align=center>1.4
  <td align=center>overflow
  <td align=center>overflow
  <td align=center>6.00
  <td align=center>2.90
</table>
</center>

<p class=pp>
References:
</p>

<p class=lp>
1. Johnson, L. R.  Indirect chaining method for addressing on secondary keys.  <i>Comm. ACM 4</i> (1961), 218-223.
</p>

<p class=lp>
2. Schay, G. and Spruth, W. G.  Analysis of a file addressing method.  <i>Comm. ACM 5</i> (1962), 459-462.
</p><br>

<p class=lp>
M. D. McIlroy<br>
<i>Bell Telephone Laboratories, Inc.<br>
Murray Hill, N. J.</i>
</p>
</blockquote>

<p class=lp>(Posting may be intermittent for the rest of March.)</p></p>





<div class="comments">
  <div class="comments-header old">
    <p>(Comments originally posted via Blogger.)</p>
  </div>
  <div class="comments-body">
    <div id="plus-comments">
 <div class="plus-comment"><ul><li class="plus-text">
    <p><a href='http://www.blogger.com/profile/05686871315696257402'>nasorenga</a> <span class="comment-when">(March 12, 2008 11:25 AM)</span> Seems to me that with the simple bit-rotation method, all members of a collision group will have the same sequence of addresses, making it equivalent to linear scanning. So why does it perform better?</p>
 </li></ul></div>
 <div class="plus-comment me"><ul><li class="plus-text">
    <p><a href="http://swtch.com/~rsc/">Russ Cox</a> <span class="comment-when">(March 12, 2008 12:08 PM)</span> @nasorenga: It performs better because you compute more bits than you need for a single hash, but not necessarily as many as you need for n different hashes.  You might compute a 36-bit hash and then use different 16-bit windows as the scanning sequence.</p>
 </li></ul></div>
 <div class="plus-comment"><ul><li class="plus-text">
    <p><a href='http://www.blogger.com/profile/05686871315696257402'>nasorenga</a> <span class="comment-when">(March 12, 2008 12:21 PM)</span> @rsc: I think your point about computing several hashes applies to non-linear scanning, not to linear scanning, which is what the random scanning is being compared to in the article. -- Btw, it occurs to me that an advantage that random does have over linear is that each collision group's scan sequence is unique. With linear scanning, when a clump starts to form, it affects the performance of all nearby collision groups. This may explain the performance improvement gained with random scan.</p>
 </li></ul></div>
 <div class="plus-comment"><ul><li class="plus-text">
    <p><a href='http://www.blogger.com/profile/01123264110675539010'>Michael</a> <span class="comment-when">(March 22, 2008 12:54 AM)</span> Hi Ross,<BR/><BR/>Generating and trying multiple hash values has found a more recent application in Cuckoo hashing, which offers worst-case O(1) lookup. And it works very well -- I've used an implementation in production that keeps over 2 million elements with a 0.99 load factor. See http://www.it-c.dk/people/pagh/papers/cuckoo-undergrad.pdf, but to achieve these high load factors, you have to generalize the number of hash functions partitions to 5 or so.</p>
 </li></ul></div>
 <div class="plus-comment"><ul><li class="plus-text">
    <p><a href='http://www.blogger.com/profile/01123264110675539010'>Michael</a> <span class="comment-when">(March 22, 2008 1:01 AM)</span> Err, I meant Russ. How embarrassing, sorry! :)</p>
 </li></ul></div>
    </div>
  </div>
</div>


      </div>
      
      
    </div>

    
<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
var pageTracker = _gat._getTracker("UA-3319603-2");
pageTracker._initData();
pageTracker._trackPageview();
</script>

    
    
  </body>
</html>
















