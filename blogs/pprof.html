<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <title>research!rsc: How To Build a User-Level CPU Profiler</title>
    <link rel="alternate" type="application/atom+xml" title="research!rsc - Atom" href="http://research.swtch.com/feed.atom" />
    
<meta name="viewport" content="width=device-width, initial-scale=1">
<link href='https://fonts.googleapis.com/css?family=Inconsolata:400,700' rel='stylesheet' type='text/css'>
<script type="text/javascript" src="https://use.typekit.com/skm6yij.js"></script>
<script type="text/javascript">try{Typekit.load();}catch(e){}</script>
<style>
  body {
    padding: 0;
    margin: 0;
    font-size: 100%;
    font-family: 'Minion Pro';
  }
  @media print {
    img {page-break-inside: avoid;}
    div.nosplit {page-break-inside: avoid;}
  }
  img.center {
    display: block;
    margin: 0 auto;
  }
  .pad {
    padding-top: 1em;
    padding-bottom: 1em;
  }
  a.anchor, a.back, a.footnote {
    color: black !important;
    text-decoration: none !important;
  }
  a.back {
    font-size: 50%;
  }
  @media print {
    a.back {display: none;}
  }
  .header {
    height: 1.25em;
    background-color: #dff;
    margin: 0;
    padding: 0.1em 0.1em 0.2em;
    border-top: 1px solid black;
    border-bottom: 1px solid #8ff;
  }
  .header h3 {
    margin: 0;
    padding: 0 2em;
    display: inline-block;
    padding-right: 2em;
    font-style: italic;
    font-size: 90%;
  }
  .rss {
    float: right;
    padding-top: 0.2em;
    padding-right: 2em;
    display: none;
  }
  .toc {
    margin-top: 2em;
  }
  .toc-title {
    font-family: "caflisch-script-pro";
    font-size: 300%;
    line-height: 50%;
  }
  .toc-subtitle {
    display: block;
    margin-bottom: 1em;
    font-size: 83%;
  }
  @media only screen and (max-width: 550px) { .toc-subtitle { display: none; } }
  .header h3 a {
    color: black;
  }
  .header h4 {
    margin: 0;
    padding: 0;
    display: inline-block;
    font-weight: normal;
    font-size: 83%;
  }
  @media only screen and (max-width: 550px) { .header h4 { display: none; } }
  .main {
    padding: 0 2em;
  }
  @media only screen and (max-width: 479px) { .article { font-size: 120%; } }
  .article h1 {
    text-align: center;
    font-size: 200%;
  }
  .copyright {
    font-size: 83%;
  }
  .subtitle {
      font-size: 65%;
  }
  .normal {
    font-size: medium;
    font-weight: normal;
  }
  .when {
    text-align: center;
    font-size: 100%;
    margin: 0;
    padding: 0;
  }
  .when p {
    margin: 0;
    padding: 0;
  }
  .article h2 {
    font-size: 125%;
    padding-top: 0.25em;
  }
  .article h3 {
    font-size: 100%;
  }
  pre {
    margin-left: 4em;
    margin-right: 4em;
  }
  pre, code {
    font-family: 'Inconsolata', monospace;
    font-size: 100%;
  }
  .footer {
    margin-top: 10px;
    font-size: 83%;
    font-family: sans-serif;
  }
  .comments {
    margin-top: 2em;
    background-color: #ffe;
    border-top: 1px solid #aa4;
    border-left: 1px solid #aa4;
    border-right: 1px solid #aa4;
  }
  .comments-header {
    padding: 0 5px 0 5px;
  }
  .comments-header p {
    padding: 0;
    margin: 3px 0 0 0;
  }
  .comments-body {
    padding: 5px 5px 5px 5px;
  }
  #plus-comments {
    border-bottom: 1px dotted #ccc;
  }
  .plus-comment {
    width: 100%;
    font-size: 14px;
    border-top: 1px dotted #ccc;
  }
  .me {
    background-color: #eec;
  }
  .plus-comment ul {
    margin: 0;
    padding: 0;
    list-style: none;
    width: 100%;
    display: inline-block;
  }
  .comment-when {
    color:#999;
    width:auto;
    padding:0 5px;
  }
  .old {
    font-size: 83%;
  }
  .plus-comment ul li {
    display: inline-block;
    vertical-align: top;
    margin-top: 5px;
    margin-bottom: 5px;
    padding: 0;
  }
  .plus-icon {
    width: 45px;
  }
  .plus-img {
    float: left;
    margin: 4px 4px 4px 4px;
    width: 32px;
    height: 32px;
  }
  .plus-comment p {
    margin: 0;
    padding: 0;
  }
  .plus-clear {
    clear: left;
  }
  .toc-when {
    font-size: 83%;
    color: #999;
  }
  .toc {
    list-style: none;
  }
  .toc li {
    margin-bottom: 0.5em;
  }
  .toc-head {
    margin-bottom: 1em !important;
    font-size: 117%;
  }
  .toc-summary {
    margin-left: 2em;
  }
  .favorite {
    font-weight: bold;
  }
  .article p, .article ol {
    line-height: 144%;
  }
  sup, sub {
    vertical-align: baseline;
    position: relative;
    font-size: 83%;
  }
  sup {
    bottom: 1ex;
  }
  sub {
    top: 0.8ex;
  }

  .main {
    position: relative;
    margin: 0 auto;
    padding: 0;
    width: 900px;
  }
  @media only screen and (min-width: 768px) and (max-width: 959px) { .main { width: 708px; } }
  @media only screen and (min-width: 640px) and (max-width: 767px) { .main { width: 580px; } }
  @media only screen and (min-width: 480px) and (max-width: 639px) { .main { width: 420px; } }
  @media only screen and (max-width: 479px) { .main { width: 300px; } }

</style>

  </head>
  <body>
    
<div class="header">
  <h3><a href="/">research!rsc</a></h3>
  <h4>Thoughts and links about programming,
    by <a href="https://swtch.com/~rsc/" rel="author">Russ Cox</a> </h4>
  <a class="rss" href="/feed.atom"><img src="/feed-icon-14x14.png" /></a>
</div>

    <div class="main">
      <div class="article">
        <h1>How To Build a User-Level CPU Profiler
        
        <div class="normal">
        <div class="when">
          
            Posted on Thursday, August 8, 2013.
            
          
        </div>
        </div>
        </h1>
        
<p class="lp">
When I spent a summer as a Google intern in 2006,
one of the many pleasant surprises was Google&rsquo;s pprof tool,
which makes profiling a C++ program&rsquo;s CPU and memory usage incredibly easy.
It had already been open sourced, and when I returned to grad school,
I incorporated pprof into my standard development toolbox when
writing C programs.
Later, when I was back at Google working on Go, implementing
support for pprof was a must.
Now it&rsquo;s part of the standard development toolbox for any Go programmer.
</p>

<p class="pp">
I&rsquo;ve written on the Go blog about
<a href="http://blog.golang.org/profiling-go-programs">what it&rsquo;s like to use pprof
to profile Go programs</a>.
This post is about how pprof gathers the CPU profile,
with the help of hardware timers and the operating system.
</p>

<h3>Hardware Timers</h3>

<p class="pp">
One of the key jobs of an operating system is to allow multiple programs to run
on a computer at the same time, each under the illusion that they have continuous
access to one or more CPUs, even though in practice each CPU can only be
running one program at a time.
On most systems, what happens is that the operating system asks the computer&rsquo;s timer chip
to interrupt normal execution every so often (every 10 milliseconds is common)
and run a small piece of the operating system called, appropriately enough,
the timer interrupt handler.
The timer interrupt handler checks to see if other programs are waiting to run.
If so, and if the current program has used up its turn on the CPU, the handler
saves the CPU registers of the current program and loads the CPU registers for
another program that has been waiting.
Shuffling the programs on and off the CPUs is called multitasking, and doing it
based on hardware interrupts like this is called preemptive multitasking: one 
running program is preempted to make room for another.
</p>

<p class="pp">
Not all operating systems provide preemptive multitasking.
Some, like MS-DOS or iOS 3, have no multitasking, so only one program can run at a time.
Others, like Windows 3.1 and Mac OS 9, use cooperative multitasking,
in which programs voluntarily relinquish the CPU at certain points.
Cooperative multitasking avoids the complexity of using the timer,
but it means that one badly written program
can hang a machine.
</p>

<p class="pp">
Another useful thing you can do with a hardware interrupt is gather a profile
of a running program.
Every time the hardware interrupt happens, the operating system can record
what the program was doing. A collection of these samples makes up a 
(hopefully representative) profile of where the program spends its time.
</p>

<h3>A Simple Profiler</h3>

<p class="pp">
Since the operating system moderates access to the hardware, it must be
involved to use the hardware timer to implement a profiler.
The simplest approach is for the operating system to collect the profile.
To illustrate this approach, I&rsquo;ll describe what the Plan 9 kernel does
for user-level profiling.
This is little changed from the original Unix <i>profil</i>(2) scheme.
</p>

<p class="pp">
When a program is running, writing to a control file in the /proc
file system enables profiling.
At that point, the operating system allocates an array of counts
with one count for every 8-byte section of the program code,
and attaches it to the program.
Then, each time a timer interrupt happens, the handler 
uses the program counter—the address of the instruction in the
code that the program is currently executing—divided by 8 as
an index into that array and increments that entry.
Later, another program (on Plan 9, called <i>tprof</i>) can be run to
read the profile from the kernel and determine the function
and specific line in the original source code corresponding to
each counter and summarize the results.
</p>

<p class="pp">
This design keeps the kernel very simple: the timer handler only
adds an increment instruction. However, it is also inflexible: that&rsquo;s
all the kernel will do for a program.
And there are potential improvements that could be made with
more flexibility. For example, in programs that use libraries, the
profiles may not have enough context to be useful.
If you find your program is spending 30% of its time in <code>memset</code>
but you don&rsquo;t know what is calling <code>memset</code>, you can&rsquo;t fix the problem.
</p>

<p class="pp">
The next step forward is to move profiling logic out of the kernel,
so that it is easier to customize.
</p>

<h3>User-Level Timers</h3>

<p class="pp">
Modern Unix systems move profiling logic out of the kernel by providing
a timer abstraction to user programs. The programs can then
build whatever they want, including profiling.
(Another use might be to build preemptive scheduling in a user-level
lightweight thread scheduler.)
</p>

<p class="pp">
On these systems, <i>setitimer</i>(2) provides three timers, for &ldquo;real time,&rsquo;&rsquo; &ldquo;virtual time,&rsquo;&rsquo;
and &ldquo;profiling time.&rsquo;&rsquo;
The &ldquo;real time&rsquo;&rsquo; timer counts down in real (wall clock) time. If it is set for 5 seconds,
it fires 5 seconds from now.
The &ldquo;virtual time&rsquo;&rsquo; timer counts down in program execution time. If it is set for 5 seconds,
it fires after the program has executed for 5 seconds.
The &ldquo;profiling time&rsquo;&rsquo; timer is similar except that it also counts down when
the kernel is executing a system call on behalf of the program.
When any of these timers fires, the kernel stops what the program is doing
and invokes a special routine in the program called a signal handler.
The signal handler in a program is analogous to the timer interrupt handler
in the kernel.
The signal being delivered depends on the kind of timer: <code>SIGALRM</code>, <code>SIGVTALRM</code>, or <code>SIGPROF</code> for the three kinds.
</p>

<p class="pp">
A program that wants to profile its own execution can set a profiling timer
and then arrange to record a profiling sample in its signal handler.
Because the profiling is being done by the program, not by the kernel,
it can be replaced without kernel changes and reboots,
by changing the program and recompiling.
This allows experimentation and in turn the construction of richer
profiles. In particular, it allows gathering more information in each
profiling sample.
</p>

<h3>Profiling with pprof</h3>

<p class="pp">
In pprof, each profiling sample records not just the current program counter
but also the program counter for each frame in the current call stack.
</p>

<p class="pp">
Obtaining the current call stack is not always trivial: typically it requires
arranging for the code being executed to maintain a certain form
(for example, to use a frame pointer in all functions) or arranging for
additional metadata to be available during the trace.
But modern computers are incredibly fast: even walking the call stack
using metadata lookups can be done in well under 100 microseconds,
which would correspond to only a 1% slowdown for a 10 millisecond profiling
period.
</p>

<p class="pp">
Recording a sampled stack is a little tricky. The signal handler, because it
interrupts normal program execution, is limited in what it can do.
In particular, the signal handler cannot even allocate memory or
acquire locks, so the stored profile cannot grow dynamically.
</p>

<p class="pp">
In pprof, the profile is maintained in a hash table in which each entry
records a distinct stack. Specifically, in the Go pprof,
each stack hashes to a specific hash value
denoting one of 1024 buckets in a hash table, and in that bucket are four entries for stacks with
that hash. If the stack being recorded is already present, the existing
entry&rsquo;s count is simply incremented. Otherwise, the stack must replace
one of the four entries. If one or more is unused, the decision is easy.
If all four entries are in use, pprof evicts the entry with the smallest
count. The evicted entry is appended to a fixed-size log with space for
2<sup>1</sup><sup>8</sup> entries, and then its space is reused for the stack we want to record.
A background goroutine, not running as a signal handler,
copies entries out of the log and into the saved profile data.
If the goroutine cannot keep up with the rate at which the log is filling,
the counts for the entries that are lost are assigned to a special
&ldquo;lost profile&rsquo;&rsquo; function. In practice, most programs spend their time
doing the same thing over and over again, so the active work of the
program fits in the hash table, the log grows slowly, and the log
draining goroutine has no problem keeping up.
In C++ pprof, there is no log-draining goroutine. Instead, the signal
handler writes the log to an already open file when it fills.
</p>

<h3>Interpreting the data</h3>

<p class="pp">
A pprof profile, then, is a set of stack traces with each mapped
to the count of the number of times that trace was seen.
The usual way this profile is presented is to create a graph
in which each function is a node and an edge between nodes denotes a call.
Each function node has two counts: first the sum of the counts of all the profiles
in which it was the final entry and second the sum of the counts of all the profiles
in which it appeared.
These correspond to time executing that function and cumulative time
executing that function and the things it called.
The edges are given counts corresponding to the number of samples
in which that call was observed somewhere on the stack.
Sizing the nodes and edges based on their counts makes the expensive parts
of the program stand out.
<a href="http://benchgraffiti.googlecode.com/hg/havlak/havlak1.svg">This example</a> should view nicely in most web browsers;
use the scroll wheel to zoom and click and drag to pan.
In that profile, it is apparent that <code>hash_lookup</code> called from <code>mapaccess1</code>
is taking the most time, and we can use the call context to see that
about 40% of the calls are from code in <code>main.FindLoops</code> while 60% of
the calls are from code in <code>main.DFS</code>.
</p>

<center>
<a href="http://benchgraffiti.googlecode.com/hg/havlak/havlak1.svg"><img src="pprof.png" style="border: 1px solid black;"></a>
</center>

<p class="lp">
Of course, there is also a command-line interface, tabular results, and annotated source code.
See the <a href="http://blog.golang.org/profiling-go-programs">Profiling Go Programs</a> post.

<h3>Further Reading</h3>

<p class="pp">
Timer-based profiling is very old. On Unix, the heritage dates back at least 
to the Seventh Edition.
The <a href="http://plan9.bell-labs.com/7thEdMan/v7vol1.pdf">Seventh Edition Unix manual</a> contains documentation
for <i>prof</i>(1), <i>profil</i>(2), and <i>monitor</i>(3), and you can even read the source for
<a href="http://www.tuhs.org/Archive/PDP-11/Trees/V7/usr/src/libc/gen/mon.c">monitor</a>.
However, pprof is the first profiler I&rsquo;ve seen that records and presents stack traces well.
If you&rsquo;d like to read more about pprof,
it is part of the C++ <a href="https://code.google.com/p/gperftools/">gperftools</a> open source project and has
good documentation.
The Go implementation of the CPU profile collection
is in <a href="http://golang.org/src/pkg/runtime/cpuprof.c">runtime/cpuprof.c</a>.
</p>

<p class="pp">
It is of course also possible to collect profiles without timers, such as by rewriting the program code.
In general the overhead of these tends to be larger than timer-based sampling,
and it can skew the results so that what looks expensive with profiling enabled
is not expensive normally.
</p>

<p class="pp">
Modern CPUs have introduced all kinds of other profiling timers, based on instructions executed,
cache misses, and so on. These are very powerful, but so far the interfaces to them are
operating system-specific.
One nice thing about pprof is that, because it&rsquo;s using an old, widely supported Unix feature,
it&rsquo;s fairly portable. I can use a single tool on FreeBSD, Linux, and OS X.
</p>

<p class="pp">
<i>Setitimer</i>(2) was introduced by 4.2BSD; that indirection makes excellent tools like pprof possible.
Of course, it has to work correctly.
In my next post I&rsquo;ll look at one system where it doesn&rsquo;t.
</p>

      </div>
      
      <div class="comments">
        <div class="comments-header">
          <p>Comments?  Please join the <a href="https://plus.google.com/116810148281701144465/posts/Foipz56nQ2M">Google+ discussion</a>.</p>
        </div>
        <div class="comments-body">
          <div id="plus-comments">
          </div>
        </div>
      </div>
      
      
    </div>

    
<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
var pageTracker = _gat._getTracker("UA-3319603-2");
pageTracker._initData();
pageTracker._trackPageview();
</script>

    
    
    
<script src="//ajax.googleapis.com/ajax/libs/jquery/1/jquery.min.js"></script>
<script>



function plusComments(me, postid, key) {
$.ajax({
type: 'GET',
url: 'https://www.googleapis.com/plus/v1/activities/'+postid+'/comments?alt=json&maxResults=100&pp=1&key='+key,
dataType: 'jsonp',
success: function(z, textStatus)
{

var items = z.items;
var countitems = 0;
for(Object in items) countitems++;
for (var i = 0; i < countitems; i++) {

var nam = z.items[i].actor.displayName;                    
var pid = z.items[i].actor.url;                           
var img = z.items[i].actor.image.url;           
var text = z.items[i].object.content;                   


(function(d){d.timeago=function(g){if(g instanceof Date){return a(g)}else{if(typeof g==="string"){return a(d.timeago.parse(g))}else{return a(d.timeago.datetime(g))}}};var f=d.timeago;d.extend(d.timeago,{settings:{refreshMillis:60000,allowFuture:false,strings:{prefixAgo:null,prefixFromNow:null,suffixAgo:"ago",suffixFromNow:"from now",seconds:"less than a minute",minute:"about a minute",minutes:"%d minutes",hour:"about an hour",hours:"about %d hours",day:"a day",days:"%d days",month:"about a month",months:"%d months",year:"about a year",years:"%d years",numbers:[]}},inWords:function(l){var m=this.settings.strings;var i=m.prefixAgo;var q=m.suffixAgo;if(this.settings.allowFuture){if(l<0){i=m.prefixFromNow;q=m.suffixFromNow}l=Math.abs(l)}var o=l/1000;var g=o/60;var n=g/60;var p=n/24;var j=p/365;function h(r,t){var s=d.isFunction(r)?r(t,l):r;var u=(m.numbers&&m.numbers[t])||t;return s.replace(/%d/i,u)}var k=o<45&&h(m.seconds,Math.round(o))||o<90&&h(m.minute,1)||g<45&&h(m.minutes,Math.round(g))||g<90&&h(m.hour,1)||n<24&&h(m.hours,Math.round(n))||n<48&&h(m.day,1)||p<30&&h(m.days,Math.floor(p))||p<60&&h(m.month,1)||p<365&&h(m.months,Math.floor(p/30))||j<2&&h(m.year,1)||h(m.years,Math.floor(j));return d.trim([i,k,q].join(" "))},parse:function(h){var g=d.trim(h);g=g.replace(/\.\d\d\d+/,"");g=g.replace(/-/,"/").replace(/-/,"/");g=g.replace(/T/," ").replace(/Z/," UTC");g=g.replace(/([\+\-]\d\d)\:?(\d\d)/," $1$2");return new Date(g)},datetime:function(h){var i=d(h).get(0).tagName.toLowerCase()==="time";var g=i?d(h).attr("datetime"):d(h).attr("title");return f.parse(g)}});d.fn.timeago=function(){var h=this;h.each(c);var g=f.settings;if(g.refreshMillis>0){setInterval(function(){h.each(c)},g.refreshMillis)}return h};function c(){var g=b(this);if(!isNaN(g.datetime)){d(this).text(a(g.datetime))}return this}function b(g){g=d(g);if(!g.data("timeago")){g.data("timeago",{datetime:f.datetime(g)});var h=d.trim(g.text());if(h.length>0){g.attr("title",h)}}return g.data("timeago")}function a(g){return f.inWords(e(g))}function e(g){return(new Date().getTime()-g.getTime())}document.createElement("abbr");document.createElement("time")}(jQuery));

var publi = ($.timeago($.trim(z.items[i].published))); 




var meclass = "";
if (pid === 'https://plus.google.com/'+me){
  meclass = " me";
}

var comment = '<div class="plus-comment'+meclass+'"><img class="plus-img" src="'+img+'" /><p><a href="'+pid+'" target="blank" title="'+nam+'\'s Google+ profile">'+nam+'</a> <span class="comment-when">('+publi+')</span> '+text+'</p><div class="plus-clear"></div></div>';

$('#plus-comments').append(comment);

}

}});
}
</script>

    <script>plusComments("116810148281701144465", "z12lftlznwjicxkms22ld1jolnn5cjx2m", "AIzaSyB_JO6hyAJAL659z0Dmu0RUVVvTx02ZPMM")</script>
    
  </body>
</html>
















