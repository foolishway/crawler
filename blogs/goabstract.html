<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <title>research!rsc: Broken abstractions in Go</title>
    <link rel="alternate" type="application/atom+xml" title="research!rsc - Atom" href="http://research.swtch.com/feed.atom" />
    
<meta name="viewport" content="width=device-width, initial-scale=1">
<link href='https://fonts.googleapis.com/css?family=Inconsolata:400,700' rel='stylesheet' type='text/css'>
<script type="text/javascript" src="https://use.typekit.com/skm6yij.js"></script>
<script type="text/javascript">try{Typekit.load();}catch(e){}</script>
<style>
  body {
    padding: 0;
    margin: 0;
    font-size: 100%;
    font-family: 'Minion Pro';
  }
  @media print {
    img {page-break-inside: avoid;}
    div.nosplit {page-break-inside: avoid;}
  }
  img.center {
    display: block;
    margin: 0 auto;
  }
  .pad {
    padding-top: 1em;
    padding-bottom: 1em;
  }
  a.anchor, a.back, a.footnote {
    color: black !important;
    text-decoration: none !important;
  }
  a.back {
    font-size: 50%;
  }
  @media print {
    a.back {display: none;}
  }
  .header {
    height: 1.25em;
    background-color: #dff;
    margin: 0;
    padding: 0.1em 0.1em 0.2em;
    border-top: 1px solid black;
    border-bottom: 1px solid #8ff;
  }
  .header h3 {
    margin: 0;
    padding: 0 2em;
    display: inline-block;
    padding-right: 2em;
    font-style: italic;
    font-size: 90%;
  }
  .rss {
    float: right;
    padding-top: 0.2em;
    padding-right: 2em;
    display: none;
  }
  .toc {
    margin-top: 2em;
  }
  .toc-title {
    font-family: "caflisch-script-pro";
    font-size: 300%;
    line-height: 50%;
  }
  .toc-subtitle {
    display: block;
    margin-bottom: 1em;
    font-size: 83%;
  }
  @media only screen and (max-width: 550px) { .toc-subtitle { display: none; } }
  .header h3 a {
    color: black;
  }
  .header h4 {
    margin: 0;
    padding: 0;
    display: inline-block;
    font-weight: normal;
    font-size: 83%;
  }
  @media only screen and (max-width: 550px) { .header h4 { display: none; } }
  .main {
    padding: 0 2em;
  }
  @media only screen and (max-width: 479px) { .article { font-size: 120%; } }
  .article h1 {
    text-align: center;
    font-size: 200%;
  }
  .copyright {
    font-size: 83%;
  }
  .subtitle {
      font-size: 65%;
  }
  .normal {
    font-size: medium;
    font-weight: normal;
  }
  .when {
    text-align: center;
    font-size: 100%;
    margin: 0;
    padding: 0;
  }
  .when p {
    margin: 0;
    padding: 0;
  }
  .article h2 {
    font-size: 125%;
    padding-top: 0.25em;
  }
  .article h3 {
    font-size: 100%;
  }
  pre {
    margin-left: 4em;
    margin-right: 4em;
  }
  pre, code {
    font-family: 'Inconsolata', monospace;
    font-size: 100%;
  }
  .footer {
    margin-top: 10px;
    font-size: 83%;
    font-family: sans-serif;
  }
  .comments {
    margin-top: 2em;
    background-color: #ffe;
    border-top: 1px solid #aa4;
    border-left: 1px solid #aa4;
    border-right: 1px solid #aa4;
  }
  .comments-header {
    padding: 0 5px 0 5px;
  }
  .comments-header p {
    padding: 0;
    margin: 3px 0 0 0;
  }
  .comments-body {
    padding: 5px 5px 5px 5px;
  }
  #plus-comments {
    border-bottom: 1px dotted #ccc;
  }
  .plus-comment {
    width: 100%;
    font-size: 14px;
    border-top: 1px dotted #ccc;
  }
  .me {
    background-color: #eec;
  }
  .plus-comment ul {
    margin: 0;
    padding: 0;
    list-style: none;
    width: 100%;
    display: inline-block;
  }
  .comment-when {
    color:#999;
    width:auto;
    padding:0 5px;
  }
  .old {
    font-size: 83%;
  }
  .plus-comment ul li {
    display: inline-block;
    vertical-align: top;
    margin-top: 5px;
    margin-bottom: 5px;
    padding: 0;
  }
  .plus-icon {
    width: 45px;
  }
  .plus-img {
    float: left;
    margin: 4px 4px 4px 4px;
    width: 32px;
    height: 32px;
  }
  .plus-comment p {
    margin: 0;
    padding: 0;
  }
  .plus-clear {
    clear: left;
  }
  .toc-when {
    font-size: 83%;
    color: #999;
  }
  .toc {
    list-style: none;
  }
  .toc li {
    margin-bottom: 0.5em;
  }
  .toc-head {
    margin-bottom: 1em !important;
    font-size: 117%;
  }
  .toc-summary {
    margin-left: 2em;
  }
  .favorite {
    font-weight: bold;
  }
  .article p, .article ol {
    line-height: 144%;
  }
  sup, sub {
    vertical-align: baseline;
    position: relative;
    font-size: 83%;
  }
  sup {
    bottom: 1ex;
  }
  sub {
    top: 0.8ex;
  }

  .main {
    position: relative;
    margin: 0 auto;
    padding: 0;
    width: 900px;
  }
  @media only screen and (min-width: 768px) and (max-width: 959px) { .main { width: 708px; } }
  @media only screen and (min-width: 640px) and (max-width: 767px) { .main { width: 580px; } }
  @media only screen and (min-width: 480px) and (max-width: 639px) { .main { width: 420px; } }
  @media only screen and (max-width: 479px) { .main { width: 300px; } }

</style>

  </head>
  <body>
    
<div class="header">
  <h3><a href="/">research!rsc</a></h3>
  <h4>Thoughts and links about programming,
    by <a href="https://swtch.com/~rsc/" rel="author">Russ Cox</a> </h4>
  <a class="rss" href="/feed.atom"><img src="/feed-icon-14x14.png" /></a>
</div>

    <div class="main">
      <div class="article">
        <h1>Broken abstractions in Go
        
        <div class="normal">
        <div class="when">
          
            Posted on Monday, March 29, 2010.
            
          
        </div>
        </div>
        </h1>
        
<p><p class=lp>
One of my favorite pieces of Go is the implementation of 
the <code>go</code> and <code>defer</code>
statements, because it seems to cheat.
It reuses the function call code in such a way that
adding <code>go</code> is just a couple lines in the
compiler back end, far shorter than it would have been
if implemented from scratch.
But reusing the function call code requires breaking
an abstraction layer in a somewhat non-obvious way.
<code>Defer</code> cheats in a few more interesting ways
too.
(I'm not claiming responsibility for any of this clever code.
I believe it's all due to Ken Thompson.)
</p>

<h3>Go</h3>

<p class=lp>
In Go, the statement <code>go f(x,y,z)</code> starts a new
goroutine running the function call <code>f(x,y,z)</code>.
The values of <code>f</code>, <code>x</code>, <code>y</code>,
and <code>z</code> are all computed in the original goroutine:
it is only the execution of <code>f</code> that happens in 
the new goroutine.
</p>

<p class=pp>
Before we go on, stop for a minute and think about how you'd
implement this if you were generating C code.
I would probably create a struct with fields for <code>f</code>,
<code>x</code>, <code>y</code>, and <code>z</code>,
and then I'd write a function that took a pointer to that struct
as input and called <code>f(x,y,z)</code>, and then I'd 
compile the <code>go</code> statement by generating
code to allocate and fill in the struct and then call a function
<code>go(helper, structptr)</code> where <code>helper</code>
is the other function that does the call.
It's a fair amount of work, and it would have to happen for
each call.
The Go implementation of <code>go</code> avoids all of that.
</p>

<p class=pp>
Let's defer <code>go</code> for a minute and look at a normal
function call.  Here's the assembly for calling <code>f(1, 2, 3)</code>:
</p>

<pre class=indent>
 MOVL    $1, 0(SP)
 MOVL    $2, 4(SP)
 MOVL    $3, 8(SP)
 CALL    f(SB)
</pre>

<p class=lp>It stores <code>1</code>, <code>2</code>, and
<code>3</code> on the stack in the places where <code>f</code>
expects them, and then it executes a <code>CALL</code> instruction.
Simple enough.
</p>

<p class=pp>
Here's the code for <code>go f(1, 2, 3)</code>:
</p>

<pre class=indent>
 MOVL    $1, 0(SP)
 MOVL    $2, 4(SP)
 MOVL    $3, 8(SP)
 PUSHQ   $f(SB)
 PUSHQ   $12
 CALL    runtime.newproc(SB)
 POPQ    AX
 POPQ    AX
</pre>

<p class=lp>This is not something you could have written in C.
It starts out by setting up for an ordinary function call,
storing the arguments in the usual places.
But then at the last minute it swerves: instead of calling
<code>f</code> directly, it pushes two more
arguments onto the stack: <code>f</code> and the number <code>12</code>,
and then it calls a different function
<code>runtime.newproc</code>.
</p>

<p class=pp>
<code>Newproc</code> expects its arguments to be
a byte count <i>n</i>, the function to call, and then <i>n</i>
bytes of parameters to the function, already laid out
exactly how the function needs to receive them.
It copies those <i>n</i> bytes to a new stack and
starts <code>f</code> running with its stack pointer
pointing at those arguments.
<code>Newproc</code> is essentially the helper,
but there's just one instance of it.
</p>

<p class=pp>
In the gc compilers (6g, etc), the implementation of
<code>go</code> calls the same code generator as
for an ordinary function call, but it ends with that
5-instruction sequence instead of a simple <code>CALL</code> instruction.
</p>

<p class=pp>
This trick eliminates
all the special code that I would have generated,
requiring only a handful of lines in the runtime and
only a handful of lines in the compiler.
</p>

<h3>Defer</h3>

<p class=lp>
The statement <code>defer f(x,y,z)</code> is like <code>go f(x,y,z)</code>,
but instead of running the call in a new goroutine, it saves
the call for later, running it when the current function eventually returns.
The implementation of the statement itself is almost
identical to the implementation for <code>go</code>,
except that the generated code calls
<code>deferproc</code> instead of <code>newproc</code>.
</p>

<p class=pp>
The interesting new broken abstractions for <code>defer</code>
are in how the deferred functions get called.
If a function contains a defer statement, instead of ending with
the usual epilogue
</p>

<pre class=indent>
 ADDL $48, SP // or whatever the frame size is
 RET
</pre>

<p class=lp>the function ends with
</p>

<pre class=indent>
 CALL runtime.deferreturn(SB)
 ADDL $48, SP
 RET
</pre>

<p class=lp>The runtime function <code>deferreturn</code>
arranges for the deferred calls, if any, to run.
How?  Each goroutine has associated with it a linked
list of deferred calls, <code>Defer</code> structures:
</p>

<pre class=indent>
struct Defer
{
 int32 siz;
 byte* sp;
 byte* fn;
 Defer* link;
 byte args[8]; // padded to actual size
};
</pre>

<p class=lp>
The struct represents a deferred call to <code>fn</code> with the <code>siz</code> bytes of arguments stored in <code>args</code>.
(The struct is allocated with enough space on the end
even if <code>siz &gt; 8</code>.)
The <code>link</code> field is for the linked list.
What about <code>sp</code>?
That's how <code>calldefer</code> knows whether it's time
to run a particular call.
The <code>sp</code> field records the address of the first
argument (after <code>fn</code>) in the call to <code>deferproc</code>.
If the first argument to <code>calldefer</code> is at the 
same address, then the <code>Defer</code> is for this 
call frame.
If not, it is for a different call frame,
and since defers run when a function exits,
it must be for a frame higher up the stack:
</p>

<pre class=indent>
void
deferreturn(uintptr arg0)
{
 byte *sp, *fn;
 Defer *d;

 sp = (byte*)&amp;arg0;
 d = g-&gt;defer;
 if(d == nil || <b><i>d-&gt;sp != sp</i></b>)
  return;
 mcpy(d-&gt;sp, d-&gt;args, d-&gt;siz);
 g-&gt;defer = d-&gt;link;
 fn = d-&gt;fn;
 free(d);
 jmpdefer(fn, sp);
}
</pre>

<p class=lp>
If you were writing this in pure C, you'd probably have
a separate stack for each call frame, or maybe on entry
to a function with a <code>defer</code> statement you'd
push a special marker onto the defer stack and 
then, at the end, run deferred calls until you found the marker.
But if you work at the lower-level world of machine instructions,
the stack pointer is a perfectly good unique identifier
of a particular call frame; using it avoids any
work on the way into the function.
</p>

<p class=pp>
If there is a deferred call to run, then <code>deferreturn</code>
copies the arguments to the stack&#8212;there's definitely room,
because that's the same address <code>deferproc</code>
copied them from&#8212;frees the defer stub, and then calls
the assembly function <code>jmpdefer</code> to transfer
control to <code>fn</code> as though the original function
had called <code>fn</code> directly instead of <code>deferreturn</code>.

<p class=pp>
But wait!  That only takes care of a single deferred call,
yet a function can defer many calls during the course
of its execution.  How can that work?
</p>

<p class=pp>
Well, the assembly trampoline <code>jmpdefer</code>
has one more abstraction breaker up its sleeve.
It subtracts five&#8212;the size of <code>CALL</code> 
instruction that invoked <code>deferreturn</code>&#8212;from
the return address on the stack
before jumping to <code>fn</code>,
so the deferred function returns not to the instruction
<i>after</i> the <code>CALL</code>, as it normally would,
but back to the <code>CALL</code> itself.
That is, subtracting five turns the <code>CALL</code> instruction
into a loop.  The only way out of the loop is for
<code>deferreturn</code> to find no work left
for this call frame and return normally,
without calling <code>jmpdefer</code>.
This subterfuge avoids the need to write a loop
at the end of every function with a defer statement.
</p>

<h3>On abstraction</h3>

<p class=lp>
In today's programming world, there seems to be a lot
of emphasis on the power of abstraction.
I think there's not enough emphasis on the power of
breaking abstractions.
All three of these places where the Go
implementation breaks the abstraction are
more efficient than if it had colored within the
abstraction boundaries.
</p>

<p class=pp>
All three are also the kinds of tricks that were
commonplace in the early days of Unix,
since it had been written in assembly.
For example, the original
<code>fork</code> system call handler distinguished
parent from child by changing the return address
just as <code>jmpdefer</code> does.
In modern Unix, the <code>fork</code> system call
returns the new process id in the parent but returns zero
in the child.  In the early versions, including Sixth Edition,
<code>fork</code> returns the new process id in both,
but the child returned normally
while the parent returned to one instruction
past the usual return address.
Thus the instruction after invoking the fork system call
needed to be an unconditional jump to the child-specific code.
</p>

<p class=pp>
There are other, more fundamental abstractions broken in Go.
The implementation of segmented stacks in Go
breaks the simple abstraction of a stack that 
most C compilers assume (more on that in another post).
The idea that an object can implement an interface without
explicitly declaring that fact is foreign to Java:
it is impossible to compile Go to standard Java byte codes,
because Go's interfaces break the JVM's abstraction.
</p>

<p class=pp>
Ultimately, I think the reason I like all these broken
abstractions is that they help you get to a
better understanding of the system as a whole.
Where before you only saw two different layers,
you now begin to see how the layers are related
and how they can interact.
And every broken abstraction is a chance to
see or create a new concept that may not have even
been expressible before.
</p></p>





<div class="comments">
  <div class="comments-header old">
    <p>(Comments originally posted via Blogger.)</p>
  </div>
  <div class="comments-body">
    <div id="plus-comments">
 <div class="plus-comment"><ul><li class="plus-text">
    <p><a href='http://www.blogger.com/profile/10559947643606684495'>Barry Kelly</a> <span class="comment-when">(March 29, 2010 9:49 AM)</span> It&#39;s expressly the job of a compiler to remove abstractions from code. Ultimately it needs to remove all abstractions, until the remaining bitstream is able to signal the hardware to generate the desired effects in the physical world.<br /><br />So yes, when you&#39;re implementing a compiler, you need to be aware of the fact that it&#39;s your job to destroy abstraction, to map it into appropriate layers with as much efficiency as correctness will allow. But that&#39;s not the same thing as saying that breaking abstractions is a good thing.</p>
 </li></ul></div>
 <div class="plus-comment"><ul><li class="plus-text">
    <p><a href='http://www.blogger.com/profile/09787472194187459747'>Autodidactic Asphyxiation</a> <span class="comment-when">(March 29, 2010 9:57 AM)</span> Are parameters passed on the stack in 64-bit, as well?<br /><br />How does the call/ret-5 subterfuge effect the call/ret prediction on modern processors?</p>
 </li></ul></div>
 <div class="plus-comment me"><ul><li class="plus-text">
    <p><a href="http://swtch.com/~rsc/">Russ Cox</a> <span class="comment-when">(March 29, 2010 10:21 AM)</span> @barry: Not a good thing if done all the time, but certainly a good thing once in a while.<br /><br />@aa: The fact that f called deferreturn, which called jmpdefer, which is returning straight to f, already broke the RET prediction.  Rewinding the CALL instruction doesn&#39;t make it any worse.  ;-)</p>
 </li></ul></div>
 <div class="plus-comment"><ul><li class="plus-text">
    <p><a href='http://www.blogger.com/profile/03688076015831464616'>Peter</a> <span class="comment-when">(May 19, 2010 9:21 PM)</span> I am pretty sure you can compile Go to JVM by messing around with Java interfaces sufficiently. It wouldn&#39;t be pretty, that&#39;s for sure. :-D</p>
 </li></ul></div>
 <div class="plus-comment"><ul><li class="plus-text">
    <p><a href='http://www.blogger.com/profile/02275315449689041289'>IDisposable</a> <span class="comment-when">(January 4, 2011 5:30 PM)</span> Why doesn&#39;t the go helper runtime.newproc pop the known-to-be function address and arglist byte-size automatically instead of relying on the call-site to pop them? That would turn this:<br /><br /> MOVL    $1, 0(SP)<br /> MOVL    $2, 4(SP)<br /> MOVL    $3, 8(SP)<br /> PUSHQ   $f(SB)<br /> PUSHQ   $12<br /> CALL    runtime.newproc(SB)<br /> POPQ    AX<br /> POPQ    AX<br /><br />into<br /><br /> MOVL    $1, 0(SP)<br /> MOVL    $2, 4(SP)<br /> MOVL    $3, 8(SP)<br /> PUSHQ   $f(SB)<br /> PUSHQ   $12<br /> CALL    runtime.newproc(SB)<br /><br />which would be much better on pipeline sizes?</p>
 </li></ul></div>
 <div class="plus-comment"><ul><li class="plus-text">
    <p><a href='http://www.blogger.com/profile/10773876428711731299'>Carsten Milkau</a> <span class="comment-when">(May 27, 2011 5:08 AM)</span> I wonder why<br /><br />defer &lt;FunctionBody&gt;<br />go    &lt;FunctionBody&gt;<br /><br />haven&#39;t been turned into (lexical) synonyms for<br /><br />defer func() &lt;FunctionBody&gt; ()<br />go    func() &lt;FunctionBody&gt; ()<br /><br />following the general design pattern of go to avoid boilerplate. <br /><br />IMHO this is fairly straightforward and unambiguous, in mind that anonymous functions are closures. The defer and go keywords are prominent enough to remind this is an anonymous function call and not an ordinary block. Still, in many cases that difference doesn&#39;t matter, and in those cases the resemblance is even a plus.</p>
 </li></ul></div>
    </div>
  </div>
</div>


      </div>
      
      
    </div>

    
<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
var pageTracker = _gat._getTracker("UA-3319603-2");
pageTracker._initData();
pageTracker._trackPageview();
</script>

    
    
  </body>
</html>
















