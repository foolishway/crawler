<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <title>research!rsc: Lessons from the Debian/OpenSSL Fiasco</title>
    <link rel="alternate" type="application/atom+xml" title="research!rsc - Atom" href="http://research.swtch.com/feed.atom" />
    
<meta name="viewport" content="width=device-width, initial-scale=1">
<link href='https://fonts.googleapis.com/css?family=Inconsolata:400,700' rel='stylesheet' type='text/css'>
<script type="text/javascript" src="https://use.typekit.com/skm6yij.js"></script>
<script type="text/javascript">try{Typekit.load();}catch(e){}</script>
<style>
  body {
    padding: 0;
    margin: 0;
    font-size: 100%;
    font-family: 'Minion Pro';
  }
  @media print {
    img {page-break-inside: avoid;}
    div.nosplit {page-break-inside: avoid;}
  }
  img.center {
    display: block;
    margin: 0 auto;
  }
  .pad {
    padding-top: 1em;
    padding-bottom: 1em;
  }
  a.anchor, a.back, a.footnote {
    color: black !important;
    text-decoration: none !important;
  }
  a.back {
    font-size: 50%;
  }
  @media print {
    a.back {display: none;}
  }
  .header {
    height: 1.25em;
    background-color: #dff;
    margin: 0;
    padding: 0.1em 0.1em 0.2em;
    border-top: 1px solid black;
    border-bottom: 1px solid #8ff;
  }
  .header h3 {
    margin: 0;
    padding: 0 2em;
    display: inline-block;
    padding-right: 2em;
    font-style: italic;
    font-size: 90%;
  }
  .rss {
    float: right;
    padding-top: 0.2em;
    padding-right: 2em;
    display: none;
  }
  .toc {
    margin-top: 2em;
  }
  .toc-title {
    font-family: "caflisch-script-pro";
    font-size: 300%;
    line-height: 50%;
  }
  .toc-subtitle {
    display: block;
    margin-bottom: 1em;
    font-size: 83%;
  }
  @media only screen and (max-width: 550px) { .toc-subtitle { display: none; } }
  .header h3 a {
    color: black;
  }
  .header h4 {
    margin: 0;
    padding: 0;
    display: inline-block;
    font-weight: normal;
    font-size: 83%;
  }
  @media only screen and (max-width: 550px) { .header h4 { display: none; } }
  .main {
    padding: 0 2em;
  }
  @media only screen and (max-width: 479px) { .article { font-size: 120%; } }
  .article h1 {
    text-align: center;
    font-size: 200%;
  }
  .copyright {
    font-size: 83%;
  }
  .subtitle {
      font-size: 65%;
  }
  .normal {
    font-size: medium;
    font-weight: normal;
  }
  .when {
    text-align: center;
    font-size: 100%;
    margin: 0;
    padding: 0;
  }
  .when p {
    margin: 0;
    padding: 0;
  }
  .article h2 {
    font-size: 125%;
    padding-top: 0.25em;
  }
  .article h3 {
    font-size: 100%;
  }
  pre {
    margin-left: 4em;
    margin-right: 4em;
  }
  pre, code {
    font-family: 'Inconsolata', monospace;
    font-size: 100%;
  }
  .footer {
    margin-top: 10px;
    font-size: 83%;
    font-family: sans-serif;
  }
  .comments {
    margin-top: 2em;
    background-color: #ffe;
    border-top: 1px solid #aa4;
    border-left: 1px solid #aa4;
    border-right: 1px solid #aa4;
  }
  .comments-header {
    padding: 0 5px 0 5px;
  }
  .comments-header p {
    padding: 0;
    margin: 3px 0 0 0;
  }
  .comments-body {
    padding: 5px 5px 5px 5px;
  }
  #plus-comments {
    border-bottom: 1px dotted #ccc;
  }
  .plus-comment {
    width: 100%;
    font-size: 14px;
    border-top: 1px dotted #ccc;
  }
  .me {
    background-color: #eec;
  }
  .plus-comment ul {
    margin: 0;
    padding: 0;
    list-style: none;
    width: 100%;
    display: inline-block;
  }
  .comment-when {
    color:#999;
    width:auto;
    padding:0 5px;
  }
  .old {
    font-size: 83%;
  }
  .plus-comment ul li {
    display: inline-block;
    vertical-align: top;
    margin-top: 5px;
    margin-bottom: 5px;
    padding: 0;
  }
  .plus-icon {
    width: 45px;
  }
  .plus-img {
    float: left;
    margin: 4px 4px 4px 4px;
    width: 32px;
    height: 32px;
  }
  .plus-comment p {
    margin: 0;
    padding: 0;
  }
  .plus-clear {
    clear: left;
  }
  .toc-when {
    font-size: 83%;
    color: #999;
  }
  .toc {
    list-style: none;
  }
  .toc li {
    margin-bottom: 0.5em;
  }
  .toc-head {
    margin-bottom: 1em !important;
    font-size: 117%;
  }
  .toc-summary {
    margin-left: 2em;
  }
  .favorite {
    font-weight: bold;
  }
  .article p, .article ol {
    line-height: 144%;
  }
  sup, sub {
    vertical-align: baseline;
    position: relative;
    font-size: 83%;
  }
  sup {
    bottom: 1ex;
  }
  sub {
    top: 0.8ex;
  }

  .main {
    position: relative;
    margin: 0 auto;
    padding: 0;
    width: 900px;
  }
  @media only screen and (min-width: 768px) and (max-width: 959px) { .main { width: 708px; } }
  @media only screen and (min-width: 640px) and (max-width: 767px) { .main { width: 580px; } }
  @media only screen and (min-width: 480px) and (max-width: 639px) { .main { width: 420px; } }
  @media only screen and (max-width: 479px) { .main { width: 300px; } }

</style>

  </head>
  <body>
    
<div class="header">
  <h3><a href="/">research!rsc</a></h3>
  <h4>Thoughts and links about programming,
    by <a href="https://swtch.com/~rsc/" rel="author">Russ Cox</a> </h4>
  <a class="rss" href="/feed.atom"><img src="/feed-icon-14x14.png" /></a>
</div>

    <div class="main">
      <div class="article">
        <h1>Lessons from the Debian/OpenSSL Fiasco
        
        <div class="normal">
        <div class="when">
          
            Posted on Wednesday, May 21, 2008.
            
          
        </div>
        </div>
        </h1>
        
<p><p class=pp>
Last week, Debian announced that in September 2006
they accidentally broke the OpenSSL pseudo-random number generator
while trying to silence a Valgrind warning.
One effect this had is that the <code>ssh-keygen</code> program
installed on recent Debian systems (and Debian-derived systems like Ubuntu)
could only generate 32,767 different possible SSH keys of a given type and size,
so there are a lot of people walking around with <a href="http://github.com/blog/63-ssh-keys-generated-on-debian-ubuntu-compromised">the same keys</a>.
</p>

<p class=pp>
Many people have had fingers pointed at them, but
it is not really interesting who made the mistake: everyone 
makes mistakes.  What's interesting is the situation that
encouraged making the mistake and that made it possible
not to notice it for almost two years.
</p>

<p class=pp>
To do that, you have to understand the code involved and the
details of the bug; those require understanding a little bit
about entropy and random number generators.
</p>
<br>
<p class=lp><b>
Entropy
</b></p>

<p class=pp>
Entropy is a measure of how surprising a piece of data is.
Jon Lester didn't pitch in last night's Red Sox game, but
that's not surprising--he only pitches in every fifth game, so most
nights he doesn't pitch.
On Monday night, though, he did pitch and (surprise!) threw a no-hitter.
No one expected that before the game: it was a high-entropy event.
</p>

<p class=pp>
Entropy can be measured in bits: a perfect coin flip produces 1 bit of entropy.
A biased coin produces less: flipping a coin that comes up heads only 25% of the
time produces only about 0.4 bits for tails and 2 bits for heads,
or 0.8 bits of entropy on average.
The exact details aren't too important.  What is important is that
entropy is a quantitative measure of the amount of
unpredictability in a piece of data.  
</p>

<p class=pp>
An ideal random byte sequence
has entropy equal to its length, but most of the time we have to
make do with lower-entropy sequences.  For example, 
the dates of Major League no-hitters this year would be a
very unpredictable sequence, but also a very short one.
On the other hand, collecting the dates that Lester pitches for 
the Red Sox this year is fairly predictable&mdash;it's 
basically every fifth day&mdash;but there are still unexpected events
like injuries and rain-outs that make it not completely predictable.
The no-hitter sequence is very unpredictable but is very short.
The Lester starts sequence is only a little unpredictable but so much
longer that it likely has more total entropy.
</p>

<p class=pp>
Computers are faced with the same problem: they have access
to long low-entropy (mostly predictable) sources, like the interarrival times between
device interrupts or static sampled from a sound or video card,
but they need high-entropy (completely unpredictable) byte sequences where every bit
is completely unpredictable.
To convert the former into the latter, a secure pseudo-random
number generator uses a
deterministic function that acts as an &ldquo;entropy juicer.&rdquo;
It takes
a large amount of low-entropy data, called the entropy pool,
and then squeezes it to produce
a smaller amount of high-entropy random byte sequences.
Deterministic programs can't create entropy, so the
amount of entropy coming out can't be greater than
the amount of entropy going in.  The 
generator has just condensed the entropy pool into a 
more concentrated form.
Cryptographic hash functions like MD5 and SHA1
turn out to be good entropy juicers.
They let every input bit have some effect on each
output bit, so that no matter which input bits were
the unpredictable ones, the output has a uniformly high entropy.
(In fact this is the very essence of a hash function,
which is why cryptographers just say
hash function instead of made-up terms like entropy juicer.)
</p>

<p class=pp>
The bad part about entropy is that you can't actually
measure it except in context: if you read a 32-bit number
from <code>/dev/random</code>, as I just did, 
you're likely to be happy with 4016139919,
but if you read ten more, you won't be happy if you
keep getting 4016139919.
(That last sentence is, technically, completely flawed, but you get the point.
See also <a href="http://xkcd.com/221/">this comic</a> and <a href="http://web.archive.org/web/20011027002011/http://dilbert.com/comics/dilbert/archive/images/dilbert2001182781025.gif">this comic</a>.)
The nice thing about entropy juicers is that as long as there's
some entropy somewhere in the pool, they'll extract it.
It never hurts to add some more data to the pool: either
it will add to the collective entropy, or it will have no effect.
</p>

<br>
<p class=lp><b>
OpenSSL</b>
</p>

<p class=pp>
OpenSSL implements such a hash-based entropy juicer.
It provides a function
<code>RAND_add(buf, n, e)</code> that adds a 
buffer of length <code>n</code> and entropy <code>e</code>
to the entropy pool.
Internally, the entry pool is just an MD5 or SHA1 hash state:
<code>RAND_add</code> calls <code>MD_update</code> to add the bytes
to a running hash computation.
The parameter <code>e</code> is an assertion made by the
caller about the entropy contained in <code>buf</code>.
OpenSSL uses it to keep a running estimate of the total amount
of entropy in the buffer. 
OpenSSL also provides a <code>RAND_bytes(buf, n)</code> that 
returns a high-entropy random byte sequence.
If the running estimate indicates that there isn't enough
entropy in the pool, <code>RAND_bytes</code> returns an error.
This is entirely reasonable.
</p>

<p class=pp>
The Unix-specific code in OpenSSL seeds the entropy juicer
with some dodgy code.  The essence of <code>RAND_poll</code>
in <code>rand_unix.c</code> is (my words):
</p>

<pre>
    char buf[100];
    fd = open("/dev/random", O_RDONLY);
    n = read(fd, buf, sizeof buf);
    close(fd);
    RAND_add(buf, sizeof buf, n);
</pre>

<p class=pp>
Notice that the parameters to <code>RAND_add</code> say to
use the entire buffer but only expect <code>n</code> bytes
of entropy.  <code>RAND_load_file</code> does a similar
thing when reading from a file, and there the uninitialized
reference is explicitly marked as intentional (actual code):
</p>

<pre>
    i=fread(buf,1,n,in);
    if (i &lt;= 0) break;
    /* even if n != i, use the full array */
    RAND_add(buf,n,i);
</pre>

<p class=pp>
The rationale here is that including the uninitialized fragment
at the end of the buffer might actually increase the actual amount of
entropy, and in any event being honest about the
amount of entropy being claimed won't break the
entropy pool estimates.
</p>

<p class=pp>
Similarly, the function <code>RAND_bytes(buf, n)</code>,
whose main purpose is to fetch <code>n</code> high-entropy
bytes from the juicer, adds the contents of <code>buf</code>
to the entropy pool (it behaves like <code>RAND_add(buf, n, 0)</code>)
before it fills in <code>buf</code>.
</p>

<p class=pp>
In at least three different places, then, the OpenSSL developers
explicitly chose to use uninitialized buffers as possible entropy sources.
While this is theoretically defensible (it can't hurt),
it's mostly a combination of voodoo and wishful thinking,
and it makes the code difficult to understand and analyze.
</p>

<p class=pp>
In particular, the <code>RAND_bytes</code> convention causes
problems at every call site that looks like:
</p>

<p class=pp>
<pre>
    char buf[100];
    n = RAND_bytes(buf, sizeof buf);
</pre>
</p>

<p class=pp>
This idiom causes so many warnings with Valgrind (and its commercial cousin, Purify)
that there is an <code>#ifdef</code> to turn the behavior off:
</p>

<p class=pp>
<pre>
    #ifndef PURIFY
                MD_Update(&m,buf,j); /* purify complains */
    #endif
 </pre>
</p>

<p class=pp>
The other two cases occur much more rarely:
in <code>RAND_poll</code>, one would have to be
reading from <code>/dev/random</code> when
the kernel had very little randomness to spare,
or calling <code>RAND_load_file</code> on a file
that reported one size in <code>stat</code> but
returned fewer bytes in <code>read</code>.
When they do occur, a different instance of <code>MD_update</code>,
the one in <code>RAND_add</code>, is on the stack trace
reported by Valgrind.
</p>

<br>
<p class=lp><b>
Debian
</b></p>

<p class=pp>
A Debian maintainer was faced with Valgrind reports of uses
of uninitialized data at a call to <code>MD_update</code>,
which is used to mix a buffer into the entropy pool inside
both <code>RAND_add</code> and <code>RAND_bytes</code>.
Normally you might look farther up the call stack, but 
there were multiple instances, with different callers.
The only common piece was <code>MD_update</code>.
Since the second <code>MD_update</code> was already known
to be non-essential&mdash;it could be safely disabled to run under Purify&mdash;it
stood to reason that perhaps the first one was non-essential as well.
The context of each call looks basically identical (the source code
is not particularly well factored).
</p>

<p class=pp>
The Debian maintainer knew he didn't understand the code,
so he <a href="http://marc.info/?t=114651088900003&r=1&w=2">asked for help</a>
on the <i>openssl-dev</i> mailing list:
</p>

<pre>
    Subject:    Random number generator, uninitialised data and valgrind.
    Date:       2006-05-01 19:14:00
    
    When debbuging applications that make use of openssl using
    valgrind, it can show alot of warnings about doing a conditional
    jump based on an unitialised value.  Those unitialised values are
    generated in the random number generator.  It's adding an
    unintialiased buffer to the pool.
    
    The code in question that has the problem are the following 2
    pieces of code in crypto/rand/md_rand.c:
    
    247:
                    MD_Update(&amp;m,buf,j);
    
    467:
    #ifndef PURIFY
                    MD_Update(&amp;m,buf,j); /* purify complains */
    #endif
    
    Because of the way valgrind works (and has to work), the place
    where the unitialised value is first used, and the place were the
    error is reported can be totaly different and it can be rather
    hard to find what the problem is.
    
    ...
    
    What I currently see as best option is to actually comment out
    those 2 lines of code.  But I have no idea what effect this
    really has on the RNG.  The only effect I see is that the pool
    might receive less entropy.  But on the other hand, I'm not even
    sure how much entropy some unitialised data has.
    
    What do you people think about removing those 2 lines of code?
</pre>

<p class=pp>
He got two substantive replies.
The first reply was from someone with
an email address at <i>openssl.org</i> who
appears to be one of the developers:
</p>

<pre>
    List:       openssl-dev
    Subject:    Re: Random number generator, uninitialised data and valgrind.
    Date:       2006-05-01 22:34:12
    
    &gt; What I currently see as best option is to actually comment out
    &gt; those 2 lines of code.  But I have no idea what effect this
    &gt; really has on the RNG.  The only effect I see is that the pool
    &gt; might receive less entropy.  But on the other hand, I'm not even
    &gt; sure how much entropy some unitialised data has.
    &gt;
    Not much. If it helps with debugging, I'm in favor of removing them. 
    (However the last time I checked, valgrind reported thousands of bogus 
    error messages. Has that situation gotten better?)
</pre>

<p class=pp>
The second is from someone not at <i>openssl.org</i>
who answers the developer's question:
</p>

<pre>
    List:       openssl-dev
    Subject:    Re: Random number generator, uninitialised data and valgrind.
    Date:       2006-05-02 6:08:10
    
    &gt; Not much. If it helps with debugging, I'm in favor of removing them. 
    &gt; (However the last time I checked, valgrind reported thousands of bogus 
    &gt; error messages. Has that situation gotten better?)
    
    I recently compiled vanilla OpenSSL 0.9.8a with -DPURIFY=1 and on Debian
    GNU/Linux 'sid' with valgrind version 3.1.1 was able to debug some
    application using both TLS/SSL as S/MIME without any warning or error
    about the OpenSSL code. Without -DPURIFY you're indeed flooded with
    warnings.
    
    So yes I think not using the uninitialized memory (it's only a single
    line, the other occurrence is already commented out) helps valgrind.
</pre>

<p class=pp>
Both essentially said, &ldquo;go ahead, remove the <code>MD_update</code> line.&rdquo;
The Debian maintainer did, causing <code>RAND_add</code> not to add
anything to the entropy pool but still update the entropy estimate.
There were other <code>MD_update</code> calls in the code that
didn't use <code>buf</code>, and those remained.  The only one
that was a little unpredictable was one in <code>RAND_bytes</code>
that added the current process ID to the entropy pool on each call.
That's why OpenSSH could still generate 32,767 possible SSH keys
of a given type and size (one for each pid) instead of just one.
</p>

<br>
<p class=lp><b>
Cascade of Failures
</b></p>

<p class=pp>
Like any true fiasco, a cascade of bad decisions and mistakes
all lined up to make this happen:
</p>

<ul>
<li>
The OpenSSL code was too clever by half.   The intentional uninitialized
  memory references obscured the code and made it hard to
  test for real bugs.

<li>
The OpenSSL code isn't very well organized.  There was code in both
  <code>RAND_add</code> and <code>RAND_bytes</code> to update
  entropy to the pool instead of having that functionality factored into one place.
  The fact that one instance wasn't essential made it look
  like the other instance wasn't essential.

<li>
The OpenSSL code's paranoia hid the Debian-introduced bug.
  Throwing the pid into the entropy pool on each call to <code>RAND_bytes</code>
   isn't actually helping create entropy, but it does keep the buggy
   Debian version from being completely deterministic.
   If it had been completely deterministic, the bug 
   would likely have been noticed much sooner, probably long before
   it got into a stable release.

<li>
The Debian maintainer asked for help with code he didn't
   understand, but the snippets in his post to the OpenSSL list
   don't include enough context to understand where the
   <code>MD_update</code> calls really are in the code.
   Showing a few lines around each call wouldn't have made the
   situation clearer, since the two code sections look pretty
   similar.
   Mentioning the names of the functions containing each
   call might have helped.

<li>
The OpenSSL developers responded incorrectly, probably
   without actually looking at the code to see which calls 
   were being talked about.  The presence of the #ifdef PURIFY
   on the one call likely made it very easy to assume the other
   call was similarly unimportant.
</ul>

<p class=pp>
Reading various blogs you find various involved party's intelligence
being insulted, but this is really a failure of process, not of intelligence.
The maintainer knew he wasn't an expert on the code in 
question, asked the experts for help, and was given bad information.
</p>

<br>
<p class=lp><b>
Lessons
</b></p>

<p class=pp>
I've spent a lot of the past decade maintaining both
<a href="http://plan9.bell-labs.com/plan9/">Plan 9</a>
and a
<a href="http://swtch.com/plan9port/">port of the Plan 9 software to Unix</a>.
I've edited a lot of code I didn't fully understand,
and I've answered questions about code that I did understand
when other people came asking.
I've made my share of embarrassing mistakes editing
unfamiliar code, and I've probably given my share
of unintentionally wrong advice.
Even the best programmers are always going to make mistakes.
The lessons of the fiasco,
for me, are the steps that can be taken to make the mistakes 
less frequent and easier to find.
</p>

<p class=pp>For me, the lessons I take away are:</p>

<ul>
<li>Try not to write clever code.  Try to write well-organized code.

<li>Inevitably, you will write clever, poorly-organized code.
  If someone comes along asking questions about it,
  use that as a sign that perhaps the code is probably too clever or
  not well enough organized.  Rewrite it to be simpler and easier to understand.

<li>Avoid voodoo code.  Zeroing a variable multiple times, for example,
  doesn't affect correctness now, but it does make the code harder to
  understand and easier to break without noticing.

<li>Mailing list discussions aren't a substitute for real code review.
  People respond to email when they're tired or on their way out the door.
  Code reviews are supposed to be thorough and considered.
  Showing a side-by-side file diff of the before and after
  versions of <code>md_rand.c</code> to an OpenSSL developer
  as a real code review would likely have turned up the mistake.

<li>Distributions like Debian have to maintain their own copies of
  some programs at least temporarily.  That's inevitable, because
  not all projects will run on Debian's time constraints.
  But I'm surprised there was no followup with the OpenSSL developers 
  once the patch was created, trying to get them to accept it into the
  main tree.  That could have provoked a code review too.
  Failing that, I'm surprised Debian doesn't have an engineer whose job
  it is to understand OpenSSL and other security-critical bits of code
  and vet local changes in a formal process.
</ul>

<p class=pp>In my own software maintenance, I think I'm doing a 
pretty good job on the first three, and not such a great job 
on the last two.  It is tempting to say that for a low-profile
project like Plan 9 they're not really needed, but that's more
likely to be laziness than the truth.
</p>

<br>
<p class=lp><b>
Links and Notes
</b></p>

<p class=pp>
Here's the
<a href="http://www.debian.org/security/2008/dsa-1571">Debian announcement</a>. 
I have not seen any account of how Luciano Bello discovered the bug.
If you do, please post a comment.
</p>

<p class=pp>
Here's one of the original <a href="http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=363516">Debian bug reports</a> about Valgrind complaints.
The original poster actually has a correct fix;
the maintainer incorrectly (but reasonably) argues
that since there are other contexts that also cause
uninitialized references, the bug must be in <code>RAND_add</code> itself.
</p>

<p class=pp>
I've been talking about <code>RAND_add</code> and <code>RAND_bytes</code>,
but in the code the actual functions are <code>ssleay_rand_add</code> and <code>ssleay_rand_bytes</code>, in <code><a href="http://cvs.openssl.org/getfile/openssl/crypto/rand/md_rand.c?v=1.75">md_rand.c</a></code>.
The latter are used as the implementation of the former.
<code>RAND_poll</code> is in <code><a href="http://cvs.openssl.org/getfile/openssl/crypto/rand/rand_unix.c?v=1.7.2.11">rand_unix.c</a></code>, and
<code>RAND_load_file</code> is in <code><a href="http://cvs.openssl.org/getfile/openssl/crypto/rand/randfile.c?v=1.49">randfile.c</a></code>.
</p></p>





<div class="comments">
  <div class="comments-header old">
    <p>(Comments originally posted via Blogger.)</p>
  </div>
  <div class="comments-body">
    <div id="plus-comments">
 <div class="plus-comment"><ul><li class="plus-text">
    <p><a href='http://www.blogger.com/profile/04489474946274002576'>Jake Nelson</a> <span class="comment-when">(May 21, 2008 6:32 AM)</span> "If it helps with debugging" is not even close to the same as "Go ahead and remove it for production deployments" and portraying it as such is being disingenuous.</p>
 </li></ul></div>
 <div class="plus-comment"><ul><li class="plus-text">
    <p><a href='http://www.blogger.com/profile/10908210050410667635'>Lester</a> <span class="comment-when">(May 21, 2008 6:46 AM)</span> Another tactic might have been to XOR the remaining 'untouched' bytes in the buffer. That might have served everyones purposes.</p>
 </li></ul></div>
 <div class="plus-comment me"><ul><li class="plus-text">
    <p><a href="http://swtch.com/~rsc/">Russ Cox</a> <span class="comment-when">(May 21, 2008 6:52 AM)</span> That's interesting.  I've read the discussion as being about cleaning up the production version of the code so that it is easier to debug.  I hadn't noticed until your comment, but it is certainly possible to read the discussion as being about temporary changes to make just for debugging.<BR/><BR/>This just reinforces that mailing list discussion is not a substitute for code reviews.</p>
 </li></ul></div>
 <div class="plus-comment"><ul><li class="plus-text">
    <p><a href='http://www.blogger.com/profile/10974821214602254645'>Tonetheman</a> <span class="comment-when">(May 21, 2008 7:27 AM)</span> First off I DO NOT see why Debian needs to change openssl in the first place. Perhaps I do not understand that part.<BR/><BR/>Then second, valgrid/purify is a tool. Blindly following the suggestions of this or any other source analyzer tool is NOT the business of anyone who is upstream of the real package developers. Sorry. If you do not understand something do not change it.<BR/><BR/>I have worked at places before with zealots that use Java source analyzers like a weapon. It is a joke and they are a joke.<BR/><BR/>Use you head. Think think think. Just because valgrind/purify says it does not make it right. Lint was the same way and so will every other source analysis tool.</p>
 </li></ul></div>
 <div class="plus-comment"><ul><li class="plus-text">
    <p><a href='http://www.blogger.com/profile/01863908675256558774'>Maht</a> <span class="comment-when">(May 21, 2008 7:50 AM)</span> Relying on magic is bad form and not documenting magic is suicidal.<BR/><BR/>A simple<BR/><BR/>// use uninitialized data as entropy<BR/><BR/>would have helped until someone came along and said "let's zero the heap" for extra security.</p>
 </li></ul></div>
 <div class="plus-comment"><ul><li class="plus-text">
    <p><a href='http://www.blogger.com/profile/10303114242550248619'>josh reich</a> <span class="comment-when">(May 21, 2008 8:03 AM)</span> Thanks for the post. It was interesting & well written. Now I don't feel so bad for blindly updating my debian machine without doing further digging.</p>
 </li></ul></div>
 <div class="plus-comment"><ul><li class="plus-text">
    <p><a href='http://www.blogger.com/profile/16955170493368020909'>Justin Mason</a> <span class="comment-when">(May 21, 2008 8:46 AM)</span> Very good points about the dangers of "clever code", well put.<BR/><BR/>Regarding mailing lists being a poor substitute for proper code review -- that's true, but open source projects simply _have_ to use lists for this, there is no alternative.  Speaking from experience, a correctly-operating, well-established open source project may have developers spanning multiple continents, and an opportunity for such side-by-side code review arises once every couple of years at best, given that. <BR/><BR/>Maybe with the new trend of open source code review tools based on Google's Mondrian, we may come up soon with a mechanism for distributed code review better than patches and a bug tracker or mailing list.  Here's hoping.<BR/><BR/>By the way, I'd like to point out, since I've seen comments elsewhere indicating that this kind of issue would never have arisen in proprietary software -- this is sadly not the case.  I've worked in companies where old software passes into the "maintainance phase" of its lifecycle, and is immediately passed to a team of fresh-from-university junior developers who have had little or no contact with the product in advance, little understanding of the code, little understanding of how to fix bugs systematically, and no contact with the original developers for reviews.  As you might imagine, the results are occasionally disastrous... but since it's proprietary software, it's nowhere near as visible as the occasional disaster in open-source land.</p>
 </li></ul></div>
 <div class="plus-comment"><ul><li class="plus-text">
    <p><a href='http://www.blogger.com/profile/14780006777195037772'>Gábor</a> <span class="comment-when">(May 21, 2008 9:29 AM)</span> Also let's not forget the reason for this patch: to silence some valgrind warning.<BR/><BR/>i think debian should not patch a package (especially such an important, central package) just because some code-checker tool showed some warnings.<BR/><BR/>if openssl would crash, or be unusable in some other way, then ok, do something about it. but just for a valgrind-warning? simply submitting the patch upstream would have been a much better solution.</p>
 </li></ul></div>
 <div class="plus-comment"><ul><li class="plus-text">
    <p><a href='http://www.blogger.com/profile/11969143527962555101'>Jeff Walden</a> <span class="comment-when">(May 21, 2008 9:58 AM)</span> Don't write over-clever code is a good point, but even better would be to make sure every piece of code you write has tests.  If you know what the right behavior is, guarantee that behavior is reproducible and won't make its way into a release.  (Note you can do this even for randomness algorithms, albeit non-deterministically, as in <A HREF="http://mxr.mozilla.org/mozilla/source/js/tests/js1_5/Regress/regress-211590.js" REL="nofollow">regress-211590.js</A>.  That potentially could have been effective here, although it's probably unlikely.)  This isn't really a substitute for clean code (and more importantly, clean APIs), but at least you don't backslide now or when you eventually rewrite the code.</p>
 </li></ul></div>
 <div class="plus-comment"><ul><li class="plus-text">
    <p><a href='http://www.blogger.com/profile/03444621708860354327'>We Are Dave</a> <span class="comment-when">(May 21, 2008 10:07 AM)</span> tonetheman, maht and Gábor make excellent points.  <BR/><BR/>Two more points that haven't yet been given enough emphasis --<BR/><BR/>* The OpenSSL guys' "cathedral" attitude - straight out of the BSD charm school - has to shoulder some of the blame.  Each project needs a one-stop feedback mechanism that is followed by multiple core maintainers.  Power users like the Debian maintainers are the alpha and omega of open source; treating them as an inconvenient distraction is not just rude, it's self-destructive.  <BR/><BR/>* Debian's attitude to patching remains an accident waiting to happen.  Many other vendors have similarly flawed attitudes.  Patching should be a distributor's act of ultimate desperation, not a market differentiator or a policy thing.  If you need changes, submit them upstream, and if upstream turns them down, find out why not.</p>
 </li></ul></div>
 <div class="plus-comment me"><ul><li class="plus-text">
    <p><a href="http://swtch.com/~rsc/">Russ Cox</a> <span class="comment-when">(May 21, 2008 10:39 AM)</span> @Jeff Walden: One of the most interesting and subtle things about this bug is that the PRNG would have passed any single-process randomness test I can imagine.  (Definitely <A HREF="http://www.koders.com/javascript/fid9ACE373CC97944615ECD74938B8A900938FD42E5.aspx" REL="nofollow">regress-211590.js</A>.)<BR/><BR/>The PRNG was still generating a byte stream that, in isolation, was cryptographically random.  The problem is that if you ran it and I ran it, we had a good chance of getting the same byte stream.  <BR/><BR/>I'd be very interested to hear about a plausible test that would have found this problem.  I can't think of one.</p>
 </li></ul></div>
 <div class="plus-comment"><ul><li class="plus-text">
    <p><a href='http://www.blogger.com/profile/16751485442056650593'>sam</a> <span class="comment-when">(May 21, 2008 4:29 PM)</span> Luciano discovered the bug by accident: he needed to generate many prime numbers for one of his projects and was surprised that he was getting many duplicates.</p>
 </li></ul></div>
 <div class="plus-comment me"><ul><li class="plus-text">
    <p><a href="http://swtch.com/~rsc/">Russ Cox</a> <span class="comment-when">(May 21, 2008 4:40 PM)</span> @sam: Do you have a link to a description of exactly what Luciano was doing?  I believe you, but the obvious way to generate a lot of primes (using a single process) wouldn't have turned this up.</p>
 </li></ul></div>
 <div class="plus-comment"><ul><li class="plus-text">
    <p><a href='http://www.blogger.com/profile/15613957348593645695'>Aaron Denney</a> <span class="comment-when">(May 21, 2008 10:42 PM)</span> The complaints about how you shouldn't listen to source-code analysis tools are correct in general, but wrong in this specific case.  In C, reading from uninitialized memory invokes undefined behaviour.  Valgrind properly warned that something hinky was going on.</p>
 </li></ul></div>
 <div class="plus-comment"><ul><li class="plus-text">
    <p><a href='http://www.blogger.com/profile/16751485442056650593'>Sam Hocevar</a> <span class="comment-when">(May 22, 2008 1:43 AM)</span> @rsc: I'm afraid you will have to ask Luciano for details. All I have is this conversation on #debian-devel from a few days ago:<BR/><BR/>&lt;Sesse> how was this found? inspection, or that someone got the same key generated twice?<BR/>&lt;luciano> has really an accident. I was needing many primes numbers... 0:-)<BR/>&lt;Sesse> and you got the same numbers every time?<BR/>&lt;luciano> Sesse, not every time :P</p>
 </li></ul></div>
 <div class="plus-comment"><ul><li class="plus-text">
    <p><a href='http://kragen.livejournal.com/'>kragen</a> <span class="comment-when">(May 22, 2008 3:01 AM)</span> I see a lot of comments castigating Kurt for wanting to shut Valgrind<BR/>up.  For example:<BR/><BR/>> Then second, valgrid [sic]/purify is a tool. Blindly following the<BR/>> suggestions of this or any other source analyzer tool is NOT the<BR/>> business of anyone who is upstream [sic] of the real package<BR/>> developers.<BR/><BR/>Leaving aside that neither Valgrind nor Purify analyzes source code,<BR/>there's a very good reason to modify the code to shut it up: if it<BR/>emits a lot of warnings that don't indicate actual errors in the<BR/>program, then you can't use it to find actual errors.  Valgrind is a<BR/>very useful tool, and it's worth going to some effort to get it to<BR/>work, and work on the production version of the software, especially<BR/>security-critical software like OpenSSL, where a buffer overflow or a<BR/>double free is likely to result in an unauthenticated-remote-root hole.<BR/><BR/>I think Luciano was generating a bunch of SSL certificates.  The<BR/>obvious way to do this would be with a shell script; I don't know if<BR/>that's what he did.  He said he got the same certificate five times in<BR/>24 hours of generating certificates!</p>
 </li></ul></div>
 <div class="plus-comment"><ul><li class="plus-text">
    <p><a href='http://kragen.livejournal.com/'>kragen</a> <span class="comment-when">(May 22, 2008 3:01 AM)</span> Wow, Blogger comments sure do suck.  Sorry about that.</p>
 </li></ul></div>
 <div class="plus-comment"><ul><li class="plus-text">
    <p><a href='http://www.blogger.com/profile/03185140656482868193'>drew</a> <span class="comment-when">(May 22, 2008 5:53 AM)</span> It was also recently noticed by the folk at github.com, where they noticed seemingly-unrelated users generating the same public SSH keys.<BR/><BR/><A HREF="http://github.com/blog/63-ssh-keys-generated-on-debian-ubuntu-compromised" REL="nofollow">(Brief mention here.)</A></p>
 </li></ul></div>
 <div class="plus-comment"><ul><li class="plus-text">
    <p><a href='http://matt.ucc.asn.au/'>matt</a> <span class="comment-when">(May 22, 2008 7:14 AM)</span> Putting getpid() into the mix is (most likely) a sensible design decision - otherwise if a program fork()s and keeps using the same pool, the child and parent will generate the same "random" bytes.</p>
 </li></ul></div>
 <div class="plus-comment"><ul><li class="plus-text">
    <p><a href='http://www.blogger.com/profile/11926139083455275005'>Resuna</a> <span class="comment-when">(May 22, 2008 7:31 AM)</span> The biggest failure, to me, is not documenting when you're being clever. Sometimes you have to be clever, and use clever code, but you should explain why you're doing it. I would much rather read a piece of code that only had an average of 0.8 comments per file, if all those comments were places where the author thought he was being clever and explained why.<BR/><BR/>If you write clever code, brag about it in the comments. It will help some poor fellow who doesn't understand it, and even if it turns out you weren't really being clever they'll like you better for having explained why it was simply obscure so they know whether it's safe to simplify it. And that "poor fellow" may well be you, five years from now.<BR/><BR/>Comments about comments:<BR/><BR/>* Medieval cathedrals were actually built using the bazaar system. Many of them fell down as a result. This terminology is really horrible.<BR/><BR/>* I agree with whoever suggested that if a debugging tool is telling you you're doing something stupid, maybe you are.<BR/><BR/>* Bug trackers are much better places to do this sort of thing. When googling for a bug dumps me in a bug tracker somewhere, I always take advantage of that to do a bit of a read about similar bugs, since I'm thinking about the problem at the time, and drop in comments and patches as appropriate.<BR/><BR/>* Putting getpid() in the mix is probably useful if (a) you're sure that's the last place you're forking, or (b) you're doing it after you fork().</p>
 </li></ul></div>
 <div class="plus-comment"><ul><li class="plus-text">
    <p><a href='http://www.blogger.com/profile/13732301290186175840'>Mark</a> <span class="comment-when">(May 22, 2008 12:13 PM)</span> "Also let's not forget the reason for this patch: to silence some valgrind warning.<BR/><BR/>i think debian should not patch a package (especially such an important, central package) just because some code-checker tool showed some warnings."<BR/><BR/>The issue here wasn't warnings on OpenSSL, but that you got the warnings whenever you ran valgrind on software that used OpenSSL. This made it very hard to see any potential problems with your software because of the huge numbers of OpenSSL-related warnings.<BR/><BR/>That's also presumably why "If it helps with debugging" was interpreted as it being OK to use in production deployments - it's a production deployment of OpenSSL, possibly used to debug some client code.</p>
 </li></ul></div>
 <div class="plus-comment"><ul><li class="plus-text">
    <p><a href='http://viric.livejournal.com/'>viric</a> <span class="comment-when">(May 23, 2008 10:00 AM)</span> Here you (all) speak a bit on how to comment code... I want to add some pence... once I learnt a good lesson:<BR/>- The code is the solution to a problem. In comments, it helps if you write what's the problem the code solves. It doesn't help that much, if the comment explains *again* only the solution.<BR/><BR/>For me, the /* even if n != i, use the full array */ is another example of redundant comment, instead of explaining the problem the next line solves: Increase the entropy using the uninitialized part of the buffer, as we already counted it with RAND_add.<BR/>(if I understood correctly)</p>
 </li></ul></div>
 <div class="plus-comment"><ul><li class="plus-text">
    <p><a href='http://www.blogger.com/profile/02944591945765091680'>m</a> <span class="comment-when">(May 24, 2008 1:14 AM)</span> 2 Justin:<BR/><BR/>side-by-side review is not only "sit side by side at the table", but also "see side by side old version and new version".<BR/><BR/>basically, I don't see any problem establishing proper software reviewing process in open source teams spanning many continents.<BR/><BR/>1. Patch is sent for review.<BR/>2. Reviewer checks the change thoroughly, with diffs and so on, and comments on those.<BR/>3. Sender addresses the comments.<BR/>2 and 3 repeat until reviewer gives his clear approval.<BR/>4. Sender submits the code to the trunk.<BR/><BR/>And approval from reviewer means that he shares the responsibility with the sender for whatever bugs were introduced.<BR/><BR/>I wonder, why such big thing like Debian still doesn't get the idea of reviewing.</p>
 </li></ul></div>
 <div class="plus-comment"><ul><li class="plus-text">
    <p><a href='http://www.blogger.com/profile/02944591945765091680'>m</a> <span class="comment-when">(May 24, 2008 1:18 AM)</span> continuing..<BR/><BR/>and this is not a question of tools, the process could be set up with a simple diff. I really don't understand what were the obstacles.<BR/><BR/>btw, there is one Mondrian-clone by Guido van Rossum, called Rietveld.</p>
 </li></ul></div>
 <div class="plus-comment"><ul><li class="plus-text">
    <p><a href='http://www.blogger.com/profile/03975843196252061184'>Monstre</a> <span class="comment-when">(August 8, 2009 11:13 AM)</span> hey the exception is well handled .. never thought of this way .. nice ./.<br />www.spyfree.info . . you get more details..</p>
 </li></ul></div>
 <div class="plus-comment"><ul><li class="plus-text">
    <p><a href='http://www.blogger.com/profile/12326115153674468849'>Owen</a> <span class="comment-when">(April 19, 2011 7:26 AM)</span> Why has no-one mentioned testing as being one of the problems here?<br /><br />If there were a test that generated say 100000 keys and did some statistical analysis, the problem would have had &gt; 95% of being caught.</p>
 </li></ul></div>
    </div>
  </div>
</div>


      </div>
      
      
    </div>

    
<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
var pageTracker = _gat._getTracker("UA-3319603-2");
pageTracker._initData();
pageTracker._trackPageview();
</script>

    
    
  </body>
</html>
















