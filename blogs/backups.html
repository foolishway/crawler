<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <title>research!rsc: Backups, heal thyself</title>
    <link rel="alternate" type="application/atom+xml" title="research!rsc - Atom" href="http://research.swtch.com/feed.atom" />
    
<meta name="viewport" content="width=device-width, initial-scale=1">
<link href='https://fonts.googleapis.com/css?family=Inconsolata:400,700' rel='stylesheet' type='text/css'>
<script type="text/javascript" src="https://use.typekit.com/skm6yij.js"></script>
<script type="text/javascript">try{Typekit.load();}catch(e){}</script>
<style>
  body {
    padding: 0;
    margin: 0;
    font-size: 100%;
    font-family: 'Minion Pro';
  }
  @media print {
    img {page-break-inside: avoid;}
    div.nosplit {page-break-inside: avoid;}
  }
  img.center {
    display: block;
    margin: 0 auto;
  }
  .pad {
    padding-top: 1em;
    padding-bottom: 1em;
  }
  a.anchor, a.back, a.footnote {
    color: black !important;
    text-decoration: none !important;
  }
  a.back {
    font-size: 50%;
  }
  @media print {
    a.back {display: none;}
  }
  .header {
    height: 1.25em;
    background-color: #dff;
    margin: 0;
    padding: 0.1em 0.1em 0.2em;
    border-top: 1px solid black;
    border-bottom: 1px solid #8ff;
  }
  .header h3 {
    margin: 0;
    padding: 0 2em;
    display: inline-block;
    padding-right: 2em;
    font-style: italic;
    font-size: 90%;
  }
  .rss {
    float: right;
    padding-top: 0.2em;
    padding-right: 2em;
    display: none;
  }
  .toc {
    margin-top: 2em;
  }
  .toc-title {
    font-family: "caflisch-script-pro";
    font-size: 300%;
    line-height: 50%;
  }
  .toc-subtitle {
    display: block;
    margin-bottom: 1em;
    font-size: 83%;
  }
  @media only screen and (max-width: 550px) { .toc-subtitle { display: none; } }
  .header h3 a {
    color: black;
  }
  .header h4 {
    margin: 0;
    padding: 0;
    display: inline-block;
    font-weight: normal;
    font-size: 83%;
  }
  @media only screen and (max-width: 550px) { .header h4 { display: none; } }
  .main {
    padding: 0 2em;
  }
  @media only screen and (max-width: 479px) { .article { font-size: 120%; } }
  .article h1 {
    text-align: center;
    font-size: 200%;
  }
  .copyright {
    font-size: 83%;
  }
  .subtitle {
      font-size: 65%;
  }
  .normal {
    font-size: medium;
    font-weight: normal;
  }
  .when {
    text-align: center;
    font-size: 100%;
    margin: 0;
    padding: 0;
  }
  .when p {
    margin: 0;
    padding: 0;
  }
  .article h2 {
    font-size: 125%;
    padding-top: 0.25em;
  }
  .article h3 {
    font-size: 100%;
  }
  pre {
    margin-left: 4em;
    margin-right: 4em;
  }
  pre, code {
    font-family: 'Inconsolata', monospace;
    font-size: 100%;
  }
  .footer {
    margin-top: 10px;
    font-size: 83%;
    font-family: sans-serif;
  }
  .comments {
    margin-top: 2em;
    background-color: #ffe;
    border-top: 1px solid #aa4;
    border-left: 1px solid #aa4;
    border-right: 1px solid #aa4;
  }
  .comments-header {
    padding: 0 5px 0 5px;
  }
  .comments-header p {
    padding: 0;
    margin: 3px 0 0 0;
  }
  .comments-body {
    padding: 5px 5px 5px 5px;
  }
  #plus-comments {
    border-bottom: 1px dotted #ccc;
  }
  .plus-comment {
    width: 100%;
    font-size: 14px;
    border-top: 1px dotted #ccc;
  }
  .me {
    background-color: #eec;
  }
  .plus-comment ul {
    margin: 0;
    padding: 0;
    list-style: none;
    width: 100%;
    display: inline-block;
  }
  .comment-when {
    color:#999;
    width:auto;
    padding:0 5px;
  }
  .old {
    font-size: 83%;
  }
  .plus-comment ul li {
    display: inline-block;
    vertical-align: top;
    margin-top: 5px;
    margin-bottom: 5px;
    padding: 0;
  }
  .plus-icon {
    width: 45px;
  }
  .plus-img {
    float: left;
    margin: 4px 4px 4px 4px;
    width: 32px;
    height: 32px;
  }
  .plus-comment p {
    margin: 0;
    padding: 0;
  }
  .plus-clear {
    clear: left;
  }
  .toc-when {
    font-size: 83%;
    color: #999;
  }
  .toc {
    list-style: none;
  }
  .toc li {
    margin-bottom: 0.5em;
  }
  .toc-head {
    margin-bottom: 1em !important;
    font-size: 117%;
  }
  .toc-summary {
    margin-left: 2em;
  }
  .favorite {
    font-weight: bold;
  }
  .article p, .article ol {
    line-height: 144%;
  }
  sup, sub {
    vertical-align: baseline;
    position: relative;
    font-size: 83%;
  }
  sup {
    bottom: 1ex;
  }
  sub {
    top: 0.8ex;
  }

  .main {
    position: relative;
    margin: 0 auto;
    padding: 0;
    width: 900px;
  }
  @media only screen and (min-width: 768px) and (max-width: 959px) { .main { width: 708px; } }
  @media only screen and (min-width: 640px) and (max-width: 767px) { .main { width: 580px; } }
  @media only screen and (min-width: 480px) and (max-width: 639px) { .main { width: 420px; } }
  @media only screen and (max-width: 479px) { .main { width: 300px; } }

</style>

  </head>
  <body>
    
<div class="header">
  <h3><a href="/">research!rsc</a></h3>
  <h4>Thoughts and links about programming,
    by <a href="https://swtch.com/~rsc/" rel="author">Russ Cox</a> </h4>
  <a class="rss" href="/feed.atom"><img src="/feed-icon-14x14.png" /></a>
</div>

    <div class="main">
      <div class="article">
        <h1>Backups, heal thyself
        
        <div class="normal">
        <div class="when">
          
            Posted on Sunday, April 13, 2008.
            
          
        </div>
        </div>
        </h1>
        
<p><center>
<img src="http://research.swtch.com/venti.jpg" border="0" alt="MIT venti server" /></center>

<p class=pp>
Around 2000, Sean Quinlan and Sean Dorward built a content-addressed storage system called Venti.  Their paper, &ldquo;<a href="http://plan9.bell-labs.com/sys/doc/venti.pdf"><b>Venti: a new approach to archival storage</b></a>&rdquo; (PDF; also <a href="http://plan9.bell-labs.com/sys/doc/venti.html">HTML</a>), won best paper at the storage conference where it was presented.  Today's post is about how Venti can heal itself.
</p>

<p class=pp>Venti names stored objects by their SHA1 hashes: you write a block, you get back the SHA1 hash.  You show up with a SHA1 hash, you can get the block.  Objects larger than a block are typically broken up into blocks and then stored in a tree.  Each pointer in the tree is the SHA-1 hash of the block it points to:</p>

<center>
<img src="http://research.swtch.com/tree1.png" border="0" alt="Hash trees" />
</center>

<p class=lp>Thus, if you've stored a big file (say, a disk image) and you change one block, only that one block and the (probably five or so) blocks that point at it actually change: the rest of the storage can be shared with the previous copy of the file.</p>

<p class=pp>The primary benefit of using content-addressing is that duplicates get removed for free.  If two different people write the same data, Venti only stores the data once.  Or if one person archives the same data twice, Venti only stores the data once.  My research group at MIT runs a Venti server to store FFS disk images of its main file server.  Writing the same images over and over again only stores changed blocks, and if multiple people have the same giant files, they take up extra space on the file server itself, but not in Venti.  Our live file system usage is about 600GB, but the incremental backup cost in Venti is about 2 GB per night.  All our nightly backups going back to 2005 take up about 3 TB, or 1.7 TB compressed.</p>

<p class=pp>
Another benefit of using content-addressing is that if the data goes bad, you notice.  You can check the SHA-1 hash of the data returned by a read to make sure it is the block you expected.  Clients can verify the data returned by the server, and the server can verify the data returned by its disks.  In fact the latter has been the bigger problem in Venti installations: disks go bad, and if you tend to notice more if you have checks like these.
</p>

<p class=pp>
A few years ago, I wanted to download all the <a href="http://plan9.bell-labs.com/who/seanq/p9trace.html">6 GB of file system traces</a> used in the Venti paper.  Not all of the files downloaded correctly: a few were truncated too early.  It turned out that the Venti server now storing the traces at Bell Labs had some disk corruption, and the Venti server noticed because the SHA-1 hashes didn't match expectations.  No problem, just use the earlier Venti server that the data was copied from.  That server has had disk corruption too, some of it overlapping the bad blocks.  So there are still traces that can't be read.  Okay, well the traces were saved on backup tapes too.  Dig those up, and the backup tapes aren't complete either: still two trace files with missing blocks.  There are also backup tapes of the original file system blocks that were used to create the traces.  Those are actually readable, so we can regenerate the bad trace files and have a complete set again.
</p>

<p class=pp>
Here's the fun part.  The original trace files were stored as a single Venti archive, a giant hash tree like the one pictured above that contains pointers to all the trace files.  Not all the files can be read out of the archive, since we have these pointers to missing blocks.  Creating a new archive holding just the two missing trace files <i>makes the old archive start working</i>.
Now that Venti has blocks with the desired SHA1 hashes, the pointers to missing blocks
become pointers to existing blocks.  
Given the right raw materials, the broken archive healed automatically.</p>

<p class=pp>
With a little engineering, you could create a typical incremental backup
system that didn't use hashes to identify duplicate blocks, and you'd probably
end up being within a factor of two as space-efficient as Venti.
For a long time I had this lingering fear that perhaps indexing by SHA-1 hash,
which is pretty expensive to implement efficiently, was overkill.
Watching that previously broken archive start working again
was the moment when I fully believed that Venti's was the right approach.</p>

<br>
<p class=lp>
<i>Further reading</i>.  The use of SHA1 specifically isn't really important: any strong collision-resistant hash function will do, though <a href="http://www.usenix.org/events/hotos03/tech/henson.html">people</a> <a href="http://www.usenix.org/event/usenix06/tech/full_papers/black/black_html/index.html">disagree</a> on the wisdom of this approach.  Remember that Venti is being used in situations where there are no adversaries: the main concern is an accidental collision.  The second paper just linked to summarizes:
<blockquote>
We conclude that it is certainly fine to use a 160-bit hash function like SHA1 or RIPEMD-160 with compare-by-hash. The chances of an accidental collision is about 2^-160. This is unimaginably small. You are roughly 2^90 times more likely to win a U.S. state lottery and be struck by lightning simultaneously than you are to encounter this type of error in your file system.
</blockquote>
</p></p>





<div class="comments">
  <div class="comments-header old">
    <p>(Comments originally posted via Blogger.)</p>
  </div>
  <div class="comments-body">
    <div id="plus-comments">
 <div class="plus-comment"><ul><li class="plus-text">
    <p><a href='http://www.blogger.com/profile/02430615130349705538'>Craig</a> <span class="comment-when">(April 14, 2008 11:16 AM)</span> That's also how the StarTeam Native-II file repository works. Stores full images of each version, compressed and indexed with MD5 hashes. So no reverse-delta penalty for diffing back versions of files.</p>
 </li></ul></div>
 <div class="plus-comment"><ul><li class="plus-text">
    <p><a href='http://www.blogger.com/profile/17140800379422429193'>francois.beausoleil</a> <span class="comment-when">(April 14, 2008 12:34 PM)</span> The Git version control system also stores content as blobs, indexed by SHA-1 hashes.</p>
 </li></ul></div>
 <div class="plus-comment"><ul><li class="plus-text">
    <p><a href='http://www.blogger.com/profile/11760508644619954982'>andrew cooke</a> <span class="comment-when">(April 14, 2008 2:50 PM)</span> the 2^-160 is a bit misleading.  as the first paper points out (search for "birthday") you're going to start getting collisions when you have around 2^80 blocks.  that's still a lot of blocks, but *significantly* less than the 2^160 you might infer from what you wrote.</p>
 </li></ul></div>
 <div class="plus-comment"><ul><li class="plus-text">
    <p><a href='http://www.blogger.com/profile/17888392276064618168'>Karthik</a> <span class="comment-when">(April 14, 2008 6:51 PM)</span> EMC's Centera uses the same concept, though it used MD5 hashes.</p>
 </li></ul></div>
 <div class="plus-comment"><ul><li class="plus-text">
    <p><a href='http://www.blogger.com/profile/04108383538978020010'>jricher</a> <span class="comment-when">(April 14, 2008 9:20 PM)</span> I understand the birthday problem, but it could be easily solved by moving from sha1 to sha256. This would be less space efficient when you were storing the trees, but that's not going to be the majority of your storage cost anyway. Doing this would make the chance of a collision insignificant for even the largest datasets. <BR/><BR/>As far as the overhead of using cryptographically strong hashes is concerned - I'm a lot more concerned about data integrity than a slightly slow backup, and it's always possible to move the hash calculation into hardware if it becomes advantageous to do so.</p>
 </li></ul></div>
 <div class="plus-comment"><ul><li class="plus-text">
    <p><a href='http://www.blogger.com/profile/16242875319857103661'>stevedekorte</a> <span class="comment-when">(October 9, 2009 2:07 PM)</span> While there&#39;s a lot of overhead, it seems the data integrity problem be solved by verifying the bits on writes just as we do for normal hash tables. Perhaps using larger blocks that are losslessly compressed would speed this up.<br /><br />I&#39;m curious about using this system for general purpose file systems where we often can&#39;t afford to keep around all changes. Would reference counts be the best way to go for tracking when to delete blocks?</p>
 </li></ul></div>
    </div>
  </div>
</div>


      </div>
      
      
    </div>

    
<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
var pageTracker = _gat._getTracker("UA-3319603-2");
pageTracker._initData();
pageTracker._trackPageview();
</script>

    
    
  </body>
</html>
















