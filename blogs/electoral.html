<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <title>research!rsc: Electoral Programming</title>
    <link rel="alternate" type="application/atom+xml" title="research!rsc - Atom" href="http://research.swtch.com/feed.atom" />
    
<meta name="viewport" content="width=device-width, initial-scale=1">
<link href='https://fonts.googleapis.com/css?family=Inconsolata:400,700' rel='stylesheet' type='text/css'>
<script type="text/javascript" src="https://use.typekit.com/skm6yij.js"></script>
<script type="text/javascript">try{Typekit.load();}catch(e){}</script>
<style>
  body {
    padding: 0;
    margin: 0;
    font-size: 100%;
    font-family: 'Minion Pro';
  }
  @media print {
    img {page-break-inside: avoid;}
    div.nosplit {page-break-inside: avoid;}
  }
  img.center {
    display: block;
    margin: 0 auto;
  }
  .pad {
    padding-top: 1em;
    padding-bottom: 1em;
  }
  a.anchor, a.back, a.footnote {
    color: black !important;
    text-decoration: none !important;
  }
  a.back {
    font-size: 50%;
  }
  @media print {
    a.back {display: none;}
  }
  .header {
    height: 1.25em;
    background-color: #dff;
    margin: 0;
    padding: 0.1em 0.1em 0.2em;
    border-top: 1px solid black;
    border-bottom: 1px solid #8ff;
  }
  .header h3 {
    margin: 0;
    padding: 0 2em;
    display: inline-block;
    padding-right: 2em;
    font-style: italic;
    font-size: 90%;
  }
  .rss {
    float: right;
    padding-top: 0.2em;
    padding-right: 2em;
    display: none;
  }
  .toc {
    margin-top: 2em;
  }
  .toc-title {
    font-family: "caflisch-script-pro";
    font-size: 300%;
    line-height: 50%;
  }
  .toc-subtitle {
    display: block;
    margin-bottom: 1em;
    font-size: 83%;
  }
  @media only screen and (max-width: 550px) { .toc-subtitle { display: none; } }
  .header h3 a {
    color: black;
  }
  .header h4 {
    margin: 0;
    padding: 0;
    display: inline-block;
    font-weight: normal;
    font-size: 83%;
  }
  @media only screen and (max-width: 550px) { .header h4 { display: none; } }
  .main {
    padding: 0 2em;
  }
  @media only screen and (max-width: 479px) { .article { font-size: 120%; } }
  .article h1 {
    text-align: center;
    font-size: 200%;
  }
  .copyright {
    font-size: 83%;
  }
  .subtitle {
      font-size: 65%;
  }
  .normal {
    font-size: medium;
    font-weight: normal;
  }
  .when {
    text-align: center;
    font-size: 100%;
    margin: 0;
    padding: 0;
  }
  .when p {
    margin: 0;
    padding: 0;
  }
  .article h2 {
    font-size: 125%;
    padding-top: 0.25em;
  }
  .article h3 {
    font-size: 100%;
  }
  pre {
    margin-left: 4em;
    margin-right: 4em;
  }
  pre, code {
    font-family: 'Inconsolata', monospace;
    font-size: 100%;
  }
  .footer {
    margin-top: 10px;
    font-size: 83%;
    font-family: sans-serif;
  }
  .comments {
    margin-top: 2em;
    background-color: #ffe;
    border-top: 1px solid #aa4;
    border-left: 1px solid #aa4;
    border-right: 1px solid #aa4;
  }
  .comments-header {
    padding: 0 5px 0 5px;
  }
  .comments-header p {
    padding: 0;
    margin: 3px 0 0 0;
  }
  .comments-body {
    padding: 5px 5px 5px 5px;
  }
  #plus-comments {
    border-bottom: 1px dotted #ccc;
  }
  .plus-comment {
    width: 100%;
    font-size: 14px;
    border-top: 1px dotted #ccc;
  }
  .me {
    background-color: #eec;
  }
  .plus-comment ul {
    margin: 0;
    padding: 0;
    list-style: none;
    width: 100%;
    display: inline-block;
  }
  .comment-when {
    color:#999;
    width:auto;
    padding:0 5px;
  }
  .old {
    font-size: 83%;
  }
  .plus-comment ul li {
    display: inline-block;
    vertical-align: top;
    margin-top: 5px;
    margin-bottom: 5px;
    padding: 0;
  }
  .plus-icon {
    width: 45px;
  }
  .plus-img {
    float: left;
    margin: 4px 4px 4px 4px;
    width: 32px;
    height: 32px;
  }
  .plus-comment p {
    margin: 0;
    padding: 0;
  }
  .plus-clear {
    clear: left;
  }
  .toc-when {
    font-size: 83%;
    color: #999;
  }
  .toc {
    list-style: none;
  }
  .toc li {
    margin-bottom: 0.5em;
  }
  .toc-head {
    margin-bottom: 1em !important;
    font-size: 117%;
  }
  .toc-summary {
    margin-left: 2em;
  }
  .favorite {
    font-weight: bold;
  }
  .article p, .article ol {
    line-height: 144%;
  }
  sup, sub {
    vertical-align: baseline;
    position: relative;
    font-size: 83%;
  }
  sup {
    bottom: 1ex;
  }
  sub {
    top: 0.8ex;
  }

  .main {
    position: relative;
    margin: 0 auto;
    padding: 0;
    width: 900px;
  }
  @media only screen and (min-width: 768px) and (max-width: 959px) { .main { width: 708px; } }
  @media only screen and (min-width: 640px) and (max-width: 767px) { .main { width: 580px; } }
  @media only screen and (min-width: 480px) and (max-width: 639px) { .main { width: 420px; } }
  @media only screen and (max-width: 479px) { .main { width: 300px; } }

</style>

  </head>
  <body>
    
<div class="header">
  <h3><a href="/">research!rsc</a></h3>
  <h4>Thoughts and links about programming,
    by <a href="https://swtch.com/~rsc/" rel="author">Russ Cox</a> </h4>
  <a class="rss" href="/feed.atom"><img src="/feed-icon-14x14.png" /></a>
</div>

    <div class="main">
      <div class="article">
        <h1>Electoral Programming
        
        <div class="normal">
        <div class="when">
          
            Posted on Friday, June 13, 2008.
            
          
        </div>
        </div>
        </h1>
        
<p><p class=pp>
A few days ago, the web site <a href="http://www.fivethirtyeight.com">fivethirtyeight.com</a>
posed the question of how many ways there were to
win the electoral college with a minimal set of states,
that is, sets of states that add up to 270 or more votes,
but for which removing any state from the set would
drop under 270.
</p>

<p class=pp>
Isabel Lugo, a mathematician, reached into his toolbox
and pulled out the most trusted tool in combinatorics:
generating functions.  His <a href="http://godplaysdice.blogspot.com/2008/06/fuller-solution-to-tuesdays-electoral.html">recent blog post</a> gives a nice
explanation.
</p>

<p class=pp>
I'm a programmer, so I reached into my toolbox and pulled
out my favorite tool for combinatorics: dynamic programming.
Dynamic programming is an odd name for what is essentially
cached recursion, minus the recursion.
</p>

<p class=pp>
Lets consider the simpler problem of counting the number
of ways to add up to exactly 270 electoral votes.
We can write a simple recursive equation to compute the number
of ways:
</p>

<pre class=p1>
ways(n, v) = ways(n-1, v-votes[n]) + ways(n-1, v)
</pre>

<p class=pp>
<code>Ways(n, v)</code> is the number of ways, using just the first <code>n</code> states,
to get <code>v</code> votes.  Either you include state <code>n</code>'s votes or you don't.
If you do, then you need <code>v-votes[n]</code> votes from the first <code>n-1</code>
states, and if you don't, then you need <code>v</code> votes from the
first <code>n-1</code> states.  <code>Ways(n, v)</code> is just the sum of the number
of ways to achieve either of the two simpler scenarios.
(There is of course a base case: using the first 0 states, there's one way
to get 0 votes, and no way to get any other number of votes.
There's also no way, using any number of states,
to get a negative number of votes.)
</p>

<p class=pp>
This makes for a simple recursive program:
</p>

<pre class=smallish>
    int64
    ways(int n, int64 v)
    {
        if(n == 0 && v == 0)
            return 1;
        if(v &lt; 0 || n &lt;= 0)
            return 0;
        return ways(n-1, v-votes[n-1]) + ways(n-1, v);
    }
    
    printf("ways to get exactly 270 = %lld\n", ways(51, 270));
</pre>

<p class=lp>
(The District of Columbia doesn't get any congressmen, but it does get
electoral votes, hence 51.  The discussion above talked about <code>votes[n]</code>
as though <code>votes</code> was 1-indexed, but in C it is 0-indexed,
hence <code>votes[n-1]</code>.)
</p>

<p class=pp>
Each call to <code>ways(n, *)</code> results in two calls to <code>ways(n-1, *)</code>,
making for an unfortunate O(2<sup>N</sup>) run-time;
since N=51, it's worth our time to write a faster program.
</p>

<p class=pp>
There are 2<sup>51</sup> function calls but only 52*271 different possible
function arguments; thus the recursive program repeats the same calls
billions and billions of times.  If we add a cache, we can avoid
the repetition:
</p>

<pre class=smallish>
    int64 cache[52][271];   // initialized to -1

    int64
    ways(int n, int64 v)
    {
        if(n == 0 && v == 0)
            return 1;
        if(v &lt; 0 || n &lt;= 0)
            return 0;
        if(cache[n][v] == -1)
            cache[n][v] = ways(n-1, v-votes[n-1]) + ways(n-1, v);
        return cache[n][v];
    }

    printf("ways to get exactly 270 = %lld\n", ways(51, 270));
</pre>

<p class=lp>
Now, after the initial call to <code>ways</code>, there are at most two calls to 
fill each cache entry, or at most 2*52*271 calls.  That will run 
<i>much</i> faster.
</p>

<p class=pp>
We could stop here, but we can simplify the code even further
by removing the recursion and filling in the cache via iteration.
</p>

<pre class=smallish>
    int64 ways[52][271];    // initialized to 0
    
    ways[0][0] = 1;
    for(n=1; n&lt;=51; n++){
        for(v=0; v&lt;=270; v++){
            ways[n][v] = ways[n-1][v];
            if(v-votes[n-1] &gt;= 0)
                ways[n][v] += ways[n-1][v-votes[n-1]];
        }
    }

    printf("ways to get exactly 270 = %lld\n", ways[51][270]);
</pre>

<p class=lp>
It's important that at the time the iteration is computing <code>ways[n][v]</code>,
it has already computed the entries in ways it will need.
Since <code>ways(n, *)</code> depends on <code>ways(n-1, *)</code> it suffices to fill in the whole
row <code>ways[n-1]</code> before starting on <code>ways[n]</code>.  It's not necessary to
iterate over <code>v</code> from 0 to 270.  We could go from 270 to 0:
</p>

<pre class=smallish>
    int64 ways[52][271];    // initialized to 0
    
    ways[0][0] = 1;
    for(n=1; n&lt;=51; n++){
        for(v=270; v&gt;=0; v--){
            ways[n][v] = ways[n-1][total];
            if(v-votes[n-1] &gt;= 0)
                ways[n][v] += ways[n-1][v-votes[n-1]];
        }
    }

    printf("ways to get exactly 270 = %lld\n", ways[51][270]);
</pre>

<p class=lp>
In fact, <code>ways[n][v]</code> depends on<code> ways[n-1][u]</code> only for <code>u &lt;= v</code>, so
if <code>v</code> iterates down from 270 to 0, we can reuse a single table row
(we can also take the opportunity to replace <code>n-1</code> with <code>n</code>,
now that <code>n</code> doesn't index into <code>ways</code> anymore):
</p>

<pre class=smallish>
    int64 ways[271];    // initialized to 0

    ways[0] = 1;
    for(n=0; n&lt;51; n++)
        for(v=270; v&gt;=votes[n]; v--)
            ways[v] += ways[v-votes[n]];

    printf("ways to get exactly 270 = %lld\n", ways[270]);
</pre>

<p class=lp>
Many dynamic programming solutions have this property,
that you only need array entries below and to the left, so that if you
iterate from the right you can keep just a single row.
For this problem, the space savings is not significant,
but in some problems it is.
</p>

<p class=pp>
Now we've got a pretty simple, straightforward way to
compute the number of ways to get 270 votes, but that
wasn't the original question.  The original question was 
how many ways there are to get at least 270 votes but
with a minimal set of states.
</p>

<p class=pp>
We could compute the number of ways to get 270 votes, and 271, and 272, etc.,
but for the larger counts, we need to make sure only to include
ways that use a minimal set.
We can ensure minimality by using state <code>n</code>'s votes only 
if the total is not big enough already:
</p>

<pre class=smallish>
    int64 ways[400];    // initialized to 0

    ways[0] = 1;
    for(n=1; n&lt;=51; n++)
        for(v=270+votes[n]-1; v&gt;=votes[n]; v--)
            ways[v] += ways[v-votes[n]];
</pre>

<p class=lp>
The <code>+=</code> will never add in <code>ways[u]</code> for any <code>u &gt;= 270</code>.
<code>Ways[v]</code> is the number of ways to get exactly <code>v</code> votes 
with a set of states that is minimal with respect to 270.
To get the number of ways to get at least 270 votes, sum
the end of the array:
</p>

<pre class=smallish>
    total = 0;
    for(v=270; v&lt;400; v++)
        total += ways[v];

    printf("minimal ways to get at least 270 = %lld\n", total);
</pre>

<p class=lp>
The upper bound of 400 is just a number that is big enough:
no minimal winning set could have more than 400 votes.*
</p>

<p class=pp>
There's one subtlety here: we only add in state <code>n</code>'s votes
if those votes put the total count over 270, but maybe
state <code>n</code> has 55 votes and the total is currently 269.
Adding in state <code>n</code> puts the total over 270, but there
must be smaller states already in the 269, so it's not a
minimal set.  To avoid such a situation, simply consider
each state in size order, from most votes to least. 
Then when we're adding a state, the sets being considered
can only contain bigger states, so the code above does
compute the desired answer.
</p>

<p class=pp>
For concreteness, there is a complete C program below.
It runs in about 80 microseconds on my Thinkpad X40.
That's a lot faster than waiting out essentially any O(2<sup>51</sup>)
would have been.
</p>

<p class=pp>
I think it's neat that there are two such very different
ways to think about the same computation: the abstract functional
elegance of generating functions, and the imperative directness
of dynamic programming.
People who are much more comfortable with one 
approach or the other can pick the one that suits them.
Personally, I'm one of the people Lugo supposed would say that the
&ldquo;approach via generating functions is just dynamic programming with a bunch of extra
symbols floating around for no good reason.&rdquo;**
</p>

<br>
<p class=lp>
<font size=-2>*
In fact, since the state with the most votes has 55, no minimal
winning set could have more than 324 votes, but since you can't
get 269 votes using bigger states, 324 is impossible for a
minimal set.  Thus the actual upper bound is even smaller.
In fact, if you add up the states with the most votes, you need
the first 11 to get to 271, and the state that seals the victory
has 15.  Thus it would suffice to use 284 as the upper bound
instead of 400.
This kind of digression is exactly the reason that 
400 is good enough!
</font>
</p>

<br>
<p class=lp>
<font size=-2>**
A similar correspondence is the one between
<a href="http://citeseer.ist.psu.edu/139456.html">static single analysis (SSA) form
and continuation-passing style (CPS)</a>.
It's easy to see the SSA advocates saying that CPS
is just SSA with a bunch of extra lambdas floating 
around for no good reason!
</font>
</p>

<br><br>
<pre class=smallish>
#include &lt;stdio.h&gt;

typedef long long int64;

int votes[51] = {
    55, 34, 31, 27, 21, 21, 20, 17, 15, 15,
    15, 13, 12, 11, 11, 11, 11, 10, 10, 10,
    10,  9,  9,  9,  8,  8,  7,  7,  7,  7,
     6,  6,  6,  5,  5,  5,  5,  5,  4,  4,
     4,  4,  4,  3,  3,  3,  3,  3,  3,  3,
     3,
};

int64 ways[400];

int
main(int argc, char **argv)
{
    int n, v, reps;
    int64 total;
    
    for(n=0; n&lt;400; n++)
        ways[n] = 0;

    ways[0] = 1;
    for(n=0; n&lt;51; n++)
        for(v=270+votes[n]-1; v&gt;=votes[n]; v--)
            ways[v] += ways[v-votes[n]];

    total = 0;
    for(v=270; v&lt;400; v++)
        total += ways[v];

    printf("%lld\n", total);
    return 0;
}
</pre></p>





<div class="comments">
  <div class="comments-header old">
    <p>(Comments originally posted via Blogger.)</p>
  </div>
  <div class="comments-body">
    <div id="plus-comments">
 <div class="plus-comment"><ul><li class="plus-text">
    <p><a href='http://www.blogger.com/profile/15671307315028242949'>Isabel Lugo</a> <span class="comment-when">(June 13, 2008 6:32 AM)</span> Thanks! I'm glad to see that somebody documented this. <BR/><BR/>And to be honest, your solution or something like it might be what's running under the hood of my solution; in the end I outsourced the computational work to Maple, and I don't know what it's doing.</p>
 </li></ul></div>
 <div class="plus-comment"><ul><li class="plus-text">
    <p><a href='http://www.blogger.com/profile/04805435564360543720'>Jack</a> <span class="comment-when">(June 15, 2008 2:12 PM)</span> Isn't O(2^51) = O(1)?</p>
 </li></ul></div>
 <div class="plus-comment"><ul><li class="plus-text">
    <p><a href='http://www.blogger.com/profile/03746679755202178161'>Stephan Schroevers</a> <span class="comment-when">(June 15, 2008 4:35 PM)</span> Jack, yes it is. But <I>2^51</I> relates only to the American situation, not to a general instance of the problem, in which there are <I>n</I> states, giving runtime <I>O(2^n)</I>, not <I>O(2^51) = O(1)</I>.<BR/><BR/>Note that even though a function <I>f(n)</I> may be dominated by <I>g(n)</I> from some <I>n_0</I> onward, it may be profitable to select a <I>O(g(n))</I> algorithm over a <I>O(f(n))</I> algorithm if one knows that typical inputs will have size <I>n &lt; n_0</I>.</p>
 </li></ul></div>
 <div class="plus-comment"><ul><li class="plus-text">
    <p><a href='http://www.blogger.com/profile/07860792846652677912'>S</a> <span class="comment-when">(June 16, 2008 11:23 AM)</span> The real issue is not how well Obama or McCain might do in the closely divided battleground states, but that we shouldn't have battleground states and spectator states in the first place. Every vote in every state should be politically relevant in a presidential election. And, every vote should be equal. We should have a national popular vote for President in which the White House goes to the candidate who gets the most popular votes in all 50 states. <BR/><BR/>The National Popular Vote bill would guarantee the Presidency to the candidate who receives the most popular votes in all 50 states (and DC). The bill would take effect only when enacted, in identical form, by states possessing a majority of the electoral vote -- that is, enough electoral votes to elect a President (270 of 538). When the bill comes into effect, all the electoral votes from those states would be awarded to the presidential candidate who receives the most popular votes in all 50 states (and DC). <BR/><BR/>The major shortcoming of the current system of electing the President is that presidential candidates have no reason to poll, visit, advertise, organize, campaign, or worry about the voter concerns in states where they are safely ahead or hopelessly behind. The reason for this is the winner-take-all rule which awards all of a state's electoral votes to the candidate who gets the most votes in each separate state. Because of this rule, candidates concentrate their attention on a handful of closely divided "battleground" states. Two-thirds of the visits and money are focused in just six states; 88% on 9 states, and 99% of the money goes to just 16 states. Two-thirds of the states and people are merely spectators to the presidential election.<BR/><BR/>Another shortcoming of the current system is that a candidate can win the Presidency without winning the most popular votes nationwide.<BR/><BR/>The National Popular Vote bill has been approved by 18 legislative chambers (one house in Colorado, Arkansas, Maine, North Carolina, Rhode Island, and Washington, and two houses in Maryland, Illinois, Hawaii, California, and Vermont). It has been enacted into law in Hawaii, Illinois, New Jersey, and Maryland. These states have 50 (19%) of the 270 electoral votes needed to bring this legislation into effect. <BR/><BR/>See http://www.NationalPopularVote.com</p>
 </li></ul></div>
 <div class="plus-comment me"><ul><li class="plus-text">
    <p><a href="http://swtch.com/~rsc/">Russ Cox</a> <span class="comment-when">(June 16, 2008 12:10 PM)</span> @s: Feel free to head over to the political blogs.  This blog only cares about the electoral college insofar as it leads to interesting programming problems.<BR/><BR/>I'm not saying your comment is right or wrong, just that it's out of place here.</p>
 </li></ul></div>
 <div class="plus-comment"><ul><li class="plus-text">
    <p><a href='http://www.blogger.com/profile/03975843196252061184'>Monstre</a> <span class="comment-when">(August 8, 2009 11:02 AM)</span> <span class='deleted-comment'>This post has been removed by the author.</span></p>
 </li></ul></div>
 <div class="plus-comment"><ul><li class="plus-text">
    <p><a href='http://www.blogger.com/profile/03975843196252061184'>Monstre</a> <span class="comment-when">(August 8, 2009 11:04 AM)</span> nice one !!never thought it was so easy ..<br /><br />check out mine ..and comment if u are interested .. www.spyfree.info</p>
 </li></ul></div>
 <div class="plus-comment"><ul><li class="plus-text">
    <p><a href='http://www.blogger.com/profile/15331041685611149300'>Fiddler</a> <span class="comment-when">(March 26, 2011 4:07 PM)</span> Minor typo:<br /><br />ways[n][v] = ways[n-1][total];<br /><br />should be<br /><br />ways[n][v] = ways[n-1][v];</p>
 </li></ul></div>
    </div>
  </div>
</div>


      </div>
      
      
    </div>

    
<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
var pageTracker = _gat._getTracker("UA-3319603-2");
pageTracker._initData();
pageTracker._trackPageview();
</script>

    
    
  </body>
</html>
















