<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <title>research!rsc: Go Data Structures: Interfaces</title>
    <link rel="alternate" type="application/atom+xml" title="research!rsc - Atom" href="http://research.swtch.com/feed.atom" />
    
<meta name="viewport" content="width=device-width, initial-scale=1">
<link href='https://fonts.googleapis.com/css?family=Inconsolata:400,700' rel='stylesheet' type='text/css'>
<script type="text/javascript" src="https://use.typekit.com/skm6yij.js"></script>
<script type="text/javascript">try{Typekit.load();}catch(e){}</script>
<style>
  body {
    padding: 0;
    margin: 0;
    font-size: 100%;
    font-family: 'Minion Pro';
  }
  @media print {
    img {page-break-inside: avoid;}
    div.nosplit {page-break-inside: avoid;}
  }
  img.center {
    display: block;
    margin: 0 auto;
  }
  .pad {
    padding-top: 1em;
    padding-bottom: 1em;
  }
  a.anchor, a.back, a.footnote {
    color: black !important;
    text-decoration: none !important;
  }
  a.back {
    font-size: 50%;
  }
  @media print {
    a.back {display: none;}
  }
  .header {
    height: 1.25em;
    background-color: #dff;
    margin: 0;
    padding: 0.1em 0.1em 0.2em;
    border-top: 1px solid black;
    border-bottom: 1px solid #8ff;
  }
  .header h3 {
    margin: 0;
    padding: 0 2em;
    display: inline-block;
    padding-right: 2em;
    font-style: italic;
    font-size: 90%;
  }
  .rss {
    float: right;
    padding-top: 0.2em;
    padding-right: 2em;
    display: none;
  }
  .toc {
    margin-top: 2em;
  }
  .toc-title {
    font-family: "caflisch-script-pro";
    font-size: 300%;
    line-height: 50%;
  }
  .toc-subtitle {
    display: block;
    margin-bottom: 1em;
    font-size: 83%;
  }
  @media only screen and (max-width: 550px) { .toc-subtitle { display: none; } }
  .header h3 a {
    color: black;
  }
  .header h4 {
    margin: 0;
    padding: 0;
    display: inline-block;
    font-weight: normal;
    font-size: 83%;
  }
  @media only screen and (max-width: 550px) { .header h4 { display: none; } }
  .main {
    padding: 0 2em;
  }
  @media only screen and (max-width: 479px) { .article { font-size: 120%; } }
  .article h1 {
    text-align: center;
    font-size: 200%;
  }
  .copyright {
    font-size: 83%;
  }
  .subtitle {
      font-size: 65%;
  }
  .normal {
    font-size: medium;
    font-weight: normal;
  }
  .when {
    text-align: center;
    font-size: 100%;
    margin: 0;
    padding: 0;
  }
  .when p {
    margin: 0;
    padding: 0;
  }
  .article h2 {
    font-size: 125%;
    padding-top: 0.25em;
  }
  .article h3 {
    font-size: 100%;
  }
  pre {
    margin-left: 4em;
    margin-right: 4em;
  }
  pre, code {
    font-family: 'Inconsolata', monospace;
    font-size: 100%;
  }
  .footer {
    margin-top: 10px;
    font-size: 83%;
    font-family: sans-serif;
  }
  .comments {
    margin-top: 2em;
    background-color: #ffe;
    border-top: 1px solid #aa4;
    border-left: 1px solid #aa4;
    border-right: 1px solid #aa4;
  }
  .comments-header {
    padding: 0 5px 0 5px;
  }
  .comments-header p {
    padding: 0;
    margin: 3px 0 0 0;
  }
  .comments-body {
    padding: 5px 5px 5px 5px;
  }
  #plus-comments {
    border-bottom: 1px dotted #ccc;
  }
  .plus-comment {
    width: 100%;
    font-size: 14px;
    border-top: 1px dotted #ccc;
  }
  .me {
    background-color: #eec;
  }
  .plus-comment ul {
    margin: 0;
    padding: 0;
    list-style: none;
    width: 100%;
    display: inline-block;
  }
  .comment-when {
    color:#999;
    width:auto;
    padding:0 5px;
  }
  .old {
    font-size: 83%;
  }
  .plus-comment ul li {
    display: inline-block;
    vertical-align: top;
    margin-top: 5px;
    margin-bottom: 5px;
    padding: 0;
  }
  .plus-icon {
    width: 45px;
  }
  .plus-img {
    float: left;
    margin: 4px 4px 4px 4px;
    width: 32px;
    height: 32px;
  }
  .plus-comment p {
    margin: 0;
    padding: 0;
  }
  .plus-clear {
    clear: left;
  }
  .toc-when {
    font-size: 83%;
    color: #999;
  }
  .toc {
    list-style: none;
  }
  .toc li {
    margin-bottom: 0.5em;
  }
  .toc-head {
    margin-bottom: 1em !important;
    font-size: 117%;
  }
  .toc-summary {
    margin-left: 2em;
  }
  .favorite {
    font-weight: bold;
  }
  .article p, .article ol {
    line-height: 144%;
  }
  sup, sub {
    vertical-align: baseline;
    position: relative;
    font-size: 83%;
  }
  sup {
    bottom: 1ex;
  }
  sub {
    top: 0.8ex;
  }

  .main {
    position: relative;
    margin: 0 auto;
    padding: 0;
    width: 900px;
  }
  @media only screen and (min-width: 768px) and (max-width: 959px) { .main { width: 708px; } }
  @media only screen and (min-width: 640px) and (max-width: 767px) { .main { width: 580px; } }
  @media only screen and (min-width: 480px) and (max-width: 639px) { .main { width: 420px; } }
  @media only screen and (max-width: 479px) { .main { width: 300px; } }

</style>

  </head>
  <body>
    
<div class="header">
  <h3><a href="/">research!rsc</a></h3>
  <h4>Thoughts and links about programming,
    by <a href="https://swtch.com/~rsc/" rel="author">Russ Cox</a> </h4>
  <a class="rss" href="/feed.atom"><img src="/feed-icon-14x14.png" /></a>
</div>

    <div class="main">
      <div class="article">
        <h1>Go Data Structures: Interfaces
        
        <div class="normal">
        <div class="when">
          
            Posted on Tuesday, December 1, 2009.
            
          
        </div>
        </div>
        </h1>
        
<p><p class=lp>Go's interfaces&#8212;static, checked at compile time, dynamic when asked for&#8212;are,
for me, the most exciting part of Go from a language design point of view.
If I could export one feature of Go into other languages, it would be interfaces.
</p>

<p class=pp>
This post is my take on the implementation of interface values in the
&ldquo;gc&rdquo; compilers: 6g, 8g, and 5g.
Over at Airs, Ian Lance Taylor has written
<a href="http://www.airs.com/blog/archives/277">two</a>
<a href="http://www.airs.com/blog/archives/276">posts</a> about
the implementation of interface values in <code>gccgo</code>.
The implementations are more alike than different:
the biggest difference is that this post has pictures.
</p>

<p class=pp>Before looking at the implementation, let's get a sense of
what it must support.</p>

<h3>Usage</h3>

<p class=lp>Go's interfaces let you use
<a href="http://en.wikipedia.org/wiki/Duck_typing">duck typing</a> like you would
in a purely dynamic language like Python but still have the
compiler catch obvious mistakes like passing an <code>int</code> where an object
with a <code>Read</code> method was expected, or
like calling the <code>Read</code> method with the wrong number of arguments.
To use interfaces, first define the interface type (say, <code>ReadCloser</code>):
</p>

<pre class=indent>
type ReadCloser interface {
    Read(b []byte) (n int, err os.Error)
    Close()
}
</pre>

<p class=lp>and then define your new function as taking a <code>ReadCloser</code>.
For example, this function calls <code>Read</code> repeatedly to get all the
data that was requested and then calls <code>Close</code>:</p>

<pre class=indent>
func ReadAndClose(r ReadCloser, buf []byte) (n int, err os.Error) {
    for len(buf) &gt; 0 && err == nil {
        var nr int
        nr, err = r.Read(buf)
        n += nr
        buf = buf[nr:]
    }
    r.Close()
    return
}
</pre>

<p class=lp>The code that calls <code>ReadAndClose</code> can pass
a value of any type as long as it has <code>Read</code> and <code>Close</code> methods
with the right signatures.
And, unlike in languages like Python, if you pass a value with the
wrong type, you get an error at compile time, not run time.
</p>

<p class=pp>Interfaces aren't restricted to static checking, though.
You can check dynamically whether a particular interface value
has an additional method.
For example:
</p>

<pre class=indent>
type Stringer interface {
    String() string
}

func ToString(any interface{}) string {
    if v, ok := any.(Stringer); ok {
        return v.String()
    }
    switch v := any.(type) {
    case int:
        return strconv.Itoa(v)
    case float:
        return strconv.Ftoa(v, 'g', -1)
    }
    return "???"
}
</pre>

<p class=lp>The value <code>any</code> has static type
<code>interface{}</code>, meaning no guarantee of any methods at all:
it could contain any type.
The &ldquo;comma ok&rdquo; assignment inside the <code>if</code>
statement asks whether it is possible to convert <code>any</code> to
an interface value of type <code>Stringer</code>, which has the
method <code>String</code>.  If so, the body of that statement
calls the method to obtain a string to return.
Otherwise, the <code>switch</code> picks off a few basic types before
giving up.
This is basically a stripped down version of what the
<a href="http://golang.org/pkg/fmt/">fmt package</a> does.
(The <code>if</code> could be replaced by adding 
<code>case Stringer:</code> at the top of the <code>switch</code>,
but I used a separate statement to draw attention to the check.)
</p>

<p class=pp>
As a simple example, let's consider a 64-bit integer type
with a <code>String</code> method that prints the value
in binary and a trivial <code>Get</code> method:
</p>

<pre class=indent>
type Binary uint64

func (i Binary) String() string {
    return strconv.Uitob64(i.Get(), 2)
}

func (i Binary) Get() uint64 {
    return uint64(i)
}
</pre>
<p class=lp>A value of type <code>Binary</code> can be passed
to <code>ToString</code>, which will format it using the <code>String</code>
method, even though the program never says that
<code>Binary</code> intends to implement <code>Stringer</code>.
There's no need: the runtime can see that <code>Binary</code>
has a <code>String</code> method, so it implements <code>Stringer</code>,
even if the author of <code>Binary</code> has never heard of
<code>Stringer</code>.
</p>

<p class=pp>These examples show that even though all the
implicit conversions are checked at compile time, explicit interface-to-interface
conversions can inquire about method sets at run time.
&ldquo;<a href="http://golang.org/doc/effective_go.html#interfaces">Effective Go</a>&rdquo;
has more details about and examples of how interface values can be used.
</p>

<h3>Interface Values</h3>

<p class=lp>Languages with methods typically fall into one of
two camps: prepare tables for all the method calls statically
(as in C++ and Java), or do a method lookup at each call
(as in Smalltalk and its many imitators, JavaScript and Python included)
and add fancy caching to make that call efficient.
Go sits halfway between the two: it has method tables
but computes them at run time. 
I don't know whether Go is the first language to use this technique,
but it's certainly not a common one.
(I'd be interested to hear about earlier examples; leave a comment below.)
</p>

<p class=pp>
As a warmup, a value of type <code>Binary</code> is just a 64-bit integer
made up of two 32-bit words (like in the <a href="http://research.swtch.com/2009/11/go-data-structures.html">last post</a>, we'll assume a 32-bit machine; this time memory
grows down instead of to the right):
</p>

<center>
<img src="http://research.swtch.com/gointer1.png">
</center>

<p class=pp>Interface values are represented as a two-word pair giving
a pointer to information about the type stored in the interface
and a pointer to the associated data.
Assigning <code>b</code> to an interface value of type <code>Stringer</code>
sets both words of the interface value.
</p>

<center>
<img src="http://research.swtch.com/gointer2.png">
</center>

<p class=lp>
(The pointers contained in the interface value are gray
to emphasize that they are implicit,
not directly exposed to Go programs.)
</p>

<p class=pp>The first word in the interface value points at
what I call an interface table or itable (pronounced i-table; in the <a href="http://golang.org/src/pkg/runtime/iface.c#L23">runtime sources</a>,
the C implementation name is <code>Itab</code>).
The itable begins with some metadata about the types
involved and then becomes a list of function pointers.
Note that the itable corresponds to the <i>interface type</i>,
not the dynamic type.  In terms of our example, the itable
for <code>Stringer</code> holding type <code>Binary</code>
lists the methods used to satisfy <code>Stringer</code>,
which is just <code>String</code>: <code>Binary</code>'s 
other methods (<code>Get</code>) make no appearance
in the itable.
</p>

<p class=pp>The second word in the interface value points
at the actual data, in this case a copy of <code>b</code>.
The assignment <code>var s Stringer = b</code> makes
a copy of <code>b</code> rather than point at <code>b</code>
for the same reason that <code>var c uint64 = b</code>
makes a copy: if <code>b</code> later changes,
<code>s</code> and <code>c</code> are supposed
to have the original value, not the new one.
Values stored in interfaces might be arbitrarily large,
but only one word is dedicated to holding the value
in the interface structure, so the assignment allocates a
chunk of memory
on the heap and records the pointer in the one-word slot.
(There's an obvious optimization when the value does fit
in the slot; we'll get to that later.)
</p>

<p class=pp>To check whether an interface value holds a 
particular type, as in the <a href="">type switch</a> above,
the Go compiler generates code equivalent to the
C expression <code>s.tab-&gt;type</code> to obtain
the type pointer and check it against the desired type.
If the types match, the value can be copied by by
dereferencing <code>s.data</code>.</p>

<p class=pp>To call <code>s.String()</code>, the Go compiler generates
code that does the equivalent of the C expression
<code>s.tab-&gt;fun[0](s.data)</code>: it calls the appropriate
function pointer from the itable, passing the interface value's
data word as the function's first (in this example, only) argument.
You can see this code if you run <code>8g -S x.go</code> (details at the bottom of this post).
Note that the function in the itable is being passed the
32-bit pointer from the second word of the interface value, not the 64-bit 
value it points at.
In general, the interface call site doesn't know the
meaning of this word nor how much data it points at.
Instead, the interface code arranges that the function
pointers in the itable expect the 32-bit representation
stored in the interface values.
Thus the function pointer in this example is <code>(*Binary).String</code>
not <code>Binary.String</code>.
</p>

<p class=pp>The example we're considering is an interface
with just one method.  An interface with more methods would
have more entries in the <i>fun</i> list at the bottom
of the itable.
</p>

<h3>Computing the Itable</h3>

<p class=lp>Now we know what the itables look like, but where
do they come from?  Go's dynamic type conversions mean that
it isn't reasonable for the compiler or linker to precompute all
possible itables: there are too many (interface type, concrete type) pairs,
and most won't be needed.
Instead, the compiler generates a type description structure for each
concrete type like <code>Binary</code> or <code>int</code> or <code>func(map[int]string)</code>.
Among other metadata, the type description structure contains a list
of the methods implemented by that type.
Similarly, the compiler generates a (different) type description structure
for each interface type like <code>Stringer</code>; it too contains a 
method list.
The interface runtime computes the itable by looking for each method listed
in the interface type's method table in
the concrete type's method table.
The runtime caches the itable after generating it,
so that this correspondence need only be computed once.
</p>

<p class=pp>In our simple example, the method table for
<code>Stringer</code> has one method, while the table for
<code>Binary</code> has two methods.
In general there might be <i>ni</i> methods 
for the interface type and <i>nt</i> methods for the concrete type.
The obvious search to find the mapping from interface
methods to concrete methods would take <i>O</i>(<i>ni</i> &#215; <i>nt</i>) time,
but we can do better.
By sorting the two method tables and walking them 
simultaneously, we can <a href="http://code.google.com/p/go/source/browse/src/pkg/runtime/iface.c#98">build the mapping</a> in <i>O</i>(<i>ni</i> + <i>nt</i>) time instead.
</p>

<h3>Memory Optimizations</h3>

<p class=lp>The space used by the 
implementation described above can be optimized in two complementary ways.
</p>

<p class=pp>First, if the interface type involved is empty&#8212;it has no methods&#8212;then
the itable serves no purpose except to hold the pointer to the
original type.  In this case, the itable can be dropped and
the value can point at the type directly:
</p>

<center>
<img src="http://research.swtch.com/gointer3.png">
</center>

<p class=lp>Whether an interface type has methods
is a static property&#8212;either the type in the source code says
<code>interface{}</code> or it says <code>interace{ methods... }</code>&#8212;so
the compiler knows which representation is in use at each point
in the program.</p>

<p class=pp>Second, if the value associated with the interface value
can fit in a single machine word, there's no need to introduce
the indirection or the heap allocation.  If we define
<code>Binary32</code> to be like <code>Binary</code>
but implemented as a <code>uint32</code>,
it could be stored in an interface value
by keeping the actual value in the second word:
</p>

<center>
<img src="http://research.swtch.com/gointer4.png">
</center>

<p class=lp>Whether the actual value is being pointed at or
inlined depends on the size of the type.  The compiler
arranges for the functions listed in the type's method table
(which get copied into the itables) to do the right thing with
the word that gets passed in.  If the receiver type fits in a word,
it is used directly; if not, it is dereferenced.
The diagrams show this: in the <code>Binary</code> version
far above, the method in the itable is
<code>(*Binary).String</code>, while in the 
<code>Binary32</code> example, the method
in the itable is <code>Binary32.String</code> 
not <code>(*Binary32).String</code>.
</p>

<p class=pp>Of course, empty interfaces holding word-sized (or smaller) values
can take advantage of both optimizations:
</p>

<center>
<img src="http://research.swtch.com/gointer5.png">
</center>

<h3>Method Lookup Performance</h3>

<p class=lp>Smalltalk and the many dynamic systems that have followed it
perform a method lookup every time a method gets called.
For speed, many implementations use a simple one-entry cache
at each call site, often in the instruction stream itself.
In a multithreaded program, these caches must be managed
carefully, since multiple threads could be at the same call
site simultaneously.  Even once the races have
been avoided, the caches would end up being a source of
memory contention.
</p>

<p class=pp>Because Go has the hint of static typing to go
along with the dynamic method lookups, it can move the lookups
back from the call sites to the point when the value is stored
in the interface.  For example, consider this code snippet:</p>

<pre class=indent>
1   var any interface{}  // initialized elsewhere
2   s := any.(Stringer)  // dynamic conversion
3   for i := 0; i &lt; 100; i++ {
4       fmt.Println(s.String())
5   }
</pre>

<p class=lp>In Go, the itable gets computed (or found in a cache)
during the assignment on line 2; the dispatch for the
<code>s.String()</code> call executed on line 4 is a
couple of memory fetches and a single indirect call
instruction.
</p>

<p class=pp>In contrast, the implementation of this program in a dynamic
language like Smalltalk (or JavaScript, or Python, or ...) would
do the method lookup at line 4, which in a loop repeats needless work.
The cache mentioned earlier makes this less expensive than it
might be, but it's still more expensive than a single indirect call
instruction.
</p>

<p class=pp>Of course, this being a blog post, I don't have any
numbers to back up this discussion, but it certainly seems like the
lack of memory contention would be a big win in a 
heavily parallel program, as is being able to move the method
lookup out of tight loops.  Also, I'm talking about the general
architecture, not the specifics o the implementation: the latter
probably has a few constant factor optimizations still
available.
</p>

<h3>More Information</h3>

<p class=lp>The interface runtime support is in
<code><a href="http://code.google.com/p/go/source/browse/src/pkg/runtime/iface.c">$GOROOT/src/pkg/runtime/iface.c</a></code>.
There's much more to say about interfaces (we haven't
even seen an example of a pointer receiver yet) and the
type descriptors (they power reflection in addition
to the interface runtime) but those will have to wait for future posts.
</p>

<h3>Code</h3>

<p class=lp>Supporting code (<code>x.go</code>):</p>

<pre class=indent>
package main

import (
 "fmt"
 "strconv"
)

type Stringer interface {
 String() string
}

type Binary uint64

func (i Binary) String() string {
 return strconv.Uitob64(i.Get(), 2)
}

func (i Binary) Get() uint64 {
 return uint64(i)
}

func main() {
 b := Binary(200)
 s := Stringer(b)
 fmt.Println(s.String())
}
</pre>

<p class=lp>Selected output of <code>8g -S x.go</code>:</p>

<pre class=indent>
0045 (x.go:25) LEAL    s+-24(SP),BX
0046 (x.go:25) MOVL    4(BX),BP
0047 (x.go:25) MOVL    BP,(SP)
0048 (x.go:25) MOVL    (BX),BX
0049 (x.go:25) MOVL    20(BX),BX
0050 (x.go:25) CALL    ,BX
</pre>

<p class=lp>The <code>LEAL</code> loads the address of <code>s</code>
into the register <code>BX</code>.
(The notation <code><i>n</i>(SP)</code> describes the
word in memory at <code>SP+<i>n</i></code>.  <code>0(SP)</code>
can be shortened to <code>(SP)</code>.)
The next two <code>MOVL</code> instructions fetch the
value from the second word in the interface and store
it as the first function call argument, <code>0(SP)</code>.
The final two <code>MOVL</code> instructions fetch
the itable and then the function pointer from the itable,
in preparation for calling that function.
</p></p>





<div class="comments">
  <div class="comments-header old">
    <p>(Comments originally posted via Blogger.)</p>
  </div>
  <div class="comments-body">
    <div id="plus-comments">
 <div class="plus-comment"><ul><li class="plus-text">
    <p><a href='http://www.blogger.com/profile/00839344798030831980'>rog peppe</a> <span class="comment-when">(December 2, 2009 2:42 AM)</span> <i>Go&#39;s interfaces let you use duck typing like you would in a purely dynamic language like Python</i><br /><br />this has been said a lot, but i don&#39;t think it&#39;s quite true. duck typing goes deeper. for instance, if i&#39;ve got an API for doing arithmetic:<br /><br /><b><br />type Foo struct { ... };<br /><br />func (f0 *Foo)Add(f1 *Foo) *Foo;<br />func (f0 *Foo)Negate() *Foo;<br /></b><br />etc<br /><br />with duck typing, this is compatible with any other type that responds to the same methods, <i>including methods on objects that its methods return</i>. if interfaces were really like duck typing, then the above struct would be compatible with this interface:<br /><br /><b><br />type Arith interface {<br />&#160;&#160;&#160;&#160;Add(f1 Arith) Arith;<br />&#160;&#160;&#160;&#160;Negate() Arith;<br />}<br /></b><br /><br />but it&#39;s not.</p>
 </li></ul></div>
 <div class="plus-comment"><ul><li class="plus-text">
    <p><a href='http://www.blogger.com/profile/08057528812732998703'>Fred Blasdel</a> <span class="comment-when">(December 2, 2009 3:26 AM)</span> It&#39;s kind of worse than that rog: the Go language doesn&#39;t itself use the polymorphism mechanism it provides to its users (Interfaces), and the ones it does use (the parametricity of Array and Map) are for its use only.<br /><br />They&#39;re understandably afraid of overloading, and classicist counter-revolutionaries could perturb the public development of the language (see Prototype.js for a particularly ironic and depressing example). They have to be careful about what they add.<br /><br /><br /><i>I don&#39;t know whether Go is the first language to use this technique, but it&#39;s certainly not a common one.</i><br /><br />I&#39;m sure this is discussed in Cardelli and Abadi&#39;s &quot;A Theory of Objects&quot;, but I don&#39;t have a copy of my own. I&#39;d bet Rob has one you could borrow :)</p>
 </li></ul></div>
 <div class="plus-comment"><ul><li class="plus-text">
    <p><a href='http://www.blogger.com/profile/01810792034258816216'>Kalani</a> <span class="comment-when">(December 2, 2009 6:41 AM)</span> Fred, I don&#39;t know why there should be any fear of overloading here (though you&#39;ve put your finger on some major problems with this language).  Especially with the poor String/toString example, somebody should have immediately seen a need to introduce overloading.  Hopefully there&#39;s a better justification for accepting the unnecessary time/space overhead (and more importantly the logical/reasoning overhead) that goes along with runtime type-tag checking.<br /><br />It&#39;s a shame -- the authors of Go should have read Mark Jones&#39;s dissertation on qualified types.  Without polymorphic recursion, they could statically construct all necessary &quot;interfaces&quot; for primitive types and have a much nicer &#39;toString&#39; function (not to mention a million other examples).<br /><br />These guys missed a great chance to seriously advance the state of &quot;system programming.&quot;</p>
 </li></ul></div>
 <div class="plus-comment"><ul><li class="plus-text">
    <p><a href='http://www.blogger.com/profile/02694440592772191857'>Evan Jones</a> <span class="comment-when">(December 10, 2009 4:31 PM)</span> Re: Method lookup performance. It seems to me that the example shown for Method lookup performance is not quite &quot;fair.&quot; The issue, I think, for Javascript and Python, is that the call to s.String() could call a different method on each loop iteration, if the code changes the type or the instance.<br /><br />Go is a bit more static, and I don&#39;t think this is possible. If Python/Javascript forbid changing methods on an object, then the method lookup could be recognized by an optimizer as being constant, and hoisted out of the loop.<br /><br />But I haven&#39;t thought about this too hard, so I could be wrong.</p>
 </li></ul></div>
 <div class="plus-comment"><ul><li class="plus-text">
    <p><a href='http://www.blogger.com/profile/13912039839233620950'>Tom</a> <span class="comment-when">(July 18, 2010 8:57 AM)</span> <i>I don&#39;t know whether Go is the first language to use this technique, but it&#39;s certainly not a common one.</i><br /><br />Haskell TypeClasses are implemented using a similar technique - each type (or set of types) implementing a typeclass is associated with a method table (called a <b>dictionary</b>) that is passed to functions requiring values of said typeclass.</p>
 </li></ul></div>
 <div class="plus-comment"><ul><li class="plus-text">
    <p><a href='http://www.blogger.com/profile/06702358341689436900'>Squire</a> <span class="comment-when">(October 14, 2010 9:45 AM)</span> <i><br />I don&#39;t know whether Go is the first language to use this technique, but it&#39;s certainly not a common one.<br /></i><br /><br />Emerald computed lookup tables dynamically; we called them &quot;AbCon vectors&quot;, because they converted from the abstract type (aka interface), known at compile time, to the concrete type of the object (aka class), which was sometimes know only at runtime.  We also cached the AbCons.<br /><br />Emerald also did typechecking more or less as you have described it in Go, with interfaces being structural (programmers didn&#39;t have to <i>claim</i> that they implemented an interface, they just had to do it), checking being static when possible but otherwise dynamic, and allowing run-time type interrogation and checked run-time conversions.  Emerald also had methods with multiple return values and &quot;comma assignments&quot;.<br /><br />Are you sure that you didn&#39;t peek?</p>
 </li></ul></div>
 <div class="plus-comment me"><ul><li class="plus-text">
    <p><a href="http://swtch.com/~rsc/">Russ Cox</a> <span class="comment-when">(October 14, 2010 7:46 PM)</span> @Squire:<br /><br />Wow.  <br /><br />I&#39;m about halfway through the 2007 retrospective paper about Emerald and my blog post pictures might as well have been lifted from Figure 3.<br /><br />I&#39;m sure we didn&#39;t peek, but I think it&#39;s interesting how similar the backgrounds of the team members are.  In the case of Go, Rob brought the concurrency ideas via Hoare&#39;s CSP, Robert brought the object sensibilities of a Smalltalk programmer, and Ken brought the focus on C-quality performance that led to essentially the same data structures Emerald used 25 years ago.  That characterization obviously oversimplifies, but you can see the same backgrounds coming together in the paper&#39;s description of the original Emerald team.<br /><br />It&#39;s very cool to see not only that other people explored this space years ago but also that they arrived at essentially the same design.  The fact that this design point has been discovered multiple times by independent groups makes it seem somehow more fundamental.<br /><br />Thanks so much for pointing this out.  Finding out about these kinds of connections is such a thrill.</p>
 </li></ul></div>
 <div class="plus-comment"><ul><li class="plus-text">
    <p><a href='http://www.blogger.com/profile/05828569029365447689'>Drew LeSueur</a> <span class="comment-when">(December 5, 2010 2:42 AM)</span> Thanks so much for the tutorial. Your code at the end really helped me understand some Go basics</p>
 </li></ul></div>
 <div class="plus-comment"><ul><li class="plus-text">
    <p>Anonymous <span class="comment-when">(June 5, 2011 7:43 PM)</span> &quot;It&#39;s very cool &quot; -- It&#39;s not cool at all; it indicates insufficient search of the literature, which one can see throughout the design of Go. Experienced language designers look at Go and just shake their heads. But it&#39;s Rob Pike and Ken Thompson! Yes, exactly -- a couple of clever strongly opinionated eccentrics, whose idiosyncratic ideas, not deep knowledge of language design, drive the design of Go. We can see the same thing in Perl and in Java -- idiosyncrasies in opposite directions. And then there&#39;s D, which is a trainwreck because its author treats it like a personal project. Google could have hired Walter Bright and turned D into the far better alternative to C++ that it had the potential to be in the beginning -- although they could have done better yet by hiring someone like Martin Odersky.</p>
 </li></ul></div>
 <div class="plus-comment"><ul><li class="plus-text">
    <p><a href='http://www.blogger.com/profile/17344213294371886790'>jam</a> <span class="comment-when">(July 31, 2011 7:33 AM)</span> One trick I noticed was missing was:<br /> stringer = s.String <br /> for i ...<br />   print stringer()<br /><br />Namely being able to pull out the attribute lookup outside the loop. I use that a lot, especially for comprehensions.<br /><br />For go, it could still be helpful to avoid the extra indirections. But go doesn&#39;t seem to allow for bound functions and using:<br /> F = func() string { return s.String() }<br /><br />Actually makes things a lot worse.</p>
 </li></ul></div>
 <div class="plus-comment"><ul><li class="plus-text">
    <p><a href='http://www.luizpaschoal.com.br'>Consultoria RH</a> <span class="comment-when">(December 11, 2011 9:56 AM)</span> Este blog é uma representação exata de competências. Eu gosto da sua recomendação. Um grande conceito que reflete os pensamentos do escritor. <a href="http://www.luizpaschoal.com.br" rel="nofollow">Consultoria RH</a></p>
 </li></ul></div>
    </div>
  </div>
</div>


      </div>
      
      
    </div>

    
<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
var pageTracker = _gat._getTracker("UA-3319603-2");
pageTracker._initData();
pageTracker._trackPageview();
</script>

    
    
  </body>
</html>
















