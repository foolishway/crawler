<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <title>research!rsc: Floating Point to Decimal Conversion is Easy</title>
    <link rel="alternate" type="application/atom+xml" title="research!rsc - Atom" href="http://research.swtch.com/feed.atom" />
    
<meta name="viewport" content="width=device-width, initial-scale=1">
<link href='https://fonts.googleapis.com/css?family=Inconsolata:400,700' rel='stylesheet' type='text/css'>
<script type="text/javascript" src="https://use.typekit.com/skm6yij.js"></script>
<script type="text/javascript">try{Typekit.load();}catch(e){}</script>
<style>
  body {
    padding: 0;
    margin: 0;
    font-size: 100%;
    font-family: 'Minion Pro';
  }
  @media print {
    img {page-break-inside: avoid;}
    div.nosplit {page-break-inside: avoid;}
  }
  img.center {
    display: block;
    margin: 0 auto;
  }
  .pad {
    padding-top: 1em;
    padding-bottom: 1em;
  }
  a.anchor, a.back, a.footnote {
    color: black !important;
    text-decoration: none !important;
  }
  a.back {
    font-size: 50%;
  }
  @media print {
    a.back {display: none;}
  }
  .header {
    height: 1.25em;
    background-color: #dff;
    margin: 0;
    padding: 0.1em 0.1em 0.2em;
    border-top: 1px solid black;
    border-bottom: 1px solid #8ff;
  }
  .header h3 {
    margin: 0;
    padding: 0 2em;
    display: inline-block;
    padding-right: 2em;
    font-style: italic;
    font-size: 90%;
  }
  .rss {
    float: right;
    padding-top: 0.2em;
    padding-right: 2em;
    display: none;
  }
  .toc {
    margin-top: 2em;
  }
  .toc-title {
    font-family: "caflisch-script-pro";
    font-size: 300%;
    line-height: 50%;
  }
  .toc-subtitle {
    display: block;
    margin-bottom: 1em;
    font-size: 83%;
  }
  @media only screen and (max-width: 550px) { .toc-subtitle { display: none; } }
  .header h3 a {
    color: black;
  }
  .header h4 {
    margin: 0;
    padding: 0;
    display: inline-block;
    font-weight: normal;
    font-size: 83%;
  }
  @media only screen and (max-width: 550px) { .header h4 { display: none; } }
  .main {
    padding: 0 2em;
  }
  @media only screen and (max-width: 479px) { .article { font-size: 120%; } }
  .article h1 {
    text-align: center;
    font-size: 200%;
  }
  .copyright {
    font-size: 83%;
  }
  .subtitle {
      font-size: 65%;
  }
  .normal {
    font-size: medium;
    font-weight: normal;
  }
  .when {
    text-align: center;
    font-size: 100%;
    margin: 0;
    padding: 0;
  }
  .when p {
    margin: 0;
    padding: 0;
  }
  .article h2 {
    font-size: 125%;
    padding-top: 0.25em;
  }
  .article h3 {
    font-size: 100%;
  }
  pre {
    margin-left: 4em;
    margin-right: 4em;
  }
  pre, code {
    font-family: 'Inconsolata', monospace;
    font-size: 100%;
  }
  .footer {
    margin-top: 10px;
    font-size: 83%;
    font-family: sans-serif;
  }
  .comments {
    margin-top: 2em;
    background-color: #ffe;
    border-top: 1px solid #aa4;
    border-left: 1px solid #aa4;
    border-right: 1px solid #aa4;
  }
  .comments-header {
    padding: 0 5px 0 5px;
  }
  .comments-header p {
    padding: 0;
    margin: 3px 0 0 0;
  }
  .comments-body {
    padding: 5px 5px 5px 5px;
  }
  #plus-comments {
    border-bottom: 1px dotted #ccc;
  }
  .plus-comment {
    width: 100%;
    font-size: 14px;
    border-top: 1px dotted #ccc;
  }
  .me {
    background-color: #eec;
  }
  .plus-comment ul {
    margin: 0;
    padding: 0;
    list-style: none;
    width: 100%;
    display: inline-block;
  }
  .comment-when {
    color:#999;
    width:auto;
    padding:0 5px;
  }
  .old {
    font-size: 83%;
  }
  .plus-comment ul li {
    display: inline-block;
    vertical-align: top;
    margin-top: 5px;
    margin-bottom: 5px;
    padding: 0;
  }
  .plus-icon {
    width: 45px;
  }
  .plus-img {
    float: left;
    margin: 4px 4px 4px 4px;
    width: 32px;
    height: 32px;
  }
  .plus-comment p {
    margin: 0;
    padding: 0;
  }
  .plus-clear {
    clear: left;
  }
  .toc-when {
    font-size: 83%;
    color: #999;
  }
  .toc {
    list-style: none;
  }
  .toc li {
    margin-bottom: 0.5em;
  }
  .toc-head {
    margin-bottom: 1em !important;
    font-size: 117%;
  }
  .toc-summary {
    margin-left: 2em;
  }
  .favorite {
    font-weight: bold;
  }
  .article p, .article ol {
    line-height: 144%;
  }
  sup, sub {
    vertical-align: baseline;
    position: relative;
    font-size: 83%;
  }
  sup {
    bottom: 1ex;
  }
  sub {
    top: 0.8ex;
  }

  .main {
    position: relative;
    margin: 0 auto;
    padding: 0;
    width: 900px;
  }
  @media only screen and (min-width: 768px) and (max-width: 959px) { .main { width: 708px; } }
  @media only screen and (min-width: 640px) and (max-width: 767px) { .main { width: 580px; } }
  @media only screen and (min-width: 480px) and (max-width: 639px) { .main { width: 420px; } }
  @media only screen and (max-width: 479px) { .main { width: 300px; } }

</style>

  </head>
  <body>
    
<div class="header">
  <h3><a href="/">research!rsc</a></h3>
  <h4>Thoughts and links about programming,
    by <a href="https://swtch.com/~rsc/" rel="author">Russ Cox</a> </h4>
  <a class="rss" href="/feed.atom"><img src="/feed-icon-14x14.png" /></a>
</div>

    <div class="main">
      <div class="article">
        <h1>Floating Point to Decimal Conversion is Easy
        
        <div class="normal">
        <div class="when">
          
            Posted on Friday, July 1, 2011.
            
          
        </div>
        </div>
        </h1>
        
<p class=pp>
Floating point to decimal conversions have a reputation for being difficult. At heart, they're really very simple and straightforward. To prove it, I'll explain a working implementation. It only formats positive numbers, but expanding it to negative numbers, zero, infinities and NaNs would be very easy.
</p>

<p class=pp>
An IEEE 64-bit binary floating point number is an integer <i>v</i> in the range [2<sup>52</sup>, 2<sup>53</sup>) times a power of two: <i>f</i> = <i>v</i> &#215; 2<sup><i>e</i></sup>. Constraining the fractional part of the unpacked <code>float64</code> to the range [2<sup>52</sup>, 2<sup>53</sup>) makes the representation unique.  We could have used any range that spans a multiplicative factor of two, but that range is the first one in which all the values are integers.
</p>

<p class=pp>
In Go, <code>math.Frexp</code> unpacks a <code>float64</code> into <i>f</i> = <i>fr</i> &#215; 2<sup><i>exp</i></sup> where <i>fr</i> is in the range [&#189;, 1). (C's <code>frexp</code> does too.) Converting to our integer representation is easy:
</p>

<pre>
fr, exp := math.Frexp(f)
v := int64(fr * (1&lt;&lt;53))
e := exp - 53
</pre>

<p class=lp>
To convert the integer to decimal, we'll use <code>strconv.Itoa64</code> out of laziness; you know how to write the direct code.
</p>

<pre>
buf := make([]byte, 1000)
n := copy(buf, strconv.Itoa64(v))
</pre>

<p class=lp>
The allocation of <code>buf</code> reserves space for 1000 digits. In general 1/2<sup><i>e</i></sup> requires about 0.7<i>e</i> non-zero decimal digits to write in full. For a <code>float64</code>, the smallest positive number is 1/2<sup>1074</sup>, so 1000 digits is plenty. The second line sets <code>n</code> to the number of bytes copied in from the string representation of the (integer) <code>v</code>. Throughout, <code>n</code> will be the number of digits in <code>buf</code>. Note that we're working with ASCII decimal digits <code>'0'</code> to <code>'9'</code>, not bytes 0-9.
</p>

<p class=pp>
Now we've got the decimal for <i>v</i> stored in <code>buf</code>. Since <i>f</i> = <i>v</i> &#215; 2<sup><i>e</i></sup>, all that remains is to multiply or divide <code>buf</code> by 2 the appropriate number of times (<i>e</i> or <i>-e</i> times).
</p>

<p class=pp>
Here's the loop to handle positive <i>e</i>:
</p>

<pre>
for ; e &gt; 0; e-- {
    δ := 0
    if buf[0] &gt;= '5' {
        δ = 1
    }
    x := byte(0)
    for i := n-1; i &gt;= 0; i-- {
        x += 2*(buf[i] - '0')
        x, buf[i+δ] = x/10, x%10 + '0'
    }
    if δ == 1 {
        buf[0] = '1'
        n++
    }
}
dp := n
</pre>

<p class=lp>
Each iteration of the inner loop overwrites <code>buf</code> with twice <code>buf</code>. To start, the code determines whether there will be a new digit (<code>δ</code> = 1), which happens when the leading digit is at least 5. Then it runs up the number from right to left, just as you learned in grade school, multiplying each digit by two and using <code>x</code> to carry the result. The digit <code>buf[i]</code> moves into <code>buf[i+δ]</code>. At the end, if the code needs to insert an extra digit, it does. Run <code>e</code> times.
</p>

<p class=pp>
After the loop finishes, we record in <code>dp</code> the current location of the decimal point. Since <code>buf</code> is still an integer (it started as an integer and we've only doubled things), the decimal point is just past all the digits.
</p>

<p class=pp>
Of course, <code>e</code> might have started out negative, in which case we've done nothing and still need to halve  <code>buf</code> <code>e</code> times:
</p>

<pre>
for ; e &lt; 0; e++ {
    if buf[n-1]%2 != 0 {
        buf[n] = '0'
        n++
    }
    δ, x := 0, byte(0)
    if buf[0] &lt; '2' {
        δ, x = 1, buf[0] - '0'
        n--
        dp--
    }
    for i := 0; i &lt; n; i++ {
        x = x*10 + buf[i+δ] - '0'
        buf[i], x = x/2 + '0', x%2
    }
}
</pre>

<p class=lp>
Dividing by two needs an extra digit if the last digit is odd, to store the final half; in that case we add a <code>0</code> to <code>buf</code> so that we'll have room to store a completely precise answer.
</p>

<p class=pp>
After adding the <code>0</code>, we can set up for the division itself. If the first digit is less than 2, it's going to become a zero; in the interest of avoiding leading zeros we use an initial partial value <code>x</code> and move digits up (<code>δ</code> = 1) during the division. The multiplication ran from right to left copying from <code>buf[i]</code> to <code>buf[i+δ]</code>. The division runs left to right copying from <code>buf[i+δ]</code> to <code>buf[i]</code>.
</p>

<p class=pp>
Now <code>buf[0:n]</code> has all the non-zero digits in the exact decimal representation of our <code>f</code>, and <code>dp</code> records where to put the decimal point. We could stop now, but we might as well implement correct rounding while we're here.
</p>

<p class=pp>
The interesting case is when we have more digits than requested (<code>n</code> &gt; <code>ndigit</code>). To make the decision, just like in grade school, we look at the  first digit being removed.  If it's less than 5, we round down by truncating. If it's greater than 5, we round up by incrementing what's left after truncation. If it's equal to 5, we have to look at the rest of the digits being dropped. If any of the rest of the digits are nonzero, then rounding up is more accurate. Otherwise we're right on the line. In grade school I was taught to handle this case by rounding up: 0.5 rounds to 1. That's a simple rule to teach, but breaking this tie by rounding to the nearest even digit has better numerical properties, because it rounds up and down equally often, and it is the usual rule employed in real calculations.
</p>

<p class=pp>
This all results in the thunderclap rounding condition:
</p>

<pre>
buf[prec] &gt; '5' ||
buf[prec] == '5' &amp;&amp; (nonzero(buf[prec+1:n]) || buf[prec-1]%2 == 1)
</pre>

<p class=lp>
You can see why children are taught <code>buf[prec] &gt;= '5'</code> instead.
</p>

<p class=pp>
Anyway, if we have to increment after the truncation, we're still working in decimal, so we have to handle carrying incremented 9s ourselves:
</p>

<pre>
i := prec-1
for i &gt;= 0 &amp;&amp; buf[i] == '9' {
    buf[i] = '0'
    i--
}
if i &gt;= 0 {
    buf[i]++
} else {
    buf[0] = '1'
    dp++
}
</pre>

<p class=lp>
The loop handles the 9s. The <code>if</code> increments what's left, or, if we turned the whole string into zeros, it simulates inserting a 1 at the beginning by changing the first digit to a 1 and moving the decimal place.
</p>

<p class=pp>
Having done that and set <code>n</code> <code>=</code> <code>prec</code>, we can piece together the actual number:
</p>

<pre>
return fmt.Sprintf("%c.%se%+d", buf[0], buf[1:n], dp-1)
</pre>

<p class=lp>
That prints the first digit, then a decimal point, then the rest of the digits, and finally the <code>e&#177;<i>N</i></code> suffix. The exponent must adjust the number by <code>dp</code>&minus;1 because we are printing all but the first digit after the decimal point.
</p>

<p class=pp>
That's all there is to it. To print &nbsp;<i>f</i> = <i>v</i> &#215; 2<sup><i>e</i></sup>&nbsp; you write <i>v</i> in decimal, multiply or divide the decimal by 2 the right number of times, and print what you're left holding.
</p>

<p class=pp>
The Plan 9 C library and the Go library both use variants of the approach above.  On my laptop, the code above does 100,000 conversions per second, which is plenty for most uses, and the code is easy to understand.
</p>

<p class=pp>
Why are some converters more complicated than this? Because you can make them a little faster. On my laptop, glibc's <code>sprintf(buf, "%.50e",</code> <code>M_PI)</code> is about 15 times faster than an equivalent print using the code above, because the implementation of <code>sprintf</code> uses much more sophisticated mathematics to speed the conversion.
</p>

<p class=pp>
If you have a stomach for pages of equations, there are many interesting papers that discuss how to do this conversion and its inverse more quickly:
</p>

<ul>
<li>William Clinger, &ldquo;<a href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.45.4152">How to Read Floating Point Numbers Accurately</a>&rdquo;, PLDI 1990.
<li>Guy L. Steele Jr. and Jon L. White, &ldquo;<a href="http://portal.acm.org/citation.cfm?id=93559">How to Print Floating Point Numbers Accurately</a>&rdquo;, PLDI 1990.
<li>David M. Gay, &ldquo;<a href="http://citeseer.ist.psu.edu/viewdoc/summary?doi=10.1.1.31.4049">Correctly Rounded Binary-Decimal and Decimal-Binary Conversions</a>&rdquo;, AT&T Bell Laboratories, 1990.
<li>Vern Paxson, &ldquo;<a href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.144.5889">A Program for Testing IEEE Decimal-Binary Conversion</a>&rdquo;, May 1991.
<li>Robert Burger and R. Kent Dybvig, &ldquo;<a href="http://citeseer.ist.psu.edu/viewdoc/summary?doi=10.1.1.52.2247">Printing Floating-Point Numbers Quickly and Accurately</a>&rdquo;, SIGPLAN 1996.
<li>Florian Loitsch, &ldquo;<a href="http://florian.loitsch.com/publications/dtoa-pldi2010.pdf">Printing Floating-Numbers Quickly and Accurately With Integers</a>&rdquo;, PLDI 2010.
</ul>

<p class=lp>
Just remember: The conversion is easy. The optimizations are hard.
</p>

<h2>Code</h2>

<script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/1.6.1/jquery.min.js"></script>
<script>
function playground() {
    var code = encodeURIComponent($('<div/>').html(document.getElementById('code').innerHTML).text())
    document.location = "http://golang.org/doc/play/#" + code
}
</script>

<p class=lp>
The full program is available in
<a href="https://gist.github.com/1057873">this Gist</a>
or you can try it
<a href="javascript:playground();">using the Go playground</a>.
</p>

<pre id="code" style="display: none; visibility: hidden;">
package main

import (
    "fmt"
    "math"
    "strconv"
)

func ftoa(f float64, prec int) string {
    fr, exp := math.Frexp(f)
    v := int64(fr * (1&lt;&lt;53))
    e := exp - 53
    
    buf := make([]byte, 1000)
    n := copy(buf, strconv.Itoa64(v))

    for ; e &gt; 0; e-- {
        δ := 0
        if buf[0] &gt;= '5' {
            δ = 1
        }
        x := byte(0)
        for i := n-1; i &gt;= 0; i-- {
            x += 2*(buf[i] - '0')
            x, buf[i+δ] = x/10, x%10 + '0'
        }
        if δ == 1 {
            buf[0] = '1'
            n++
        }
    }
    dp := n

    for ; e &lt; 0; e++ {
        if buf[n-1]%2 != 0 {
            buf[n] = '0'
            n++
        }
        δ, x := 0, byte(0)
        if buf[0] &lt; '2' {
            δ, x = 1, buf[0] - '0'
            n--
            dp--
        }
        for i := 0; i &lt; n; i++ {
            x = x*10 + buf[i+δ] - '0'
            buf[i], x = x/2 + '0', x%2
        }
    }

    if prec &gt; 0 {
        if n &gt; prec {
            if buf[prec] &gt; '5' || buf[prec] == '5' &amp;&amp; (nonzero(buf[prec+1:n]) || buf[prec-1]%2 == 1) {
                    i := prec-1
                    for i &gt;= 0 &amp;&amp; buf[i] == '9' {
                        buf[i] = '0'
                        i--
                    }
                    if i &gt;= 0 {
                        buf[i]++
                    } else {
                        buf[0] = '1'
                        dp++
                    }
            }
            n = prec
        }
        for n &lt; prec {
            buf[n] = '0'
            n++
        }
    }
    return fmt.Sprintf("%c.%se%+d", buf[0], buf[1:n], dp-1)
}

func nonzero(buf []byte) bool {
    for _, c := range buf {
        if c != '0' {
            return true
        }
    }
    return false
}

// Difficult boundary cases, derived from tables given in
//    Vern Paxson, A Program for Testing IEEE Decimal-Binary Conversion
//    ftp://ftp.ee.lbl.gov/testbase-report.ps.Z
//
var ftoaTests = []struct{
    N int
    F float64
    A string
}{
    // Table 3: Stress Inputs for Converting 53-bit Binary to Decimal, &lt; 1/2 ULP
    {0, math.Ldexp(8511030020275656, -342), "9.e-88"},
    {1, math.Ldexp(5201988407066741, -824), "4.6e-233"},
    {2, math.Ldexp(6406892948269899, +237), "1.41e+87"},
    {3, math.Ldexp(8431154198732492, +72), "3.981e+37"},
    {4, math.Ldexp(6475049196144587, +99), "4.1040e+45"},
    {5, math.Ldexp(8274307542972842, +726), "2.92084e+234"},
    {6, math.Ldexp(5381065484265332, -456), "2.891946e-122"},
    {7, math.Ldexp(6761728585499734, -1057), "4.3787718e-303"},
    {8, math.Ldexp(7976538478610756, +376), "1.22770163e+129"},
    {9, math.Ldexp(5982403858958067, +377), "1.841552452e+129"},
    {10, math.Ldexp(5536995190630837, +93), "5.4835744350e+43"},
    {11, math.Ldexp(7225450889282194, +710), "3.89190181146e+229"},
    {12, math.Ldexp(7225450889282194, +709), "1.945950905732e+229"},
    {13, math.Ldexp(8703372741147379, +117), "1.4460958381605e+51"},
    {14, math.Ldexp(8944262675275217, -1001), "4.17367747458531e-286"},
    {15, math.Ldexp(7459803696087692, -707), "1.107950772878888e-197"},
    {16, math.Ldexp(6080469016670379, -381), "1.2345501366327440e-99"},
    {17, math.Ldexp(8385515147034757, +721), "9.25031711960365024e+232"},
    {18, math.Ldexp(7514216811389786, -828), "4.198047150284889840e-234"},
    {19, math.Ldexp(8397297803260511, -345), "1.1716315319786511046e-88"},
    {20, math.Ldexp(6733459239310543, +202), "4.32810072844612493629e+76"},
    {21, math.Ldexp(8091450587292794, -473), "3.317710118160031081518e-127"},

    // Table 4: Stress Inputs for Converting 53-bit Binary to Decimal, &gt; 1/2 ULP
    {0, math.Ldexp(6567258882077402, +952), "3.e+302"},
    {1, math.Ldexp(6712731423444934, +535), "7.6e+176"},
    {2, math.Ldexp(6712731423444934, +534), "3.78e+176"},
    {3, math.Ldexp(5298405411573037, -957), "4.350e-273"},
    {4, math.Ldexp(5137311167659507, -144), "2.3037e-28"},
    {5, math.Ldexp(6722280709661868, +363), "1.26301e+125"},
    {6, math.Ldexp(5344436398034927, -169), "7.142211e-36"},
    {7, math.Ldexp(8369123604277281, -853), "1.3934574e-241"},
    {8, math.Ldexp(8995822108487663, -780), "1.41463449e-219"},
    {9, math.Ldexp(8942832835564782, -383), "4.539277920e-100"},
    {10, math.Ldexp(8942832835564782, -384), "2.2696389598e-100"},
    {11, math.Ldexp(8942832835564782, -385), "1.13481947988e-100"},
    {12, math.Ldexp(6965949469487146, -249), "7.700366561890e-60"},
    {13, math.Ldexp(6965949469487146, -250), "3.8501832809448e-60"},
    {14, math.Ldexp(6965949469487146, -251), "1.92509164047238e-60"},
    {15, math.Ldexp(7487252720986826, +548), "6.898586531774201e+180"},
    {16, math.Ldexp(5592117679628511, +164), "1.3076622631878654e+65"},
    {17, math.Ldexp(8887055249355788, +665), "1.36052020756121240e+216"},
    {18, math.Ldexp(6994187472632449, +690), "3.592810217475959676e+223"},
    {19, math.Ldexp(8797576579012143, +588), "8.9125197712484551899e+192"},
    {20, math.Ldexp(7363326733505337, +272), "5.58769757362301140950e+97"},
    {21, math.Ldexp(8549497411294502, -448), "1.176257830728540379990e-119"},

    {3, 12345000, "1.234e+7"},
}

func main() {
    fmt.Printf("%s\n", ftoa(math.Pi, 50))  // 50 digits of math.Pi (not 50 digits of π)
    //fmt.Printf("%s\n", ftoa(math.Nextafter(0, 1), 0))
    for _, tt := range ftoaTests {
        if a := ftoa(tt.F, tt.N+1); a != tt.A {
            fmt.Printf("ftoa(%g, %d) = %q, want %q\n", tt.F, tt.N+1, a, tt.A)
        }
    }
}
</pre></p>







<div class="comments">
  <div class="comments-header old">
    <p>(Comments originally posted via Blogger.)</p>
  </div>
  <div class="comments-body">
    <div id="plus-comments">
 <div class="plus-comment"><ul><li class="plus-text">
    <p><a href='http://www.blogger.com/profile/13769333498003444630'>nicolas cellier</a> <span class="comment-when">(July 1, 2011 10:44 AM)</span> In general 1/2e requires about 0.7e non-zero decimal digits to write in full:<br />It requires exactly e digits after the decimal point, but removing the leading zeros is interesting...<br /><br />2^10 &gt; 10^3, thus 2^-10e has at least 3e leading zeroes.<br />Thus 2^-e has at least trunc(0.3e) leading zeroes, thus the 0.7e digits. Very good to know :)</p>
 </li></ul></div>
 <div class="plus-comment"><ul><li class="plus-text">
    <p><a href='http://www.blogger.com/profile/12548850641640358518'>Jan-willem</a> <span class="comment-when">(July 1, 2011 10:47 AM)</span> Do you simply cap prec to avoid extra decimal places?  I&#39;m worried about the 1.99999999999 problem that Steele &amp; White discuss, where you really want the shortest decimal that reads as the number you&#39;ve got.</p>
 </li></ul></div>
 <div class="plus-comment me"><ul><li class="plus-text">
    <p><a href="http://swtch.com/~rsc/">Russ Cox</a> <span class="comment-when">(July 1, 2011 10:55 AM)</span> http://golang.org/src/pkg/strconv/ftoa.go&#39;s roundShortest has the logic for the &#39;1.9999999999&#39; problem.  <br /><br />Basically, it&#39;s easy to figure out the (v&#39;, e&#39;) for the minimum (least) number you could print to get the right answer when converted back, and also the maximum number.  Then you walk all three at the same time until they start to differ.  Then you can round.  If a short form is a valid answer, it you&#39;ll get a digit difference very quickly.</p>
 </li></ul></div>
 <div class="plus-comment"><ul><li class="plus-text">
    <p><a href='http://www.blogger.com/profile/03215784713435892961'>GlacJAY</a> <span class="comment-when">(July 27, 2011 2:08 AM)</span> Lost minus sign in the power&#39;s range.</p>
 </li></ul></div>
    </div>
  </div>
</div>


      </div>
      
      
    </div>

    
<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
var pageTracker = _gat._getTracker("UA-3319603-2");
pageTracker._initData();
pageTracker._trackPageview();
</script>

    
    
  </body>
</html>
















