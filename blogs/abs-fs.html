<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <title>research!rsc: Absolute File System Design</title>
    <link rel="alternate" type="application/atom+xml" title="research!rsc - Atom" href="http://research.swtch.com/feed.atom" />
    
<meta name="viewport" content="width=device-width, initial-scale=1">
<link href='https://fonts.googleapis.com/css?family=Inconsolata:400,700' rel='stylesheet' type='text/css'>
<script type="text/javascript" src="https://use.typekit.com/skm6yij.js"></script>
<script type="text/javascript">try{Typekit.load();}catch(e){}</script>
<style>
  body {
    padding: 0;
    margin: 0;
    font-size: 100%;
    font-family: 'Minion Pro';
  }
  @media print {
    img {page-break-inside: avoid;}
    div.nosplit {page-break-inside: avoid;}
  }
  img.center {
    display: block;
    margin: 0 auto;
  }
  .pad {
    padding-top: 1em;
    padding-bottom: 1em;
  }
  a.anchor, a.back, a.footnote {
    color: black !important;
    text-decoration: none !important;
  }
  a.back {
    font-size: 50%;
  }
  @media print {
    a.back {display: none;}
  }
  .header {
    height: 1.25em;
    background-color: #dff;
    margin: 0;
    padding: 0.1em 0.1em 0.2em;
    border-top: 1px solid black;
    border-bottom: 1px solid #8ff;
  }
  .header h3 {
    margin: 0;
    padding: 0 2em;
    display: inline-block;
    padding-right: 2em;
    font-style: italic;
    font-size: 90%;
  }
  .rss {
    float: right;
    padding-top: 0.2em;
    padding-right: 2em;
    display: none;
  }
  .toc {
    margin-top: 2em;
  }
  .toc-title {
    font-family: "caflisch-script-pro";
    font-size: 300%;
    line-height: 50%;
  }
  .toc-subtitle {
    display: block;
    margin-bottom: 1em;
    font-size: 83%;
  }
  @media only screen and (max-width: 550px) { .toc-subtitle { display: none; } }
  .header h3 a {
    color: black;
  }
  .header h4 {
    margin: 0;
    padding: 0;
    display: inline-block;
    font-weight: normal;
    font-size: 83%;
  }
  @media only screen and (max-width: 550px) { .header h4 { display: none; } }
  .main {
    padding: 0 2em;
  }
  @media only screen and (max-width: 479px) { .article { font-size: 120%; } }
  .article h1 {
    text-align: center;
    font-size: 200%;
  }
  .copyright {
    font-size: 83%;
  }
  .subtitle {
      font-size: 65%;
  }
  .normal {
    font-size: medium;
    font-weight: normal;
  }
  .when {
    text-align: center;
    font-size: 100%;
    margin: 0;
    padding: 0;
  }
  .when p {
    margin: 0;
    padding: 0;
  }
  .article h2 {
    font-size: 125%;
    padding-top: 0.25em;
  }
  .article h3 {
    font-size: 100%;
  }
  pre {
    margin-left: 4em;
    margin-right: 4em;
  }
  pre, code {
    font-family: 'Inconsolata', monospace;
    font-size: 100%;
  }
  .footer {
    margin-top: 10px;
    font-size: 83%;
    font-family: sans-serif;
  }
  .comments {
    margin-top: 2em;
    background-color: #ffe;
    border-top: 1px solid #aa4;
    border-left: 1px solid #aa4;
    border-right: 1px solid #aa4;
  }
  .comments-header {
    padding: 0 5px 0 5px;
  }
  .comments-header p {
    padding: 0;
    margin: 3px 0 0 0;
  }
  .comments-body {
    padding: 5px 5px 5px 5px;
  }
  #plus-comments {
    border-bottom: 1px dotted #ccc;
  }
  .plus-comment {
    width: 100%;
    font-size: 14px;
    border-top: 1px dotted #ccc;
  }
  .me {
    background-color: #eec;
  }
  .plus-comment ul {
    margin: 0;
    padding: 0;
    list-style: none;
    width: 100%;
    display: inline-block;
  }
  .comment-when {
    color:#999;
    width:auto;
    padding:0 5px;
  }
  .old {
    font-size: 83%;
  }
  .plus-comment ul li {
    display: inline-block;
    vertical-align: top;
    margin-top: 5px;
    margin-bottom: 5px;
    padding: 0;
  }
  .plus-icon {
    width: 45px;
  }
  .plus-img {
    float: left;
    margin: 4px 4px 4px 4px;
    width: 32px;
    height: 32px;
  }
  .plus-comment p {
    margin: 0;
    padding: 0;
  }
  .plus-clear {
    clear: left;
  }
  .toc-when {
    font-size: 83%;
    color: #999;
  }
  .toc {
    list-style: none;
  }
  .toc li {
    margin-bottom: 0.5em;
  }
  .toc-head {
    margin-bottom: 1em !important;
    font-size: 117%;
  }
  .toc-summary {
    margin-left: 2em;
  }
  .favorite {
    font-weight: bold;
  }
  .article p, .article ol {
    line-height: 144%;
  }
  sup, sub {
    vertical-align: baseline;
    position: relative;
    font-size: 83%;
  }
  sup {
    bottom: 1ex;
  }
  sub {
    top: 0.8ex;
  }

  .main {
    position: relative;
    margin: 0 auto;
    padding: 0;
    width: 900px;
  }
  @media only screen and (min-width: 768px) and (max-width: 959px) { .main { width: 708px; } }
  @media only screen and (min-width: 640px) and (max-width: 767px) { .main { width: 580px; } }
  @media only screen and (min-width: 480px) and (max-width: 639px) { .main { width: 420px; } }
  @media only screen and (max-width: 479px) { .main { width: 300px; } }

</style>

  </head>
  <body>
    
<div class="header">
  <h3><a href="/">research!rsc</a></h3>
  <h4>Thoughts and links about programming,
    by <a href="https://swtch.com/~rsc/" rel="author">Russ Cox</a> </h4>
  <a class="rss" href="/feed.atom"><img src="/feed-icon-14x14.png" /></a>
</div>

    <div class="main">
      <div class="article">
        <h1>Absolute File System Design
        
        <div class="normal">
        <div class="when">
          
            Posted on Monday, February 11, 2008.
            
          
        </div>
        </div>
        </h1>
        
<p><p class=lp>Butler Lampson and Robert Sproull's 1979 SOSP paper &ldquo;<a href="http://research.microsoft.com/lampson/22-OpenOS/Acrobat.pdf"><b>An Open Operating System for a Single-User Machine</b></a>&rdquo; (PDF; also <a href="http://research.microsoft.com/lampson/22-OpenOS/WebPage.html">HTML</a>) describes the operating system on the Alto, a groundbreaking personal networked workstation built at Xerox PARC in the late 1970s and early 1980s. Many Alto features became everyday aspects of modern computing environments, but one that didn't catch on was the Alto's robust file system. </p> <p class=pp> The Alto file system was designed to withstand disk or programming errors.  If some set of disk blocks were lost, the Alto file system would only lose the data contained in those sectors. If you lose a data block from a file, you lose just that data block. If you lose a block in a directory, you lose the name for that file but not the file itself. </p> <p class=pp> Section 3 of the paper gives the details.  The basic technique is that each disk block contains a small header giving the id number and version of the associated file along with the block's offset in the file and the amount of data in the block (the last block in a file might contain less than a block worth of data). Lampson and Sproull refer to this information as <i>absolute</i>: it is the single point of truth for the block in question. A disk scavenger (like Unix's <i>fsck</i>) can scan the entire file system reading block labels to reconstruct the contents of any file. </p> <p class=pp> Scanning the entire file system to find block contents is of course  very slow.  The block label also contains pointers to the previous and next block in a file, so that reading a file can just follow the block pointers (the file system layout algorithm arranged that much of the time files would be laid out sequentially so that following these pointers would not be too expensive in terms of disk seeks). These pointers are called <i>hints</i>, because they exist only for performance, not for correctness.  If the hints are incorrect, that fact will become clear when they are used (the label of the pointed at block will not agree with expectations), and the scavenger can be invoked to fix the file system. </p> <p class=pp> Contrast this scheme to inodes in a modern Unix file system (say, BSD FFS or Linux Ext2/3). If you lose the 512-byte disk block containing a 1GB file's inode, the entire file is inaccessible.  No amount of scavenging can  help, because the list of blocks making up the file was only contained in the inode, and the blocks themselves are not tagged with which file they belong to. This is much less robust than the Alto file system. Of course, the situation is even worse if you lose the 512-byte disk block containing the file system superblock: then you've lost the entire file system.  Because the superblock is so crucial, file systems usually maintain backup copies of the superblock scattered across the disk.  Inodes are almost as important but not so carefully guarded. </p> <p class=pp> Why don't modern file systems don't use labels like the Alto did? </p> <p class=pp> Disk geometry might play a role: it is hard to reconcile a  (say) 32 byte label with (say) a 4096 byte data block. You put the label in the data block, cutting the actual data size to 4064 bytes. You could put the label in the sector before the block, taking up 512 bytes for a 32 byte label. Or you could write a label sector containing 16 labels every 16 data blocks. The third is probably the best option, but all of them are  somewhat cumbersome. (But you'd lose less data!) </p> <p class=pp> Another reason is historical: the original Unix file system didn't have any such mechanism, and FFS and Ext2/3 differ little from the original Unix file system. </p> <p class=pp> Another reason might be philosophical: you're supposed to handle disk failures with backups, not clever file system tricks. This is the least useful argument: who wouldn't want a file system that needed to resort to backups less often? </p> <p class=pp> Another reason might be pragmatic: maybe disks fail in different ways now than they did in 1979.  (Of course, that doesn't explain the original Unix file system or FFS.) Since there's so little data on disk failures, it's hard to say anything for certain. </p> <p class=pp> Whatever the arguments against labels, it is undeniable that they produced a very robust system.  In fact, the operating system on the Alto could be almost completely swapped out an replaced with user programs, each of which could supply its own file system implementation.  Over time, there came to be three file system implementations sharing the disk, one in BCPL, one in Mesa, and one in Smalltalk. In <a href="http://research.microsoft.com/lampson/38-AltoSoftware/Abstract.html">a retrospective paper</a>, Lampson wrote:</p>  <blockquote> <p class=lp>If a disk address is wrong, the label check will detect the error, and various recovery mechanisms can be invoked. A Scavenger program, written by Jim Morris, takes about a minute to check or restore the consistency of an Alto file system; it can be routinely run by nonprofessional users. As a result of this conservative design, the file system has proved to be very reliably; loss of any information other than bits physically damaged on the disk is essentially unheard of.  This reliability is achieved in spite of the fact that many programs besides the standard operating system have access to the disk. </p></blockquote> <p class=lp>Who wouldn't want a robust system like that? And why aren't more of today's file systems that robust? </p></p>





<div class="comments">
  <div class="comments-header old">
    <p>(Comments originally posted via Blogger.)</p>
  </div>
  <div class="comments-body">
    <div id="plus-comments">
 <div class="plus-comment"><ul><li class="plus-text">
    <p><a href='http://www.blogger.com/profile/10850439928916346077'>garyj</a> <span class="comment-when">(February 11, 2008 10:08 AM)</span> the reason this doesn't matter <B>at all</B> is because disks don't fail in such a way as to make it matter.  I.e., if you lose a few blocks, it is VERY LIKELY you've lost a lot of blocks, or that entire sectors are unreadable.  Studies of disk failures also indicate that once you've lost a few sectors, you are likely going to lose a lot more soon (because such errors are due to platter warpage, foreign material, head alignment, etc).<BR/><BR/>Unix's scheme of keeping multiple copies of inode's is actually much more reliable in dealing with such situations.<BR/><BR/>Of course, with the move to solid state drives, maybe Lampson and Sproull's method deserves another look (anyone have any pointers to research on flash drive failures?).</p>
 </li></ul></div>
 <div class="plus-comment"><ul><li class="plus-text">
    <p><a href='http://www.blogger.com/profile/00716572574695142998'>seregine</a> <span class="comment-when">(February 11, 2008 7:37 PM)</span> Interesting. So if I insert a block at the beginning of a 1GB file, the FS has to write to every other block to update its offset?</p>
 </li></ul></div>
 <div class="plus-comment me"><ul><li class="plus-text">
    <p><a href="http://swtch.com/~rsc/">Russ Cox</a> <span class="comment-when">(February 12, 2008 3:19 AM)</span> @seregine: Sure, but the traditional Unix file interface doesn't provide an "insert" operation anyway.  "Inserting" at the beginning of the file is accomplished by writing the entire file out again at a different offset anyway.   <BR/><BR/>This is why MP3 tags are usually placed at the end of the MP3 file, making them easier to edit.</p>
 </li></ul></div>
 <div class="plus-comment"><ul><li class="plus-text">
    <p><a href='http://www.blogger.com/profile/17320082374768944309'>fanf</a> <span class="comment-when">(February 15, 2008 2:51 PM)</span> One reason against block labels is that they interleave data and metadata, so users can't mmap files and the OS can't have a unified buffer cache.</p>
 </li></ul></div>
 <div class="plus-comment me"><ul><li class="plus-text">
    <p><a href="http://swtch.com/~rsc/">Russ Cox</a> <span class="comment-when">(February 15, 2008 4:13 PM)</span> @fanf: Placing a block full of N labels every N data blocks would address that problem.</p>
 </li></ul></div>
 <div class="plus-comment"><ul><li class="plus-text">
    <p><a href='http://www.blogger.com/profile/14442121383593520632'>mike.w.meyer</a> <span class="comment-when">(February 15, 2008 8:42 PM)</span> Interleaving data and metadata also hoses the performance of<BR/>multi-block (not even large) transfers. If I don't do that, I can just<BR/>point the disk controller at consecutive chunks of RAM, and let it<BR/>load blocks directly into the users output buffer. With metadata at<BR/>the start of the block, I have to put the block in an intermediate<BR/>buffer in order to copy out just the data.</p>
 </li></ul></div>
 <div class="plus-comment me"><ul><li class="plus-text">
    <p><a href="http://swtch.com/~rsc/">Russ Cox</a> <span class="comment-when">(February 17, 2008 6:06 AM)</span> @mike.w.meyer: I don't believe this is a concern in practice, since it's far more common to load the data first into the kernel's buffer cache.  The buffer cache can certainly handle some of the buffers being label blocks, so it would still be a sequential transfer.</p>
 </li></ul></div>
 <div class="plus-comment"><ul><li class="plus-text">
    <p><a href='http://www.blogger.com/profile/15155998626202067226'>Marius Gedminas</a> <span class="comment-when">(March 15, 2008 5:52 AM)</span> What are the performance implications of this kind of file system?  Would seeking into the middle of a large file require you to read all the blocks from the beginning of the file to follow the metadata chain?  How about appending to the end of a big file?<BR/><BR/>How much disk space would this kind of extensive metadata use, compared to something like ext3?</p>
 </li></ul></div>
 <div class="plus-comment me"><ul><li class="plus-text">
    <p><a href="http://swtch.com/~rsc/">Russ Cox</a> <span class="comment-when">(March 15, 2008 8:10 AM)</span> @marius: Sure, if you used only the linked list to navigate, then the file system accesses would be slow.  But there's nothing stopping you from building block trees like Unix file systems and using them as <I>hints</I> to find the blocks faster.<BR/><BR/>The space overhead is pretty minimal: a few words per 4096-byte block would be under 1%.  Make the block size bigger and the overhead goes down.</p>
 </li></ul></div>
 <div class="plus-comment"><ul><li class="plus-text">
    <p><a href='http://www.blogger.com/profile/00068719978877211213'>forsyth</a> <span class="comment-when">(April 30, 2008 3:25 PM)</span> ken thompson's file server for Plan 9 tags each block with a little data (type and path) which isn't quite enough to allow recovering whole files automatically but does allow simple consistency checks that (for me) not only detected problems (hardware and software) but prevented them escalating to destroy file systems (eg, data, directory, and free list blocks have different types).</p>
 </li></ul></div>
 <div class="plus-comment"><ul><li class="plus-text">
    <p><a href='http://www.blogger.com/profile/09316935439535008529'>Keith</a> <span class="comment-when">(June 24, 2009 7:59 PM)</span> Sorry to arrive at the party so late.  But as a file system nerd I couldn&#39;t help commenting...<br /><br />Some modern file systems do stuff like this. Unfortunately, they&#39;re not systems that are well described in the academic literature.  Sun&#39;s new ZFS file system stores multiple copies of every metadata block, along with checksums of every block.  So if an inode or indirect block gets corrupted you can detect the corruption and find a good copy of the data.  It&#39;s not the same as Alto, but is makes it much harder to loose track of your data blocks.<br /><br />NetApp&#39;s WAFL file system stores block identity information along with the block---either in an enlarged 4160-byte block or in a nearby block similar to &quot;label sector&quot; idea you describe.<br /><br />There are also a variety of real world issues that make the Alto approach less useful.  <br /><br />With RAID, I can usually reconstruct lost data (or metadata) without the need to resort to scanning every block in the file system. This doesn&#39;t help the individual user with a single-disk file system, but a lot of the more advanced file systems are targeting folks who can pay for them, and these folks typically have RAID.<br /><br />With the sizes of modern disks it is increasingly impractical to do a full scan of a file system.  Disk sizes are already over 1 TB, and there are folks running file systems that span dozens of those disks. If I lose a few inodes, it may be faster to restore from backup than to scan the entire file system looking for the unreferenced blocks.<br /><br />Performance and capacity.  At the high-end, you can get disks that will support 520-byte sectors, giving you room to store block labels.  But most data is stored on lower-end disks.  There you can either use 9 sectors for a 4KB block, essentially wasting 10% of your storage, or you can do something like your &quot;label sector.&quot; The label sectors would work, but would force you to do disk writes for each block you modify.    <br /><br />As you&#39;ll notice, however, none of these issues invalidates the Alto approach.  There would still be cases where it would save you. And given the numerous clever ideas people are coming up with in new file systems like btrfs, tux3, and HAMMER, you would think more people would find ways to use this idea in modern file systems.</p>
 </li></ul></div>
    </div>
  </div>
</div>


      </div>
      
      
    </div>

    
<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
var pageTracker = _gat._getTracker("UA-3319603-2");
pageTracker._initData();
pageTracker._trackPageview();
</script>

    
    
  </body>
</html>
















