<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <title>research!rsc: Bigger Programs are Better, not Best</title>
    <link rel="alternate" type="application/atom+xml" title="research!rsc - Atom" href="http://research.swtch.com/feed.atom" />
    
<meta name="viewport" content="width=device-width, initial-scale=1">
<link href='https://fonts.googleapis.com/css?family=Inconsolata:400,700' rel='stylesheet' type='text/css'>
<script type="text/javascript" src="https://use.typekit.com/skm6yij.js"></script>
<script type="text/javascript">try{Typekit.load();}catch(e){}</script>
<style>
  body {
    padding: 0;
    margin: 0;
    font-size: 100%;
    font-family: 'Minion Pro';
  }
  @media print {
    img {page-break-inside: avoid;}
    div.nosplit {page-break-inside: avoid;}
  }
  img.center {
    display: block;
    margin: 0 auto;
  }
  .pad {
    padding-top: 1em;
    padding-bottom: 1em;
  }
  a.anchor, a.back, a.footnote {
    color: black !important;
    text-decoration: none !important;
  }
  a.back {
    font-size: 50%;
  }
  @media print {
    a.back {display: none;}
  }
  .header {
    height: 1.25em;
    background-color: #dff;
    margin: 0;
    padding: 0.1em 0.1em 0.2em;
    border-top: 1px solid black;
    border-bottom: 1px solid #8ff;
  }
  .header h3 {
    margin: 0;
    padding: 0 2em;
    display: inline-block;
    padding-right: 2em;
    font-style: italic;
    font-size: 90%;
  }
  .rss {
    float: right;
    padding-top: 0.2em;
    padding-right: 2em;
    display: none;
  }
  .toc {
    margin-top: 2em;
  }
  .toc-title {
    font-family: "caflisch-script-pro";
    font-size: 300%;
    line-height: 50%;
  }
  .toc-subtitle {
    display: block;
    margin-bottom: 1em;
    font-size: 83%;
  }
  @media only screen and (max-width: 550px) { .toc-subtitle { display: none; } }
  .header h3 a {
    color: black;
  }
  .header h4 {
    margin: 0;
    padding: 0;
    display: inline-block;
    font-weight: normal;
    font-size: 83%;
  }
  @media only screen and (max-width: 550px) { .header h4 { display: none; } }
  .main {
    padding: 0 2em;
  }
  @media only screen and (max-width: 479px) { .article { font-size: 120%; } }
  .article h1 {
    text-align: center;
    font-size: 200%;
  }
  .copyright {
    font-size: 83%;
  }
  .subtitle {
      font-size: 65%;
  }
  .normal {
    font-size: medium;
    font-weight: normal;
  }
  .when {
    text-align: center;
    font-size: 100%;
    margin: 0;
    padding: 0;
  }
  .when p {
    margin: 0;
    padding: 0;
  }
  .article h2 {
    font-size: 125%;
    padding-top: 0.25em;
  }
  .article h3 {
    font-size: 100%;
  }
  pre {
    margin-left: 4em;
    margin-right: 4em;
  }
  pre, code {
    font-family: 'Inconsolata', monospace;
    font-size: 100%;
  }
  .footer {
    margin-top: 10px;
    font-size: 83%;
    font-family: sans-serif;
  }
  .comments {
    margin-top: 2em;
    background-color: #ffe;
    border-top: 1px solid #aa4;
    border-left: 1px solid #aa4;
    border-right: 1px solid #aa4;
  }
  .comments-header {
    padding: 0 5px 0 5px;
  }
  .comments-header p {
    padding: 0;
    margin: 3px 0 0 0;
  }
  .comments-body {
    padding: 5px 5px 5px 5px;
  }
  #plus-comments {
    border-bottom: 1px dotted #ccc;
  }
  .plus-comment {
    width: 100%;
    font-size: 14px;
    border-top: 1px dotted #ccc;
  }
  .me {
    background-color: #eec;
  }
  .plus-comment ul {
    margin: 0;
    padding: 0;
    list-style: none;
    width: 100%;
    display: inline-block;
  }
  .comment-when {
    color:#999;
    width:auto;
    padding:0 5px;
  }
  .old {
    font-size: 83%;
  }
  .plus-comment ul li {
    display: inline-block;
    vertical-align: top;
    margin-top: 5px;
    margin-bottom: 5px;
    padding: 0;
  }
  .plus-icon {
    width: 45px;
  }
  .plus-img {
    float: left;
    margin: 4px 4px 4px 4px;
    width: 32px;
    height: 32px;
  }
  .plus-comment p {
    margin: 0;
    padding: 0;
  }
  .plus-clear {
    clear: left;
  }
  .toc-when {
    font-size: 83%;
    color: #999;
  }
  .toc {
    list-style: none;
  }
  .toc li {
    margin-bottom: 0.5em;
  }
  .toc-head {
    margin-bottom: 1em !important;
    font-size: 117%;
  }
  .toc-summary {
    margin-left: 2em;
  }
  .favorite {
    font-weight: bold;
  }
  .article p, .article ol {
    line-height: 144%;
  }
  sup, sub {
    vertical-align: baseline;
    position: relative;
    font-size: 83%;
  }
  sup {
    bottom: 1ex;
  }
  sub {
    top: 0.8ex;
  }

  .main {
    position: relative;
    margin: 0 auto;
    padding: 0;
    width: 900px;
  }
  @media only screen and (min-width: 768px) and (max-width: 959px) { .main { width: 708px; } }
  @media only screen and (min-width: 640px) and (max-width: 767px) { .main { width: 580px; } }
  @media only screen and (min-width: 480px) and (max-width: 639px) { .main { width: 420px; } }
  @media only screen and (max-width: 479px) { .main { width: 300px; } }

</style>

  </head>
  <body>
    
<div class="header">
  <h3><a href="/">research!rsc</a></h3>
  <h4>Thoughts and links about programming,
    by <a href="https://swtch.com/~rsc/" rel="author">Russ Cox</a> </h4>
  <a class="rss" href="/feed.atom"><img src="/feed-icon-14x14.png" /></a>
</div>

    <div class="main">
      <div class="article">
        <h1>Bigger Programs are Better, not Best
        
        <div class="normal">
        <div class="when">
          
            Posted on Friday, April 4, 2008.
            
          
        </div>
        </div>
        </h1>
        
<p><p class=pp>
When computer scientists study algorithms, they are
interested in how much time or working space an algorithm
requires, as a function of the input size: quicksort
uses <i>O</i>(<i>n</i> log <i>n</i>) time, but only <i>O</i>(<i>n</i>) space.
For the most part, computer scientists don't study 
how much <i>code</i> a problem requires.  In fact,
part of what it means to be an algorithm is that it can be
implemented as a fixed-size program that works regardless
of the input size.
Intuitively, though, bigger programs should
be able to do more than smaller programs.
</p>

<p class=pp>
It is pretty easy to prove that bigger programs are better,
or at least that they can do more.
To start, we need to precisely define what we mean by
the size a program.  These kinds of discussions often
use Turing machines, but these days not many people are 
comfortable with Turing machines, so I'm going to use Scheme.
[<a href="http://en.wikipedia.org/wiki/Irony_mark">&#1567;</a>]
</p>

<p class=pp>
Let's define a Scheme program's <i>size</i> to be the number of
left parentheses it contains.
We need to disallow arbitrarily large parenthesis-free expressions,
so that there are only a finite number of Scheme programs of a given size.
Let's limit functions to three arguments and 
integer literals to be numbers less than 100.
These requirements might make Scheme a little more verbose,
but they don't make it any less powerful.
Notice that these programs are just expressions that don't take any input.
</p>

<p class=pp>
If we look at all the Scheme programs of a given size,
some of those programs evaluate to integers:
<code>(+ 1 (+ 2 3))</code> has size 2 and evaluates to 6.
Let's define <i>B</i>(<i>n</i>) to be the largest integer that can be
produced by evaluating a Scheme program of size <i>n</i>.
The example demonstrates that <i>B</i>(3) is at least 6.
</p>

<p class=pp>
The formal statement of the &ldquo;bigger is better&rdquo;
assertion is that <i>B</i>(<i>n</i>+1) &gt; <i>B</i>(<i>n</i>) for any <i>n</i>.
For any given <i>n</i>, the definition of <i>B</i> requires that
there be some Scheme program <code>e</code> of size <i>n</i> that 
evaluates to <i>B</i>(<i>n</i>).
Then <code>(+ 1 e)</code> has size <i>n</i>+1 and evaluates to 1+<i>B</i>(<i>n</i>).
This demonstrates that <i>B</i>(<i>n</i>+1) is at least 1+<i>B</i>(<i>n</i>), 
so <i>B</i>(<i>n</i>+1) &gt; <i>B</i>(<i>n</i>).
</p>

<p class=pp>
There you have it.  Bigger programs are better.
But it turns out that no matter how big a program
you write, it can't compute <i>B</i>(<i>n</i>).
<i>B</i>(<i>n</i>) gets so big so fast that no fixed-size program can keep up.
We can prove this too.
</p>

<p class=pp>
Consider any Scheme function <code>f</code> that takes a single integer argument.
This is a lambda expression, not a standalone program like we've been
considering, but it still has some size <i>s</i>.
Define <i>n</i> = 2<i>s</i>+1.
We can write a Scheme program <code>n1</code>, also of size <i>s</i>,
that computes 2<i>s</i>+2 = <i>n</i>+1.  The program looks like
<code>(+ 2 (+ 2 ... (+ 2 (+ 2 2)) ...))</code>.
Now consider the Scheme program <code>(f n1)</code>,
wihch has size <i>s</i>+<i>s</i>+1 = <i>n</i>.
Since it has size <i>n</i>, it cannot compute a number bigger than <i>B</i>(<i>n</i>).
The value of the argument to <code>f</code> is <i>n</i>+1, 
and <i>B</i>(<i>n</i>+1) &gt; <i>B</i>(<i>n</i>), so
<code>f</code> cannot be computing <i>B</i>.
Essentially, <i>B</i> grows faster than any function you can implement in Scheme.*
</p>

<p class=pp>
There you have it.  The function <i>B</i> cannot be computed.
Bigger has bested the computer.
</p>

<p class=pp>
The original presentation of this result is
Tibor Rado's 1962 paper &ldquo;<a href="http://pdos.csail.mit.edu/~rsc/rado62beaver.pdf"><b>On Non-Computable Functions</b></a>&rdquo; (PDF, 320kB),
which appeared in the Bell System Technical Journal.
Rado used Turing machines, not Scheme programs,
and called the function <i>Σ</i>(<i>n</i>), not <i>B</i>(<i>n</i>).
He also defined a function <i>S</i>(<i>n</i>) which is the maximum
length of any computation by a Turing machine of size <i>n</i>
that eventually stops.
Rado made a game of trying to make Turing machines
of a given size that ran for as long as possible (but stopped),
and he called it the &ldquo;Busy Beaver game.&rdquo;
</p>

<p class=pp>
The function Σ is sometimes called the Busy Beaver function,
leading to a slew of papers by 
otherwise respectable computer scientists and mathematicians
<a href="http://www.google.com/search?&q=busy-beaver+turing+machine">about busy beavers</a>.
In particular, a favorite pastime is to attempt to compute
<i>Σ</i>(<i>n</i>) and <i>S</i>(<i>n</i>) by hand, for small values of <i>n</i>.
This requires analyzing all possible Turing machines
of the given size to figure out
whether each eventually stops, and if so, how long it runs 
and what number it prints.
</p>

<p class=pp>
Using a computer to analyze the easy machines
and then doing the hard ones by hand,
Rado and his student Shen Lin
proved that <i>Σ</i>(1) = 1, <i>S</i>(1) = 1, <i>Σ</i>(2) = 4, and <i>S</i>(2) = 6
in their 1965 paper &ldquo;<a href="http://doi.acm.org.libproxy.mit.edu/10.1145/321264.321270">Computer Studies of Turing Machine Problems</a>&rdquo; (subscription required).
Lin proved in his Ph.D. thesis that <i>Σ</i>(3) = 6 and <i>S</i>(3) = 21.
In 1983, Allen Brady proved that <i>Σ</i>(4) = 13 and <i>S</i>(4) = 107.
</p>

<p class=pp>
Rona Machlin and Quentin Stout summarized the situation
nicely in their 1990 paper &ldquo;<a href="http://www.eecs.umich.edu/~qstout/abs/busyb.html">The Complex Behavior Of Simple Machines</a>:&rdquo;
</p>

<blockquote>
<p class=lp>
 Brady predicted that there
 will never be a proof of the values of <i>Σ</i>(5) and <i>S</i>(5).
 We are just slightly more optimistic, and are
 lead to recast a parable due to Erdös (who spoke
 in the context of determining Ramsey numbers):
 suppose a vastly superior alien force lands and announces
 that they will destroy the planet unless we provide
 a value of the S function, along with a proof of its 
 correctness.  If they ask for <i>S</i>(5) we should put all
 of our mathematicians, computer scientists, and
 computers to the task, but if they ask for <i>S</i>(6) we should
 immediately attack because the task is hopeless.
</p>
</blockquote>

<p class=pp>
Michiel Wijers has a <a href="http://www.win.tue.nl/~wijers/bb-index.htm">good bibliography</a>.
Allen Brady has recently been
exploring <a href="http://www.cse.unr.edu/~al/BusyBeaver.html">ternary
Turing machines</a>.
</p>
<br>

<p class=lp>
<span style="font-size: 0.8em">* It doesn't matter that we used Scheme and Rado used Turing machines,
because Scheme can simulate a Turing machine and vice versa.
In fact, so far no feasible computational model has yet been found
that can't be simulated by a Turing machine (or, by extension, by Scheme).
The <a href="http://en.wikipedia.org/wiki/Church-Turing_thesis">Church-Turing
thesis</a> is the name for the hypothesis that anything we would
reasonably consider computable can be computed by a Turing machine
(or lambda calculus or a general-recursive function, both of which are equivalent).
The exact details of what you can do with a given size differs
from model to model, but the net result is the same:
even a Turing machine can't compute our Scheme-based <i>B</i>(<i>n</i>).
The result would work for any modern programming language,
but Scheme makes the proofs particularly elegant.</span>
</p></p>





<div class="comments">
  <div class="comments-header old">
    <p>(Comments originally posted via Blogger.)</p>
  </div>
  <div class="comments-body">
    <div id="plus-comments">
 <div class="plus-comment"><ul><li class="plus-text">
    <p><a href='http://www.blogger.com/profile/11014201732055198675'>Screwperman</a> <span class="comment-when">(April 4, 2008 10:35 PM)</span> If I'm not mistaken, some quicksorts take O(lg n) space.<BR/><BR/>Good point, though.</p>
 </li></ul></div>
    </div>
  </div>
</div>


      </div>
      
      
    </div>

    
<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
var pageTracker = _gat._getTracker("UA-3319603-2");
pageTracker._initData();
pageTracker._trackPageview();
</script>

    
    
  </body>
</html>
















