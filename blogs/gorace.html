<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <title>research!rsc: Off to the Races</title>
    <link rel="alternate" type="application/atom+xml" title="research!rsc - Atom" href="http://research.swtch.com/feed.atom" />
    
<meta name="viewport" content="width=device-width, initial-scale=1">
<link href='https://fonts.googleapis.com/css?family=Inconsolata:400,700' rel='stylesheet' type='text/css'>
<script type="text/javascript" src="https://use.typekit.com/skm6yij.js"></script>
<script type="text/javascript">try{Typekit.load();}catch(e){}</script>
<style>
  body {
    padding: 0;
    margin: 0;
    font-size: 100%;
    font-family: 'Minion Pro';
  }
  @media print {
    img {page-break-inside: avoid;}
    div.nosplit {page-break-inside: avoid;}
  }
  img.center {
    display: block;
    margin: 0 auto;
  }
  .pad {
    padding-top: 1em;
    padding-bottom: 1em;
  }
  a.anchor, a.back, a.footnote {
    color: black !important;
    text-decoration: none !important;
  }
  a.back {
    font-size: 50%;
  }
  @media print {
    a.back {display: none;}
  }
  .header {
    height: 1.25em;
    background-color: #dff;
    margin: 0;
    padding: 0.1em 0.1em 0.2em;
    border-top: 1px solid black;
    border-bottom: 1px solid #8ff;
  }
  .header h3 {
    margin: 0;
    padding: 0 2em;
    display: inline-block;
    padding-right: 2em;
    font-style: italic;
    font-size: 90%;
  }
  .rss {
    float: right;
    padding-top: 0.2em;
    padding-right: 2em;
    display: none;
  }
  .toc {
    margin-top: 2em;
  }
  .toc-title {
    font-family: "caflisch-script-pro";
    font-size: 300%;
    line-height: 50%;
  }
  .toc-subtitle {
    display: block;
    margin-bottom: 1em;
    font-size: 83%;
  }
  @media only screen and (max-width: 550px) { .toc-subtitle { display: none; } }
  .header h3 a {
    color: black;
  }
  .header h4 {
    margin: 0;
    padding: 0;
    display: inline-block;
    font-weight: normal;
    font-size: 83%;
  }
  @media only screen and (max-width: 550px) { .header h4 { display: none; } }
  .main {
    padding: 0 2em;
  }
  @media only screen and (max-width: 479px) { .article { font-size: 120%; } }
  .article h1 {
    text-align: center;
    font-size: 200%;
  }
  .copyright {
    font-size: 83%;
  }
  .subtitle {
      font-size: 65%;
  }
  .normal {
    font-size: medium;
    font-weight: normal;
  }
  .when {
    text-align: center;
    font-size: 100%;
    margin: 0;
    padding: 0;
  }
  .when p {
    margin: 0;
    padding: 0;
  }
  .article h2 {
    font-size: 125%;
    padding-top: 0.25em;
  }
  .article h3 {
    font-size: 100%;
  }
  pre {
    margin-left: 4em;
    margin-right: 4em;
  }
  pre, code {
    font-family: 'Inconsolata', monospace;
    font-size: 100%;
  }
  .footer {
    margin-top: 10px;
    font-size: 83%;
    font-family: sans-serif;
  }
  .comments {
    margin-top: 2em;
    background-color: #ffe;
    border-top: 1px solid #aa4;
    border-left: 1px solid #aa4;
    border-right: 1px solid #aa4;
  }
  .comments-header {
    padding: 0 5px 0 5px;
  }
  .comments-header p {
    padding: 0;
    margin: 3px 0 0 0;
  }
  .comments-body {
    padding: 5px 5px 5px 5px;
  }
  #plus-comments {
    border-bottom: 1px dotted #ccc;
  }
  .plus-comment {
    width: 100%;
    font-size: 14px;
    border-top: 1px dotted #ccc;
  }
  .me {
    background-color: #eec;
  }
  .plus-comment ul {
    margin: 0;
    padding: 0;
    list-style: none;
    width: 100%;
    display: inline-block;
  }
  .comment-when {
    color:#999;
    width:auto;
    padding:0 5px;
  }
  .old {
    font-size: 83%;
  }
  .plus-comment ul li {
    display: inline-block;
    vertical-align: top;
    margin-top: 5px;
    margin-bottom: 5px;
    padding: 0;
  }
  .plus-icon {
    width: 45px;
  }
  .plus-img {
    float: left;
    margin: 4px 4px 4px 4px;
    width: 32px;
    height: 32px;
  }
  .plus-comment p {
    margin: 0;
    padding: 0;
  }
  .plus-clear {
    clear: left;
  }
  .toc-when {
    font-size: 83%;
    color: #999;
  }
  .toc {
    list-style: none;
  }
  .toc li {
    margin-bottom: 0.5em;
  }
  .toc-head {
    margin-bottom: 1em !important;
    font-size: 117%;
  }
  .toc-summary {
    margin-left: 2em;
  }
  .favorite {
    font-weight: bold;
  }
  .article p, .article ol {
    line-height: 144%;
  }
  sup, sub {
    vertical-align: baseline;
    position: relative;
    font-size: 83%;
  }
  sup {
    bottom: 1ex;
  }
  sub {
    top: 0.8ex;
  }

  .main {
    position: relative;
    margin: 0 auto;
    padding: 0;
    width: 900px;
  }
  @media only screen and (min-width: 768px) and (max-width: 959px) { .main { width: 708px; } }
  @media only screen and (min-width: 640px) and (max-width: 767px) { .main { width: 580px; } }
  @media only screen and (min-width: 480px) and (max-width: 639px) { .main { width: 420px; } }
  @media only screen and (max-width: 479px) { .main { width: 300px; } }

</style>

  </head>
  <body>
    
<div class="header">
  <h3><a href="/">research!rsc</a></h3>
  <h4>Thoughts and links about programming,
    by <a href="https://swtch.com/~rsc/" rel="author">Russ Cox</a> </h4>
  <a class="rss" href="/feed.atom"><img src="/feed-icon-14x14.png" /></a>
</div>

    <div class="main">
      <div class="article">
        <h1>Off to the Races
        
        <div class="normal">
        <div class="when">
          
            Posted on Tuesday, February 23, 2010.
            
          
        </div>
        </div>
        </h1>
        
<p><p class=lp>
Go is defined to be a safe language.
Indices into array or string references must be in bounds;
there is no way to reinterpret the bits of one type
as another, no way to conjure a pointer out of thin air;
and there is no way to release memory, so no
chance of &ldquo;<a href="http://en.wikipedia.org/wiki/Dangling_pointer">dangling pointer</a>&rdquo; errors and the
associated memory corruption and instability.
</p>

<p class=pp>In the current Go implementations, though, there are two
ways to break through these safety mechanisms.
The first and more direct way is to use 
<a href="http://golang.org/pkg/unsafe/">package unsafe</a>,
specifically <a href="http://golang.org/pkg/unsafe#Pointer">unsafe.Pointer</a>.
The second, less direct way is to use a data race in a multithreaded program.
</p>

<p class=pp>If you were going to build an environment that ran untrusted
Go code, you'd probably want to change the available packages to restrict
or delete certain routines, like <a href="http://golang.org/pkg/os/#RemoveAll">os.RemoveAll</a>,
and you'd want to disallow access to package unsafe.
Those kinds of restrictions are straightforward.
</p>

<p class=pp>The data races that can be used to break through the
usual memory safety of Go are less straightforward.
This post describes the races and how to rearrange the data
structures involved to avoid them.
Until the Go implementations have been tuned more,
we won't be able to measure whether there is a
significant performance difference between the current
representation and the race-free implementation.
</p>

<h3>Package Unsafe</h3>

<p class=lp>Here's a simple packaging of a type that lets you
edit arbitrary memory locations, built using the standard
<a href="http://golang.org/pkg/unsafe/">package unsafe</a>:
</p>

<pre class=indent>
import "unsafe"

type Mem struct {
 addr *uintptr // actually == &amp;m.data!
 data *uintptr
}

// Peek reads and returns the word at address addr.
func (m *Mem) Peek(addr uintptr) uintptr {
 *m.addr = addr
 return *m.data
}

// Poke sets the word at address addr to val.
func (m *Mem) Poke(addr, val uintptr) {
 *m.addr = addr
 *m.data = val
}

func NewMem() *Mem {
 m := new(Mem)
 m.addr = (*uintptr)(unsafe.Pointer(&amp;m.data))
 return m
}
</pre>

<p class=lp>(The Go type <code>uintptr</code> is an unsigned integer
the size of a pointer, like <code>uint32</code> or <code>uint64</code>
depending on the underlying machine architecture.)
</p>

<p class=pp>The key line is near the bottom, the use of 
the special type <code>unsafe.Pointer</code> to convert a
<code>**uintptr</code> into a <code>*uintptr</code>.
Dereferencing that value gives us <code>m.data</code> (actually a <code>*uintptr</code>)
interpreted as a <code>uintptr</code>.
We can assign an arbitrary integer to <code>*m.addr</code>, that changes <code>m.data</code>,
and then we can dereference the integer as <code>*m.data</code>.
In other words, the <code>Mem</code> struct
gives us a way to convert between integers and pointers, just like in C.
There are no races here: this is just something you
can do by importing <code>unsafe</code>.
The <code>Mem</code> wrapper is a bit convoluted&#8212;normally you'd just use <code>unsafe</code> directly&#8212;but
we're going to drop in a different implementation of <code>NewMem</code>
that doesn't rely on <code>unsafe</code>.
</p>


<h3>A Race</h3>

<p class=lp>The current Go representation of slices and interface values
admits a <a href="http://en.wikipedia.org/wiki/Race_condition">data race</a>:
because they are multiword values, if one goroutine reads the value
while another goroutine writes it, the reader might see half of the old
value and half of the new value.
</p>

<p class=pp>Let's provoke the race using interface values.
In Go, an interface value is <a href="http://research.swtch.com/2009/12/go-data-structures-interfaces.html">represented as two words</a>,
a type and a value of that type.
After these declarations:
</p>

<pre class=indent>
var x *uintptr

var i interface{} = (*uintptr)(nil)
var j interface{} = &amp;x
</pre>

<p class=lp>The data structures for <code>i</code> and <code>j</code> look like:
</p>

<center>
<img src="http://research.swtch.com/gorace1.png">
</center>

<p class=lp>Suppose we kick off a goroutine that alternately assigns <code>i</code> and <code>j</code>
to a new interface value <code>k</code>:

<pre class=indent>
var k interface{}

func hammer() {
 for {
  k = i
  k = j
 }
}
</pre>

<p class=lp>After each statement executes, <code>k</code> will look like either <code>i</code> or <code>j</code>, but during the assignment, there will be a moment when <code>k</code> is half <code>i</code> and half <code>j</code>, one of these:
</p>

<center>
<img src="http://research.swtch.com/gorace2.png">
</center>

<p class=lp>
The top case gives us a <code>**uintptr</code> <code>nil</code>, which
we could obtain more easily via legitimate means,
but the bottom case gives us the value <code>&amp;x</code> (actually
a <code>**uintptr</code>) interpreted as a <code>*uintptr</code>.
If we can catch the interface when it looks like the case on the right,
we'll have rederived the conversion we used above via <code>unsafe</code>.
Based on that insight, we can rewrite <code>NewMem</code> without <code>unsafe</code>:
</p>

<pre class=indent>
func NewMem() *Mem {
 fmt.Println("here we go!")

 m := new(Mem)

 var i, j, k interface{}
 i = (*uintptr)(nil)
 j = &amp;m.data

 // Try over and over again until we win the race.
 done := false
 go func(){
  for !done {
   k = i
   k = j
  }
 }()
 for {
  // Is k a non-nil *uintptr?  If so, we got it.
  if p, ok := k.(*uintptr); ok && p != nil {
   m.addr = p
   done = true
   break
  }
 }
 return m
}
</pre>

<p class=pp>The same kind of race happens in all of
Go's mutable multiword structures: slices, interfaces, and strings.
In the case of slices, the trick is to get a pointer from
one slice and a cap from a different one.
In the case of strings, the trick is to get a pointer from
one string and the len from a different one.
(The string race isn't as interesting, because strings
cannot be written to, so it would only let you read memory, not write it.)
</p>

<h3>The Fix</h3>

<p class=lp>The race is fundamentally caused by
being able to observe partial updates to Go's 
multiword values (slices, interfaces, and strings):
the updates are not atomic.
</p>

<p class=pp>The fix is to make the updates atomic.
In Go, the easiest way to do that is to make the
representation a single pointer that points at an
immutable structure.  When the value needs to be
updated, you allocate a new structure, fill it in
completely, and only then change the pointer
to point at it.  This makes the assignment atomic:
another goroutine reading the pointer at the
same time sees either the new data or the old data,
but not a mix, assuming the compiler is careful to
read the pointer just once and then access
both fields using the same pointer value.</p>

<center>
<img src="http://research.swtch.com/gorace3.png">
</center>

<p class=lp>(The red border indicates immutable data.)</p>

<p class=pp>For slices and strings, it makes sense to keep the
multiword representation but put an immutable
&rdquo;pointer and cap&rdquo; stub structure
between the slice and the underlying array.
This keeps the same basic efficiency properties
of slices at the cost of a few extra instructions
on each indexing operation.</p>

<center>
<img src="http://research.swtch.com/gorace4.png">
</center>

<p class=lp>The idea here is to keep a structure with a 
mutable offset and length to support efficient slicing
but replace the pointer with an immutable base+length pair.
Any access to the underlying data must check the final
offset against the immutable <i>cap</i>.
Copying slice values is still not an atomic operation,
but an invalid <i>len</i> will not keep an out-of-bounds
index from being caught.
</p>

<p class=pp>This representation requires a couple
more assembly instructions, because each index
must be checked against two bounds, first the relative len
and then the absolute cap:
</p>

<center>
<table>
<tr height=5><td></tr>
<tr align=center><th colspan=5>Compute <code>x[i]</code> in <code>AX</code></th></tr>
<tr><th align=center><i>Racy</i></th><th></th><th align=center><i>Race-free</i></th></tr>
<tr><td><pre class=smallish
>
LEAL x, SI
MOVL i, CX
CMPL CX, 4(SI)
JGE panic




MOVL 0(SI), DI
MOVL (4*CX)(DI), AX
</pre></td><td width=20></td><td><pre class=smallish
>
LEAL x, BX
MOVL i, CX
CMPL CX, 4(BX)
JGE panic
ADDL 8(BX), CX
MOVL 0(BX), SI
CMPL CX, 4(SI)
JGE panic
MOVL 0(SI), DI
MOVL (4*CX)(DI), AX
</pre></td><td width=20></td><td><pre class=smallish
>
&nbsp;
&nbsp;
// i >= len?
&nbsp;
&nbsp;
// i+off >= cap?
&nbsp;
// &x[0] -> SI
// x[i] (or x[i+off]) -> DI
&nbsp;
</pre></td></tr>
</table>
</center>

<p class=lp>With suitable analysis, an optimizing compiler
could cache <code>0(BX)</code>, <code>4(BX)</code>, <code>8(BX)</code>,
and <code>4(SI)</code>, so in a loop, it is possible that the 
new representation would run at the same speed
as the original.</p>

<p class=pp>An ambitious implementation might
continue to use the current data structures for
slices, interfaces, and strings stored on the stack,
because data on the stack can only be accessed
by the goroutine running on that stack.
(Local variables whose addresses might escape
to other goroutines are already allocated
on the heap automatically, to avoid dangling pointer bugs
after a function returns.)
</p>

<h3>Garbage Collection</h3>

<p class=lp>This fix is feasible only because Go is
a garbage-collected language: we can treat the
red stub structures as immutable and trust that
the garbage collector will recycle the memory only
when nothing points to them anymore.
It's much harder to build a safe language
without a garbage collector to fall back on.
</p>

<h3>Security Implications</h3>

<p class=lp>It is important to note that these races do not make
the current implementations any less secure than they already are.
The races allow clever programmers to subvert Go's memory safety,
but a less clever programmer can still use 
the aptly-named <a href="http://golang.org/doc/go_spec.html#Package_unsafe">package unsafe</a>.
</p>

<p class=pp>
These races only matter if you are trying to build a Go service
that can safely run arbitrary code supplied by untrusted programmers
(and to the best of my knowledge, there are no such services yet).
In that situation, you'd already need to change the implementations
to disable access to the unsafe package and remove or restrict functions like
os.Remove or net.Dial.
Changing the data representations to be race free is just one more 
change you'd have to make.  Now you know, not just that a change
is needed but also what the change is.
</p>

<p class=pp>The races exist because the data representations 
were chosen for performance: the race-free versions introduce
an extra pointer, which carries with it the cost of extra indirection
and extra allocation.  Once the Go implementations are more mature,
we'll be able to evaluate the precise performance impact of using
the race-free data structures and whether to use them always
or only in situations running untrusted code.
</p></p>





<div class="comments">
  <div class="comments-header old">
    <p>(Comments originally posted via Blogger.)</p>
  </div>
  <div class="comments-body">
    <div id="plus-comments">
 <div class="plus-comment"><ul><li class="plus-text">
    <p><a href='http://www.blogger.com/profile/18124558793142592579'>Ed Marshall</a> <span class="comment-when">(February 23, 2010 10:28 AM)</span> <i>These races only matter if you are trying to build a Go service that can safely run arbitrary code supplied by untrusted programmers (and to the best of my knowledge, there are no such services yet).</i><br /><br />*cough*<a href="http://code.google.com/appengine/" rel="nofollow">AppEngine</a>*cough*? :)</p>
 </li></ul></div>
 <div class="plus-comment"><ul><li class="plus-text">
    <p><a href='http://www.blogger.com/profile/00351576818248952080'>stefanha</a> <span class="comment-when">(February 23, 2010 2:26 PM)</span> In your example, is there any guarantee that setting &#39;done&#39; to true will ever be visible to the anonymous goroutine?<br /><br />(Would a compiler be allowed to assume that since there is no synchronization point inside the loop and &#39;done&#39; is not modified in the loop, it does not need to load &#39;done&#39; from memory each loop iteration?)<br /><br />Also, this race seems like an issue for legitimate programs.  If interface{}, slice, and string assignment are not atomic, then robust code accessing such variables concurrently needs to explicitly synchronize in order to work around the current non-atomic implementation. :(</p>
 </li></ul></div>
 <div class="plus-comment me"><ul><li class="plus-text">
    <p><a href="http://swtch.com/~rsc/">Russ Cox</a> <span class="comment-when">(February 23, 2010 4:11 PM)</span> @stefanha: No, there&#39;s no guarantee in the memory model that the use of done is okay.  But I happen to know it works in the current implementation.  ;-)<br /><br />Regarding the memory model, interface{}, slice, and string updates are not guaranteed to be atomic (in fact, no variable access is guaranteed to be atomic), so a correct program <b>should</b> be synchronizing.  That&#39;s a good thing.</p>
 </li></ul></div>
 <div class="plus-comment"><ul><li class="plus-text">
    <p><a href='http://metageek.livejournal.com/'>metageek</a> <span class="comment-when">(March 7, 2010 5:23 AM)</span> Wouldn&#39;t it be expensive to require extra memory allocations for all the interfaces? Instead, the compiler could emit double-word atomic operations like CMPXCHG8B.</p>
 </li></ul></div>
 <div class="plus-comment"><ul><li class="plus-text">
    <p><a href='http://www.blogger.com/profile/06837651109419168637'>Jessta</a> <span class="comment-when">(May 19, 2010 2:51 PM)</span> I found a tiny typo, <br />The text says<br />var i interface{} = &amp;x<br />var j interface{} = (*uintptr)(nil)<br /><br />but the diagrams say,<br />var i interface{} = (*uintptr)(nil)<br />var j interface{} = &amp;x</p>
 </li></ul></div>
 <div class="plus-comment"><ul><li class="plus-text">
    <p><a href='http://www.blogger.com/profile/00397201887944230084'>Santiago Gala</a> <span class="comment-when">(October 16, 2010 7:26 AM)</span> @rsc (regarding done): isn&#39;t done heap allocated in the heap (as it is used from the (potentially long lived) goroutine outside of the function where it is declared, and aren&#39;t those kind of heap accessed treated as &quot;volatile&quot;?</p>
 </li></ul></div>
 <div class="plus-comment me"><ul><li class="plus-text">
    <p><a href="http://swtch.com/~rsc/">Russ Cox</a> <span class="comment-when">(November 9, 2010 7:36 AM)</span> @santiago: Done is in the heap, but Go has no concept of &quot;volatile&quot;.  The compiler might well optimize the accesses to done in the tight loop since it can see that done is not changing.  But I know it doesn&#39;t.<br /><br />Go guarantees almost nothing about memory accesses unless you explicitly synchronize with locks or channels.  http://golang.org/doc/go_mem.html</p>
 </li></ul></div>
 <div class="plus-comment"><ul><li class="plus-text">
    <p><a href='http://www.blogger.com/profile/18233398123137441204'>mk</a> <span class="comment-when">(November 25, 2010 3:08 PM)</span> Good article, but I think Jessta is correct...the first picture in the Race section looks flat-out wrong.<br /><br />Could you fix the picture or switch i/j in the code immediately preceding it?</p>
 </li></ul></div>
 <div class="plus-comment me"><ul><li class="plus-text">
    <p><a href="http://swtch.com/~rsc/">Russ Cox</a> <span class="comment-when">(December 4, 2010 8:41 AM)</span> @mk, @jessta: Fixed the text, thanks.</p>
 </li></ul></div>
 <div class="plus-comment"><ul><li class="plus-text">
    <p>Anonymous <span class="comment-when">(May 11, 2011 10:22 AM)</span> Google recently announced Go support on the App Engine service. Does this vulnerability still exist?</p>
 </li></ul></div>
 <div class="plus-comment me"><ul><li class="plus-text">
    <p><a href="http://swtch.com/~rsc/">Russ Cox</a> <span class="comment-when">(May 23, 2011 6:40 AM)</span> The race described in this post only exists in multithreaded programs.  Go on App Engine is restricted to a single thread (running possibly many goroutines).</p>
 </li></ul></div>
 <div class="plus-comment"><ul><li class="plus-text">
    <p><a href='http://www.blogger.com/profile/17344213294371886790'>jam</a> <span class="comment-when">(July 21, 2011 4:08 AM)</span> This is also hidden behind the language specification, right? So if Google wanted to have their AppEngine compiler emit the 8-byte compare&amp;exchange, or switch to the pointer indirection, it would still run the go code everyone else was running.<br /><br />It is also trivial to rewrite the &quot;done&quot; logic with a non-blocking channel (either via select, or via val, ok, I believe.)<br /><br />I added some counters for how many steps it takes. And certainly GOMAXPROCS=1 it never happens. Otherwise I&#39;ve seen it as fast as:<br />Got it after 2567 attempts, 19 go_steps<br /><br />and as slow as:<br />Got it after 302132 attempts, 87105 go_steps<br /><br />The latter was using a channel synchronization, though, which might make things more &#39;ordered&#39;.</p>
 </li></ul></div>
 <div class="plus-comment"><ul><li class="plus-text">
    <p><a href='http://www.blogger.com/profile/00398184141815003668'>&#9883;</a> <span class="comment-when">(October 4, 2011 2:51 AM)</span> http://stackoverflow.com/questions/7646018/sse-instructions-single-memory-access</p>
 </li></ul></div>
 <div class="plus-comment me"><ul><li class="plus-text">
    <p><a href="http://swtch.com/~rsc/">Russ Cox</a> <span class="comment-when">(October 30, 2011 9:01 AM)</span> &#9883;, very cool, thanks.</p>
 </li></ul></div>
    </div>
  </div>
</div>


      </div>
      
      
    </div>

    
<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
var pageTracker = _gat._getTracker("UA-3319603-2");
pageTracker._initData();
pageTracker._trackPageview();
</script>

    
    
  </body>
</html>
















