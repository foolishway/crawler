<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <title>research!rsc: Zip Files All The Way Down</title>
    <link rel="alternate" type="application/atom+xml" title="research!rsc - Atom" href="http://research.swtch.com/feed.atom" />
    
<meta name="viewport" content="width=device-width, initial-scale=1">
<link href='https://fonts.googleapis.com/css?family=Inconsolata:400,700' rel='stylesheet' type='text/css'>
<script type="text/javascript" src="https://use.typekit.com/skm6yij.js"></script>
<script type="text/javascript">try{Typekit.load();}catch(e){}</script>
<style>
  body {
    padding: 0;
    margin: 0;
    font-size: 100%;
    font-family: 'Minion Pro';
  }
  @media print {
    img {page-break-inside: avoid;}
    div.nosplit {page-break-inside: avoid;}
  }
  img.center {
    display: block;
    margin: 0 auto;
  }
  .pad {
    padding-top: 1em;
    padding-bottom: 1em;
  }
  a.anchor, a.back, a.footnote {
    color: black !important;
    text-decoration: none !important;
  }
  a.back {
    font-size: 50%;
  }
  @media print {
    a.back {display: none;}
  }
  .header {
    height: 1.25em;
    background-color: #dff;
    margin: 0;
    padding: 0.1em 0.1em 0.2em;
    border-top: 1px solid black;
    border-bottom: 1px solid #8ff;
  }
  .header h3 {
    margin: 0;
    padding: 0 2em;
    display: inline-block;
    padding-right: 2em;
    font-style: italic;
    font-size: 90%;
  }
  .rss {
    float: right;
    padding-top: 0.2em;
    padding-right: 2em;
    display: none;
  }
  .toc {
    margin-top: 2em;
  }
  .toc-title {
    font-family: "caflisch-script-pro";
    font-size: 300%;
    line-height: 50%;
  }
  .toc-subtitle {
    display: block;
    margin-bottom: 1em;
    font-size: 83%;
  }
  @media only screen and (max-width: 550px) { .toc-subtitle { display: none; } }
  .header h3 a {
    color: black;
  }
  .header h4 {
    margin: 0;
    padding: 0;
    display: inline-block;
    font-weight: normal;
    font-size: 83%;
  }
  @media only screen and (max-width: 550px) { .header h4 { display: none; } }
  .main {
    padding: 0 2em;
  }
  @media only screen and (max-width: 479px) { .article { font-size: 120%; } }
  .article h1 {
    text-align: center;
    font-size: 200%;
  }
  .copyright {
    font-size: 83%;
  }
  .subtitle {
      font-size: 65%;
  }
  .normal {
    font-size: medium;
    font-weight: normal;
  }
  .when {
    text-align: center;
    font-size: 100%;
    margin: 0;
    padding: 0;
  }
  .when p {
    margin: 0;
    padding: 0;
  }
  .article h2 {
    font-size: 125%;
    padding-top: 0.25em;
  }
  .article h3 {
    font-size: 100%;
  }
  pre {
    margin-left: 4em;
    margin-right: 4em;
  }
  pre, code {
    font-family: 'Inconsolata', monospace;
    font-size: 100%;
  }
  .footer {
    margin-top: 10px;
    font-size: 83%;
    font-family: sans-serif;
  }
  .comments {
    margin-top: 2em;
    background-color: #ffe;
    border-top: 1px solid #aa4;
    border-left: 1px solid #aa4;
    border-right: 1px solid #aa4;
  }
  .comments-header {
    padding: 0 5px 0 5px;
  }
  .comments-header p {
    padding: 0;
    margin: 3px 0 0 0;
  }
  .comments-body {
    padding: 5px 5px 5px 5px;
  }
  #plus-comments {
    border-bottom: 1px dotted #ccc;
  }
  .plus-comment {
    width: 100%;
    font-size: 14px;
    border-top: 1px dotted #ccc;
  }
  .me {
    background-color: #eec;
  }
  .plus-comment ul {
    margin: 0;
    padding: 0;
    list-style: none;
    width: 100%;
    display: inline-block;
  }
  .comment-when {
    color:#999;
    width:auto;
    padding:0 5px;
  }
  .old {
    font-size: 83%;
  }
  .plus-comment ul li {
    display: inline-block;
    vertical-align: top;
    margin-top: 5px;
    margin-bottom: 5px;
    padding: 0;
  }
  .plus-icon {
    width: 45px;
  }
  .plus-img {
    float: left;
    margin: 4px 4px 4px 4px;
    width: 32px;
    height: 32px;
  }
  .plus-comment p {
    margin: 0;
    padding: 0;
  }
  .plus-clear {
    clear: left;
  }
  .toc-when {
    font-size: 83%;
    color: #999;
  }
  .toc {
    list-style: none;
  }
  .toc li {
    margin-bottom: 0.5em;
  }
  .toc-head {
    margin-bottom: 1em !important;
    font-size: 117%;
  }
  .toc-summary {
    margin-left: 2em;
  }
  .favorite {
    font-weight: bold;
  }
  .article p, .article ol {
    line-height: 144%;
  }
  sup, sub {
    vertical-align: baseline;
    position: relative;
    font-size: 83%;
  }
  sup {
    bottom: 1ex;
  }
  sub {
    top: 0.8ex;
  }

  .main {
    position: relative;
    margin: 0 auto;
    padding: 0;
    width: 900px;
  }
  @media only screen and (min-width: 768px) and (max-width: 959px) { .main { width: 708px; } }
  @media only screen and (min-width: 640px) and (max-width: 767px) { .main { width: 580px; } }
  @media only screen and (min-width: 480px) and (max-width: 639px) { .main { width: 420px; } }
  @media only screen and (max-width: 479px) { .main { width: 300px; } }

</style>

  </head>
  <body>
    
<div class="header">
  <h3><a href="/">research!rsc</a></h3>
  <h4>Thoughts and links about programming,
    by <a href="https://swtch.com/~rsc/" rel="author">Russ Cox</a> </h4>
  <a class="rss" href="/feed.atom"><img src="/feed-icon-14x14.png" /></a>
</div>

    <div class="main">
      <div class="article">
        <h1>Zip Files All The Way Down
        
        <div class="normal">
        <div class="when">
          
            Posted on Thursday, March 18, 2010.
            
          
        </div>
        </div>
        </h1>
        
<p><p class=lp>
Stephen Hawking begins <i><a href="http://www.amazon.com/-/dp/0553380168">A Brief History of Time</a></i> with this story:
</p>

<blockquote>
<p class=pp>
A well-known scientist (some say it was Bertrand Russell) once gave a public lecture on astronomy. He described how the earth orbits around the sun and how the sun, in turn, orbits around the center of a vast collection of stars called our galaxy. At the end of the lecture, a little old lady at the back of the room got up and said: &ldquo;What you have told us is rubbish. The world is really a flat plate supported on the back of a giant tortoise.&rdquo; The scientist gave a superior smile before replying, &ldquo;What is the tortoise standing on?&rdquo;  &ldquo;You're very clever, young man, very clever,&rdquo; said the old lady. &ldquo;But it's turtles all the way down!&rdquo;
</p>
</blockquote>

<p class=lp>
Scientists today are pretty sure that the universe is not actually turtles all the way down,
but we can create that kind of situation in other contexts.
For example, here we have <a href="http://www.youtube.com/watch?v=Y-gqMTt3IUg">video monitors all the way down</a>
and <a href="http://www.amazon.com/gp/customer-media/product-gallery/0387900926/ref=cm_ciu_pdp_images_all">set theory books all the way down</a>,
and <a href="http://blog.makezine.com/archive/2009/01/thousands_of_shopping_carts_stake_o.html">shopping carts all the way down</a>.
</p>

<p class=pp>
And here's a computer storage equivalent: 
look inside <a href="http://swtch.com/r.zip"><code>r.zip</code></a>.
It's zip files all the way down:
each one contains another zip file under the name <code>r/r.zip</code>.
(For the die-hard Unix fans, <a href="http://swtch.com/r.tar.gz"><code>r.tar.gz</code></a> is
gzipped tar files all the way down.)
Like the line of shopping carts, it never ends,
because it loops back onto itself: the zip file contains itself!
And it's probably less work to put together a self-reproducing zip file
than to put together all those shopping carts,
at least if you're the kind of person who would read this blog.
This post explains how.
</p>

<p class=pp>
Before we get to self-reproducing zip files, though,
we need to take a brief detour into self-reproducing programs.
</p>

<h3>Self-reproducing programs</h3>

<p class=pp>
The idea of self-reproducing programs dates back to the 1960s.
My favorite statement of the problem is the one Ken Thompson gave in his 1983 Turing Award address:
</p>

<blockquote>
<p class=pp>
In college, before video games, we would amuse ourselves by posing programming exercises. One of the favorites was to write the shortest self-reproducing program. Since this is an exercise divorced from reality, the usual vehicle was FORTRAN. Actually, FORTRAN was the language of choice for the same reason that three-legged races are popular.
</p>

<p class=pp>
More precisely stated, the problem is to write a source program that, when compiled and executed, will produce as output an exact copy of its source. If you have never done this, I urge you to try it on your own. The discovery of how to do it is a revelation that far surpasses any benefit obtained by being told how to do it. The part about &ldquo;shortest&rdquo; was just an incentive to demonstrate skill and determine a winner.
</p>
</blockquote>

<p class=lp>
<b>Spoiler alert!</b>
I agree: if you have never done this, I urge you to try it on your own.
The internet makes it so easy to look things up that it's refreshing
to discover something yourself once in a while.
Go ahead and spend a few days figuring out.  This blog will still be here
when you get back.
(If you don't mind the spoilers, the entire <a href="http://cm.bell-labs.com/who/ken/trust.html">Turing award address</a> is worth reading.)
</p>

<center>
<br><br>
<i>(Spoiler blocker.)</i>
<br>
<a href="http://www.robertwechsler.com/projects.html"><img src="http://research.swtch.com/applied_geometry.jpg"></a>
<br>
<i><a href="http://www.robertwechsler.com/projects.html">http://www.robertwechsler.com/projects.html</a></i>
<br><br>
</center>

<p class=pp>
Let's try to write a Python program that prints itself.
It will probably be a <code>print</code> statement, so here's a first attempt,
run at the interpreter prompt:
</p>

<pre class=indent>
&gt;&gt;&gt; print '<span style="color: #005500">hello</span>'
hello
</pre>

<p class=lp>
That didn't quite work.  But now we know what the program is, so let's print it:
</p>

<pre class=indent>
&gt;&gt;&gt; print "<span style="color: #005500">print 'hello'</span>"
print 'hello'
</pre>

<p class=lp>
That didn't quite work either.  The problem is that when you execute
a simple print statement, it only prints part of itself: the argument to the print.
We need a way to print the rest of the program too.
</p>

<p class=pp>
The trick is to use recursion: you write a string that is the whole program,
but with itself missing, and then you plug it into itself before passing it to print.
</p>

<pre class=indent>
&gt;&gt;&gt; s = '<span style="color: #005500">print %s</span>'; print s % repr(s)
print 'print %s'
</pre>

<p class=lp>
Not quite, but closer: the problem is that the string <code>s</code> isn't actually
the program.  But now we know the general form of the program:
<code>s = '<span style="color: #005500">%s</span>'; print s % repr(s)</code>.
That's the string to use.
</p>

<pre class=indent>
&gt;&gt;&gt; s = '<span style="color: #005500">s = %s; print s %% repr(s)</span>'; print s % repr(s)
s = 's = %s; print s %% repr(s)'; print s % repr(s)
</pre>

<p class=lp>
Recursion for the win.
</p>

<p class=pp>
This form of self-reproducing program is often called a <a href="http://en.wikipedia.org/wiki/Quine_(computing)">quine</a>, 
in honor of the philosopher and logician W. V. O. Quine,
who discovered the paradoxical sentence:
</p>
<blockquote>
&ldquo;Yields falsehood when preceded by its quotation&rdquo;<br>yields falsehood when preceded by its quotation.
</blockquote>
<p class=lp>
The simplest English form of a self-reproducing quine is a command like:
</p>
<blockquote>
Print this, followed by its quotation:<br>&ldquo;Print this, followed by its quotation:&rdquo;
</blockquote>
<p class=lp>
There's nothing particularly special about Python that makes quining possible.
The most elegant quine I know is a Scheme program that is a direct, if somewhat inscrutable, translation of that
sentiment:
</p>
<pre class=indent>
((lambda (x) `<span style="color: #005500">(</span>,x <span style="color: #005500">'</span>,x<span style="color: #005500">)</span>)
'<span style="color: #005500">(lambda (x) `(,x ',x))</span>)
</pre>
<p class=lp>
I think the Go version is a clearer translation, at least as far as the quoting is concerned:
</p>
<pre class=indent>
/* Go quine */
package main
import "<span style="color: #005500">fmt</span>"
func main() {
 fmt.Printf("<span style="color: #005500">%s%c%s%c\n</span>", q, 0x60, q, 0x60)
}
var q = `<span style="color: #005500">/* Go quine */
package main
import "fmt"
func main() {
 fmt.Printf("%s%c%s%c\n", q, 0x60, q, 0x60)
}
var q = </span>`
</pre>
<p class=lp>(I've colored the data literals green throughout to make it clear what is program and what is data.)</p>

<p class=pp>The Go program has the interesting property that, ignoring the pesky newline
at the end, the entire program is the same thing twice (<code>/* Go quine */ ... q = `</code>).
That got me thinking: maybe it's possible to write a self-reproducing program
using only a repetition operator.
And you know what programming language has essentially only a repetition operator?
The language used to encode Lempel-Ziv compressed files
like the ones used by <code>gzip</code> and <code>zip</code>.
</p>

<h3>Self-reproducing Lempel-Ziv programs</h3>

<p class=pp>
Lempel-Ziv compressed data is a stream of instructions with two basic
opcodes: <code>literal(</code><i>n</i><code>)</code> followed by 
<i>n</i> bytes of data means write those <i>n</i> bytes into the
decompressed output,
and <code>repeat(</code><i>d</i><code>,</code> <i>n</i><code>)</code>
means look backward <i>d</i> bytes from the current location
in the decompressed output and copy the <i>n</i> bytes you find there
into the output stream.
</p>

<p class=pp>
The programming exercise, then, is this: write a Lempel-Ziv program
using just those two opcodes that prints itself when run.
In other words, write a compressed data stream that decompresses to itself.
Feel free to assume any reasonable encoding for the <code>literal</code>
and <code>repeat</code> opcodes.
For the grand prize, find a program that decompresses to 
itself surrounded by an arbitrary prefix and suffix,
so that the sequence could be embedded in an actual <code>gzip</code>
or <code>zip</code> file, which has a fixed-format header and trailer.
</p>

<p class=pp>
<b>Spoiler alert!</b>
I urge you to try this on your own before continuing to read.
It's a great way to spend a lazy afternoon, and you have
one critical advantage that I didn't: you know there is a solution.
</p>

<center>
<br><br>
<i>(Spoiler blocker.)</i>
<br>
<a href=""><img src="http://research.swtch.com/the_best_circular_bike(sbcc_sbma_students_roof).jpg"></a>
<br>
<i><a href="http://www.robertwechsler.com/thebest.html">http://www.robertwechsler.com/thebest.html</a></i>
<br><br>
</center>

<p class=lp>By the way, here's <a href="http://swtch.com/r.gz"><code>r.gz</code></a>, gzip files all the way down.

<pre class=indent>
$ gunzip &lt; r.gz &gt; r
$ cmp r r.gz
$
</pre>

<p class=lp>The nice thing about <code>r.gz</code> is that even broken web browsers
that ordinarily decompress downloaded gzip data before storing it to disk
will handle this file correctly!
</p>

<p class=pp>Enough stalling to hide the spoilers.
Let's use this shorthand to describe Lempel-Ziv instructions:
<code>L</code><i>n</i> and <code>R</code><i>n</i> are
shorthand for <code>literal(</code><i>n</i><code>)</code> and
<code>repeat(</code><i>n</i><code>,</code> <i>n</i><code>)</code>,
and the program assumes that each code is one byte.
<code>L0</code> is therefore the Lempel-Ziv no-op;
<code>L5</code> <code>hello</code> prints <code>hello</code>;
and so does <code>L3</code> <code>hel</code> <code>R1</code> <code>L1</code> <code>o</code>.
</p>

<p class=pp>
Here's a Lempel-Ziv program that prints itself.
(Each line is one instruction.)
</p>

<br>
<center>
<table border=0>
<tr><th></th><th width=30></th><th>Code</th><th width=30></th><th>Output</th></tr>
<tr><td align=right><i><span style="font-size: 0.8em;">no-op</span></i></td><td></td><td><code>L0</code></td><td></td><td></td></tr>
<tr><td align=right><i><span style="font-size: 0.8em;">no-op</span></i></td><td></td><td><code>L0</code></td><td></td><td></td></tr>
<tr><td align=right><i><span style="font-size: 0.8em;">no-op</span></i></td><td></td><td><code>L0</code></td><td></td><td></td></tr>
<tr><td align=right><i><span style="font-size: 0.8em;">print 4 bytes</span></i></td><td></td><td><code>L4 <span style="color: #005500">L0 L0 L0 L4</span></code></td><td></td><td><code>L0 L0 L0 L4</code></td></tr>
<tr><td align=right><i><span style="font-size: 0.8em;">repeat last 4 printed bytes</span></i></td><td></td><td><code>R4</code></td><td></td><td><code>L0 L0 L0 L4</code></td></tr>
<tr><td align=right><i><span style="font-size: 0.8em;">print 4 bytes</span></i></td><td></td><td><code>L4 <span style="color: #005500">R4 L4 R4 L4</span></code></td><td></td><td><code>R4 L4 R4 L4</code></td></tr>
<tr><td align=right><i><span style="font-size: 0.8em;">repeat last 4 printed bytes</span></i></td><td></td><td><code>R4</code></td><td></td><td><code>R4 L4 R4 L4</code></td></tr>
<tr><td align=right><i><span style="font-size: 0.8em;">print 4 bytes</span></i></td><td></td><td><code>L4 <span style="color: #005500">L0 L0 L0 L0</span></code></td><td></td><td><code>L0 L0 L0 L0</code></td></tr>
</table>
</center>
<br>

<p class=lp>
(The two columns Code and Output contain the same byte sequence.)
</p>

<p class=pp>
The interesting core of this program is the 6-byte sequence
<code>L4 R4 L4 R4 L4 R4</code>, which prints the 8-byte sequence <code>R4 L4 R4 L4 R4 L4 R4 L4</code>.
That is, it prints itself with an extra byte before and after.
</p>

<p class=pp>
When we were trying to write the self-reproducing Python program,
the basic problem was that the print statement was always longer
than what it printed.  We solved that problem with recursion,
computing the string to print by plugging it into itself.
Here we took a different approach.
The Lempel-Ziv program is
particularly repetitive, so that a repeated substring ends up
containing the entire fragment.  The recursion is in the
representation of the program rather than its execution.
Either way, that fragment is the crucial point.
Before the final <code>R4</code>, the output lags behind the input.
Once it executes, the output is one code ahead.
</p>

<p class=pp>
The <code>L0</code> no-ops are plugged into 
a more general variant of the program, which can reproduce itself
with the addition of an arbitrary three-byte prefix and suffix:
</p>

<br>
<center>
<table border=0>
<tr><th></th><th width=30></th><th>Code</th><th width=30></th><th>Output</th></tr>
<tr><td align=right><i><span style="font-size: 0.8em;">print 4 bytes</span></i></td><td></td><td><code>L4 <span style="color: #005500"><i>aa bb cc</i> L4</span></code></td><td></td><td><code><i>aa bb cc</i> L4</code></td></tr>
<tr><td align=right><i><span style="font-size: 0.8em;">repeat last 4 printed bytes</span></i></td><td></td><td><code>R4</code></td><td></td><td><code><i>aa bb cc</i> L4</code></td></tr>
<tr><td align=right><i><span style="font-size: 0.8em;">print 4 bytes</span></i></td><td></td><td><code>L4 <span style="color: #005500">R4 L4 R4 L4</span></code></td><td></td><td><code>R4 L4 R4 L4</code></td></tr>
<tr><td align=right><i><span style="font-size: 0.8em;">repeat last 4 printed bytes</span></i></td><td></td><td><code>R4</code></td><td></td><td><code>R4 L4 R4 L4</code></td></tr>
<tr><td align=right><i><span style="font-size: 0.8em;">print 4 bytes</span></i></td><td></td><td><code>L4 <span style="color: #005500">R4 <i>xx yy zz</i></span></code></td><td></td><td><code>R4 <i>xx yy zz</i></code></td></tr>
<tr><td align=right><i><span style="font-size: 0.8em;">repeat last 4 printed bytes</span></i></td><td></td><td><code>R4</code></td><td></td><td><code>R4 <i>xx yy zz</i></code></td></tr>
</table>
</center>
<br>

<p class=lp>
(The byte sequence in the Output column is <code><i>aa bb cc</i></code>, then
the byte sequence from the Code column, then <code><i>xx yy zz</i></code>.)
</p>

<p class=pp>
It took me the better part of a quiet Sunday to get this far,
but by the time I got here I knew the game was over
and that I'd won.
From all that experimenting, I knew it was easy to create
a program fragment that printed itself minus a few instructions
or even one that printed an arbitrary prefix 
and then itself, minus a few instructions.
The extra <code>aa bb cc</code> in the output
provides a place to attach such a program fragment.
Similarly, it's easy to create a fragment to attach
to the <code>xx yy zz</code> that prints itself,
minus the first three instructions, plus an arbitrary suffix.
We can use that generality to attach an appropriate 
header and trailer.
</p>

<p class=pp>
Here is the final program, which prints itself surrounded by an
arbitrary prefix and suffix.
<code>[P]</code> denotes the <i>p</i>-byte compressed form of the prefix <code>P</code>;
similarly, <code>[S]</code> denotes the <i>s</i>-byte compressed form of the suffix <code>S</code>.
</p>

<br>
<center>
<table border=0>
<tr><th></th><th width=30></th><th>Code</th><th width=30></th><th>Output</th></tr>
<tr>
 <td align=right><i><span style="font-size: 0.8em;">print prefix</span></i></td>
 <td></td>
 <td><code>[P]</code></td>
 <td></td>
 <td><code>P</code></td>
</tr>
<tr>
 <td align=right><span style="font-size: 0.8em;"><i>print </i>p<i>+1 bytes</i></span></td>
 <td></td>
 <td><code>L</code><span style="font-size: 0.8em;"><i>p</i>+1</span><code> <span style="color: #005500">[P] L</span></code><span style="color: #005500"><span style="font-size: 0.8em;"><i>p</i>+1</span></span><code></code></td>
 <td></td>
 <td><code>[P] L</code><span style="font-size: 0.8em;"><i>p</i>+1</span><code></code></td>
</tr>
<tr>
 <td align=right><span style="font-size: 0.8em;"><i>repeat last </i>p<i>+1 printed bytes</i></span></td>
 <td></td>
 <td><code>R</code><span style="font-size: 0.8em;"><i>p</i>+1</span><code></code></td>
 <td></td>
 <td><code>[P] L</code><span style="font-size: 0.8em;"><i>p</i>+1</span><code></code></td>
</tr>
<tr>
 <td align=right><span style="font-size: 0.8em;"><i>print 1 byte</i></span></td>
 <td></td>
 <td><code>L1 <span style="color: #005500">R</span></code><span style="color: #005500"><span style="font-size: 0.8em;"><i>p</i>+1</span></span><code></code></td>
 <td></td>
 <td><code>R</code><span style="font-size: 0.8em;"><i>p</i>+1</span><code></code></td>
</tr>
<tr>
 <td align=right><span style="font-size: 0.8em;"><i>print 1 byte</i></span></td>
 <td></td>
 <td><code>L1 <span style="color: #005500">L1</span></code></td>
 <td></td>
 <td><code>L1</code></td>
</tr>
<tr>
 <td align=right><i><span style="font-size: 0.8em;">print 4 bytes</span></i></td>
 <td></td>
 <td><code>L4 <span style="color: #005500">R</span></code><span style="color: #005500"><span style="font-size: 0.8em;"><i>p</i>+1</span></span><code><span style="color: #005500"> L1 L1 L4</span></code></td>
 <td></td>
 <td><code>R</code><span style="font-size: 0.8em;"><i>p</i>+1</span><code> L1 L1 L4</code></td>
</tr>
<tr>
 <td align=right><i><span style="font-size: 0.8em;">repeat last 4 printed bytes</span></i></td>
 <td></td>
 <td><code>R4</code></td>
 <td></td>
 <td><code>R</code><span style="font-size: 0.8em;"><i>p</i>+1</span><code> L1 L1 L4</code></td>
</tr>
<tr>
 <td align=right><i><span style="font-size: 0.8em;">print 4 bytes</span></i></td>
 <td></td>
 <td><code>L4 <span style="color: #005500">R4 L4 R4 L4</span></code></td>
 <td></td>
 <td><code>R4 L4 R4 L4</code></td>
</tr>
<tr>
 <td align=right><i><span style="font-size: 0.8em;">repeat last 4 printed bytes</span></i></td>
 <td></td>
 <td><code>R4</code></td>
 <td></td>
 <td><code>R4 L4 R4 L4</code></td>
</tr>
<tr>
 <td align=right><i><span style="font-size: 0.8em;">print 4 bytes</span></i></td>
 <td></td>
 <td><code>L4 <span style="color: #005500">R4 L0 L0 L</span></code><span style="color: #005500"><span style="font-size: 0.8em;"><i>s</i>+1</span></span><code><span style="color: #005500"></span></code></td>
 <td></td>
 <td><code>R4 L0 L0 L</code><span style="font-size: 0.8em;"><i>s</i>+1</span><code></code></td>
</tr>
<tr>
 <td align=right><i><span style="font-size: 0.8em;">repeat last 4 printed bytes</span></i></td>
 <td></td>
 <td><code>R4</code></td>
 <td></td>
 <td><code>R4 L0 L0 L</code><span style="font-size: 0.8em;"><i>s</i>+1</span><code></code></td>
</tr>
<tr>
 <td align=right><i><span style="font-size: 0.8em;">no-op</span></i></td>
 <td></td>
 <td><code>L0</code></td>
 <td></td>
 <td></td>
</tr>
<tr>
 <td align=right><i><span style="font-size: 0.8em;">no-op</span></i></td>
 <td></td>
 <td><code>L0</code></td>
 <td></td>
 <td></td>
</tr>
<tr>
 <td align=right><span style="font-size: 0.8em;"><i>print </i>s<i>+1 bytes</i></span></td>
 <td></td>
 <td><code>L</code><span style="font-size: 0.8em;"><i>s</i>+1</span><code> <span style="color: #005500">R</span></code><span style="color: #005500"><span style="font-size: 0.8em;"><i>s</i>+1</span></span><code><span style="color: #005500"> [S]</span></code></td>
 <td></td>
 <td><code>R</code><span style="font-size: 0.8em;"><i>s</i>+1</span><code> [S]</code></td>
</tr>
<tr>
 <td align=right><span style="font-size: 0.8em;"><i>repeat last </i>s<i>+1 bytes</i></span></td>
 <td></td>
 <td><code>R</code><span style="font-size: 0.8em;"><i>s</i>+1</span><code></code></td>
 <td></td>
 <td><code>R</code><span style="font-size: 0.8em;"><i>s</i>+1</span><code> [S]</code></td>
</tr>
<tr>
 <td align=right><i><span style="font-size: 0.8em;">print suffix</span></i></td>
 <td></td>
 <td><code>[S]</code></td>
 <td></td>
 <td><code>S</code></td>
</tr>

</table>
</center>
<br>

<p class=lp>
(The byte sequence in the Output column is <code><i>P</i></code>, then
the byte sequence from the Code column, then <code><i>S</i></code>.)
</p>


<h3>Self-reproducing zip files</h3>

<p class=pp>
Now the rubber meets the road.
We've solved the main theoretical obstacle to making a self-reproducing
zip file, but there are a couple practical obstacles
still in our way.
</p>

<p class=pp>
The first obstacle is to translate our self-reproducing Lempel-Ziv program,
written in simplified opcodes, into the real opcode encoding.
<a href="http://www.ietf.org/rfc/rfc1951.txt">RFC 1951</a> describes the DEFLATE format used in both gzip and zip: a sequence of blocks, each of which
is a sequence of opcodes encoded using Huffman codes.
Huffman codes assign different length bit strings
to different opcodes,
breaking our assumption above that opcodes have
fixed length.
But wait!
We can, with some care, find a set of fixed-size encodings
that says what we need to be able to express.
</p>

<p class=pp>
In DEFLATE, there are literal blocks and opcode blocks.
The header at the beginning of a literal block is 5 bytes:
</p>

<center>
<img src="http://research.swtch.com/zip1.png">
</center>

<p class=pp>
If the translation of our <code>L</code> opcodes above
are 5 bytes each, the translation of the <code>R</code> opcodes
must also be 5 bytes each, with all the byte counts
above scaled by a factor of 5.
(For example, <code>L4</code> now has a 20-byte argument,
and <code>R4</code> repeats the last 20 bytes of output.)
The opcode block
with a single <code>repeat(20,20)</code> instruction falls well short of
5 bytes:
</p>

<center>
<img src="http://research.swtch.com/zip2.png">
</center>


<p class=lp>Luckily, an opcode block containing two
<code>repeat(20,10)</code> instructions has the same effect and is exactly 5 bytes:
</p>

<center>
<img src="http://research.swtch.com/zip3.png">
</center>

<p class=lp>
Encoding the other sized repeats
(<code>R</code><span style="font-size: 0.8em;"><i>p</i>+1</span> and 
<code>R</code><span style="font-size: 0.8em;"><i>s</i>+1</span>)
takes more effort
and some sleazy tricks, but it turns out that 
we can design 5-byte codes that repeat any amount 
from 9 to 64 bytes.
For example, here are the repeat blocks for 10 bytes and for 40 bytes:
</p>

<center>
<img src="http://research.swtch.com/zip4.png">
<br>
<img src="http://research.swtch.com/zip5.png">
</center>

<p class=lp>
The repeat block for 10 bytes is two bits too short,
but every repeat block is followed by a literal block,
which starts with three zero bits and then padding
to the next byte boundary.
If a repeat block ends two bits short of a byte
but is followed by a literal block, the literal block's
padding will insert the extra two bits.
Similarly, the repeat block for 40 bytes is five bits too long,
but they're all zero bits.
Starting a literal block five bits too late
steals the bits from the padding.
Both of these tricks only work because the last 7 bits of
any repeat block are zero and the bits in the first byte
of any literal block are also zero,
so the boundary isn't directly visible.
If the literal block started with a one bit,
this sleazy trick wouldn't work.
</p>

<p class=pp>The second obstacle is that zip archives (and gzip files)
record a CRC32 checksum of the uncompressed data.
Since the uncompressed data is the zip archive,
the data being checksummed includes the checksum itself.
So we need to find a value <i>x</i> such that writing <i>x</i> into
the checksum field causes the file to checksum to <i>x</i>.
Recursion strikes back.
</p>

<p class=pp>
The CRC32 checksum computation interprets the entire file as a big number and computes
the remainder when you divide that number by a specific constant
using a specific kind of division.
We could go through the effort of setting up the appropriate
equations and solving for <i>x</i>.
But frankly, we've already solved one nasty recursive puzzle
today, and <a href="http://www.youtube.com/watch?v=TQBLTB5f3j0">enough is enough</a>.
There are only four billion possibilities for <i>x</i>:
we can write a program to try each in turn, until it finds one that works.
</p>

<p class=pp>
If you want to recreate these files yourself, there are a
few more minor obstacles, like making sure the tar file is a multiple
of 512 bytes and compressing the rather large zip trailer to
at most 59 bytes so that <code>R</code><span style="font-size: 0.8em;"><i>s</i>+1</span> is
at most <code>R</code><span style="font-size: 0.8em;">64</span>.
But they're just a simple matter of programming.
</p>

<p class=pp>
So there you have it:
<code><a href="http://swtch.com/r.gz">r.gz</a></code> (gzip files all the way down),
<code><a href="http://swtch.com/r.tar.gz">r.tar.gz</a></code> (gzipped tar files all the way down),
and
<code><a href="http://swtch.com/r.zip">r.zip</a></code> (zip files all the way down).
I regret that I have been unable to find any programs
that insist on decompressing these files recursively, ad infinitum.
It would have been fun to watch them squirm, but 
it looks like much less sophisticated
<a href="http://en.wikipedia.org/wiki/Zip_bomb">zip bombs</a> have spoiled the fun.
</p>

<p class=pp>
If you're feeling particularly ambitious, here is
<a href="http://swtch.com/rgzip.go">rgzip.go</a>,
the <a href="http://golang.org/">Go</a> program that generated these files.
I wonder if you can create a zip file that contains a gzipped tar file
that contains the original zip file.
Ken Thompson suggested trying to make a zip file that
contains a slightly larger copy of itself, recursively,
so that as you dive down the chain of zip files
each one gets a little bigger.
(If you do manage either of these, please leave a comment.)
</p>

<br>
<p class=lp><font size=-1>P.S.  I can't end the post without sharing my favorite self-reproducing program: the one-line shell script <code>#!/bin/cat</code></font>.
</p></p>


<div class="comments">
  <div class="comments-header old">
    <p>(Comments originally posted via Blogger.)</p>
  </div>
  <div class="comments-body">
    <div id="plus-comments">
 <div class="plus-comment"><ul><li class="plus-text">
    <p><a href='http://www.blogger.com/profile/15155998626202067226'>Marius Gedminas</a> <span class="comment-when">(March 18, 2010 9:22 AM)</span> It&#39;s <a href="http://www.steike.com/code/useless/zip-file-quine/" rel="nofollow">been done before</a>, but I liked your writeup better.</p>
 </li></ul></div>
 <div class="plus-comment"><ul><li class="plus-text">
    <p><a href='http://www.blogger.com/profile/13040586463566582881'>tafs</a> <span class="comment-when">(March 18, 2010 9:46 AM)</span> In Safari on Mac OS X, with the option &#39;open &quot;safe&quot; files after downloading&#39; set (on by default), it keeps uncompressing and filling up my disk. &quot;safe&quot; indeed &#8230;</p>
 </li></ul></div>
 <div class="plus-comment"><ul><li class="plus-text">
    <p><a href='http://www.blogger.com/profile/05334056755840192313'>Aaron Davies</a> <span class="comment-when">(March 18, 2010 1:59 PM)</span> &gt; #!/bin/cat<br /><br />very nice. i&#39;m kind of partial to &quot;10 LIST&quot;, myself....</p>
 </li></ul></div>
 <div class="plus-comment"><ul><li class="plus-text">
    <p><a href='http://www.blogger.com/profile/00799196834273346407'>Shahms</a> <span class="comment-when">(March 18, 2010 3:46 PM)</span> It&#39;s kind of cheating, but in Python you can write arbitrary self-repeating programs pretty trivially (if you assume the standard library as well):<br /><br />import inspect, sys<br />print inspect.getsource(sys.modules[&#39;__main__&#39;]),</p>
 </li></ul></div>
 <div class="plus-comment"><ul><li class="plus-text">
    <p><a href='http://www.blogger.com/profile/07286591605709358099'>EthanG</a> <span class="comment-when">(March 18, 2010 4:39 PM)</span> @tafs: at least it responds to the cancel button in the downloads window. Mine got to r-962 (963 unpacks) before I killed it, for a total of 3.8MB in the trash.</p>
 </li></ul></div>
 <div class="plus-comment"><ul><li class="plus-text">
    <p><a href='http://www.blogger.com/profile/08373555553758943954'>Nick</a> <span class="comment-when">(March 18, 2010 6:23 PM)</span> <span class='deleted-comment'>This post has been removed by the author.</span></p>
 </li></ul></div>
 <div class="plus-comment"><ul><li class="plus-text">
    <p><a href='http://www.blogger.com/profile/08373555553758943954'>Nick</a> <span class="comment-when">(March 18, 2010 6:25 PM)</span> Perhaps r.zip could contain <b>two</b> copies of itself ...<br /><br />Reminds me of &quot;I cannot be played on a record player X&quot; ...</p>
 </li></ul></div>
 <div class="plus-comment"><ul><li class="plus-text">
    <p><a href='http://www.blogger.com/profile/02968259963578761433'>luc</a> <span class="comment-when">(March 19, 2010 7:18 AM)</span> C&#39;s handling of strings make it slightly annoying but not overly complicated... I&#39;d like to know if anyone can come up with anything shorter (but still in bare C).<br /><br />char qs[160]; char *q(char *s){char *rs=qs;do{if(*s==0x22)*(rs++)=0x5C;*(rs++)=*s;}while(*(s++));return qs;} int main() { char *s = &quot;char qs[160]; char *q(char *s){char *rs=qs;do{if(*s==0x22)*(rs++)=0x5C;*(rs++)=*s;}while(*(s++));return qs;} int main() { char *s = \&quot;%s\&quot;; printf(s, q(s)); }&quot;; printf(s, q(s)); }</p>
 </li></ul></div>
 <div class="plus-comment"><ul><li class="plus-text">
    <p><a href='http://www.blogger.com/profile/02968259963578761433'>luc</a> <span class="comment-when">(March 19, 2010 7:21 AM)</span> Despite slight annoiances related to string handling, a C version is relatively short (closest fragment to an IOCCC candidate I have ever written ;) ) :<br /> <br />char qs[160]; char *q(char *s){char *rs=qs;do{if(*s==0x22)*(rs++)=0x5C;*(rs++)=*s;}while(*(s++));return qs;} int main() { char *s = &quot;char qs[160]; char *q(char *s){char *rs=qs;do{if(*s==0x22)*(rs++)=0x5C;*(rs++)=*s;}while(*(s++));return qs;} int main() { char *s = \&quot;%s\&quot;; printf(s, q(s)); }&quot;; printf(s, q(s)); }</p>
 </li></ul></div>
 <div class="plus-comment"><ul><li class="plus-text">
    <p><a href='http://www.blogger.com/profile/02968259963578761433'>luc</a> <span class="comment-when">(March 19, 2010 7:22 AM)</span> Sorry about the double posting, my browser returned a 404 on the first attempt...</p>
 </li></ul></div>
 <div class="plus-comment"><ul><li class="plus-text">
    <p><a href='http://www.blogger.com/profile/03657901505827400722'>Arachnid</a> <span class="comment-when">(March 19, 2010 9:19 AM)</span> Any hints on how you would write a version that unpacks to a larger copy of itself, given the crc32 issue?</p>
 </li></ul></div>
 <div class="plus-comment me"><ul><li class="plus-text">
    <p><a href="http://swtch.com/~rsc/">Russ Cox</a> <span class="comment-when">(March 19, 2010 10:08 AM)</span> @Arachnid: I suspect you could engineer a sequence that when inserted into a specific place (no matter how many times) would leave the crc unaffected.  But I haven&#39;t done the math.</p>
 </li></ul></div>
 <div class="plus-comment"><ul><li class="plus-text">
    <p><a href='http://www.blogger.com/profile/10246332335331785919'>nickjohnson</a> <span class="comment-when">(March 19, 2010 10:13 AM)</span> That occurred to me shortly afterwards. In principle it shouldn&#39;t be hard, since CRCs only correct for small errors. If the sequence is a set of instructions that print itself twice, you&#39;re sorted!</p>
 </li></ul></div>
 <div class="plus-comment"><ul><li class="plus-text">
    <p><a href='http://www.blogger.com/profile/17506797414755089967'>ajshankar</a> <span class="comment-when">(March 22, 2010 12:40 PM)</span> Fascinating post!<br /><br />Is it possible to create a pure LZ quine (without header or footer) that doesn&#39;t use L0 no-ops?</p>
 </li></ul></div>
 <div class="plus-comment"><ul><li class="plus-text">
    <p><a href='http://www.blogger.com/profile/17506797414755089967'>ajshankar</a> <span class="comment-when">(March 23, 2010 10:39 AM)</span> For the record, the answer is yes, and it can be done with this 16-opcode quine (your easier-to-explain solution was 20):<br /><br />L2 L2 L2<br />L2 L2 L2<br />L2 L2 L2<br />R4,3<br />L4 R4,3 L4 R4,3 L4<br />R4,3<br /><br />And the shortest one I&#39;ve found is 14 opcodes:<br />L0<br />L4 L0 L4 L0 L4<br />L0<br />R4,3<br />L4 R4,3 L4 R4,3 L4<br />R4,3</p>
 </li></ul></div>
 <div class="plus-comment me"><ul><li class="plus-text">
    <p><a href="http://swtch.com/~rsc/">Russ Cox</a> <span class="comment-when">(March 23, 2010 12:05 PM)</span> Neat.  If you start with the core pattern from above you can plug in L1 L1 L1 L1 L1 L1 on both ends instead of L0 L0 L0, but that&#39;s even longer.  <br /><br />The link in the first comment boils down to this 9-instruction one.  It takes advantage of the fact that you can have a repeat length longer than the back-up <br /><br />L0<br />L2 L0 L2<br />L0<br />R2,3<br />L2 R2,3 L2<br />R2,3<br /><br />(R2,3 == go back 2 bytes and copy 3: if the current output ends with x y, that appends x y x.)</p>
 </li></ul></div>
 <div class="plus-comment"><ul><li class="plus-text">
    <p><a href='http://www.blogger.com/profile/17506797414755089967'>ajshankar</a> <span class="comment-when">(March 23, 2010 12:20 PM)</span> Dang, that&#39;s sneaky. I like it. I happened on the 4,3 approach after I got frustrated with trying to find a pure 3,2 solution. But I never thought to do 2,3.</p>
 </li></ul></div>
 <div class="plus-comment"><ul><li class="plus-text">
    <p><a href='http://www.blogger.com/profile/15702832879167847409'>Misi</a> <span class="comment-when">(March 24, 2010 2:56 PM)</span> About CRC: you can modify your program to contain an arbitrary 4 byte sequence somewhere (exactly once). And by modifying these 4 bytes you can make the CRC to be anything.<br />So, you first chose your CRC (for example to be 0x00000000), create your self-reproducing archive, and finally chose that 4 bytes so that CRC is what you want it to be. Thus, avoiding the recursive problem altogether.</p>
 </li></ul></div>
 <div class="plus-comment"><ul><li class="plus-text">
    <p><a href='http://www.blogger.com/profile/08691965407699794724'>k5 user</a> <span class="comment-when">(March 25, 2010 11:54 AM)</span> Late for the game, but recursive zips have been around a very very long time. The anti-virus world has known about them for at least 8 years. One could create a denial of service attack against an AV product that was set to scan compressed files by sending in a zip of death. To combat this, many AV programs stop processing after some configurable &quot;depth&quot; into the file.</p>
 </li></ul></div>
 <div class="plus-comment"><ul><li class="plus-text">
    <p><a href='http://www.blogger.com/profile/15702832879167847409'>Misi</a> <span class="comment-when">(March 27, 2010 9:12 AM)</span> So, here&#39;s what I was talking about:<br /><a href="http://www.cs.elte.hu/~klao/quine/rec_fix.gz" rel="nofollow">rec_fix.gz</a><br /><br />It is a gzip quine, in which the bytes 102-105 are &quot;fix points&quot;. That is, you can change them to whatever you want and the file will still uncompress to itself. (Of course, if you change them the CRC won&#39;t check out.)<br /><br />So, I created this file with CRC in gzip footer set to all 0, and then &quot;reverse computed&quot; the CRC in these four bytes, so that the CRC of the whole file is actually 0. I believe, that based on this idea it is possible to create a file that has a part in the middle, which duplicate itself on gunzipping, while the CRC stays the same. I will post it here when I&#39;m finished.<br /><br />You also might want to look inside this file, as it is based on slightly different idea than yours. For example, I do not depend on &quot;repeat&quot; opcodes being 5 bytes. There&#39;s a &quot;source code&quot; which might be slightly easier to read: <a href="http://www.cs.elte.hu/~klao/quine/rec_fix.lgz" rel="nofollow">rec_fix.lgz</a></p>
 </li></ul></div>
 <div class="plus-comment"><ul><li class="plus-text">
    <p><a href='http://www.blogger.com/profile/15702832879167847409'>Misi</a> <span class="comment-when">(March 27, 2010 3:47 PM)</span> Here it is: <a href="http://www.cs.elte.hu/~klao/quine/rec_exp.gz" rel="nofollow">rec_exp.gz</a>.<br />It has a 32 bytes block which duplicates on uncompressing, and the CRC is always correct (and 0).<br /><br />Unfortunately, the gzip footer also contains a size field, which of course won&#39;t be correct... Until you uncompress the file 27 times. :)  At that point the size of the duplicating block will become 4 gigabytes and the 32 bit size field  is set to be the remainder. (I didn&#39;t check this though. :))<br /><br />While thinking about this, I realized that there is a much simpler (but somewhat cheating) way of creating a &quot;growing gzip quine&quot;. You just duplicate the whole file. As gzip just concatenates the output of concatenated inputs, this will work without paying much attention to size or crc fields. So, here is a file for which gunzipping is the same as concatenating it with itself: <a href="http://www.cs.elte.hu/~klao/quine/rec_dup.gz" rel="nofollow">rec_dup.gz</a><br /><br />(The &quot;sources&quot; are available in the same directory.)</p>
 </li></ul></div>
 <div class="plus-comment"><ul><li class="plus-text">
    <p><a href='http://www.blogger.com/profile/06950680233029380929'>Marc Ruef</a> <span class="comment-when">(May 1, 2010 1:57 AM)</span> Hello,<br /><br />Very interesting research and a great writeup! Keep up the good work.<br /><br />Regards,<br /><br />Marc</p>
 </li></ul></div>
 <div class="plus-comment"><ul><li class="plus-text">
    <p><a href='http://user-unknown.myopenid.com/'>user-unknown</a> <span class="comment-when">(May 1, 2010 3:23 PM)</span> Here is my rather unknown quine:<br />import java.math.BigInteger;<br />/**<br /> (c) Stefan Wagner, GPLv3.0<br />*/<br />class Quine <br />{<br /> public static void main (String [] args)<br /> {<br />  BigInteger b = new BigInteger (&quot;3125672623196693767569686149189009633452 2377871159551965921417137170609691214223 9208376749605139774443708326203800130556 5247549291738666720120851102563432688661 2425053632619026133552590824825360959495 9103568388341399920152904163137391991148 8600579488934249116624219425362354637760 9935667840623358056717110027295132562103 9400252768836739128617742678124740473856 7878670179316536315099060433926849016933 4865116792986969613917692005305319947405 7778267800604078704652663104779321903695 4971735707525104532138973326414147694788 6144049586837524382107377428450195285880 0467794888319592557310425481240448120408 1531669064199685228190893676717975716990 4846241527401973665847012561439332697517 5470668411522967977332908759408086343490 26570&quot;);<br />  int i=0;<br />  for (byte c : b.toByteArray ())<br />  {<br />   ++i;<br />   if (i==159) <br />    System.out.print (b);<br />   System.out.print ((char)c);<br />  }<br /> }<br />}<br />And here my shortest bash-quine:. Yes, that it was. Maybe you didn&#39;t see it - here is how you produce it:<br /><br />touch _; chmod a+x _; ./_</p>
 </li></ul></div>
 <div class="plus-comment"><ul><li class="plus-text">
    <p><a href='http://www.blogger.com/profile/14536525649091496458'>steffenz</a> <span class="comment-when">(May 2, 2010 10:02 AM)</span> In Perl (one line without newline):<br /><br />$q=chr(39);$s=&#39;$q=chr(39);$s=%s%s%s; printf $s,$q,$s,$q;&#39;; printf $s,$q,$s,$q;</p>
 </li></ul></div>
 <div class="plus-comment"><ul><li class="plus-text">
    <p><a href='http://www.blogger.com/profile/14536525649091496458'>steffenz</a> <span class="comment-when">(May 3, 2010 3:18 AM)</span> And the C version is just the same (one line without newline):<br /><br />main(){char q=34; char *s=&quot;main(){char q=34; char *s=%c%s%c; printf(s,q,s,q);}&quot;; printf(s,q,s,q);}</p>
 </li></ul></div>
 <div class="plus-comment"><ul><li class="plus-text">
    <p><a href='http://www.blogger.com/profile/02863876217578588420'>DAGwyn</a> <span class="comment-when">(May 19, 2010 4:31 AM)</span> Hioefukky any antivirus program that stops after some fixed depth then flags the file as malware, rather than treating it as benign.  The main reason is that the hackers will obviously just hide their malware in a nested ZIP file one level deeper than the threshold.</p>
 </li></ul></div>
 <div class="plus-comment"><ul><li class="plus-text">
    <p><a href='http://www.blogger.com/profile/04246309171579657328'>Duncan</a> <span class="comment-when">(May 25, 2010 5:52 AM)</span> &quot;I regret that I have been unable to find any programs that insist on decompressing these files recursively, ad infinitum. It would have been fun to watch them squirm, but it looks like much less sophisticated zip bombs have spoiled the fun.&quot;<br /><br />I&#39;m afraid I have found something that bombs. I thought this was fun so I last week emailed a copy of r.zip to a few colleagues at work. Today the mail servers crashed.<br /><br />Our email is Lotus Notes with McAfee as a virus scanner. It seems that while the desktop version of McAfee only scans a zip file when you unzip it, the server version checks every emailed zip file right the way down...<br /><br />It seems to have taken it a week to fill the disc.</p>
 </li></ul></div>
 <div class="plus-comment"><ul><li class="plus-text">
    <p><a href='http://www.blogger.com/profile/08982759344736367893'>Franz</a> <span class="comment-when">(November 4, 2010 5:25 AM)</span> Computer scientists all the way down<br /><br />Beautiful post, thank you!<br />But I find very misleading the shopping cart metaphor.  The key<br />to a quine is to have something (the program) that contains a<br />representation of itself (the string to be printed). Finally, the act<br />of representing the representation (executing the &#39;print&#39; instruction)<br />makes the representation real (a new program, identical to its<br />parent). There&#39;s no representation of a cart in circle of carts.<br /><br />Other artistic context have the potentiality of making quines, as they<br />blur the boundary between reality and its representation. I&#39;m thinking<br />about some of Escher&#39;s drawings, Pirandello&#39;s &quot;six characters in<br />search of an author&quot;, or Allen&#39;s &quot;Purple Rose of Cairo&quot;.<br /><br />However none of them is a quine, because the artistic work does not<br />represent itself (e.g.&quot;Purple Rose of Cairo&quot;&#39;s representation is a<br />movie about egypt, rather than a Great Depression story).<br /><br />The example that gets closer to a real quine (probably by accident) is<br />&quot;The 13th floor&quot;. (spoiler ahead)<br /><br />In the movie a team of computer scientists in Los Angeles creates a<br />simulation of Los Angeles, only to discover that they are themselves<br />part of a computer simulation made by a team of Los Angeles<br />scientists. The silly authors stop the movie at three levels (in the<br />innermost Los Angeles the year is 1937, and there are no<br />computers). But just wait enough (cpu) time... and it&#39;s going to be<br />computer scientists all the way down!</p>
 </li></ul></div>
 <div class="plus-comment"><ul><li class="plus-text">
    <p><a href='http://www.blogger.com/profile/05334056755840192313'>Aaron Davies</a> <span class="comment-when">(November 4, 2010 5:36 AM)</span> also <i>eXistenZ</i>, and of course now <i>Inception</i>. in books, there&#39;s <i>house of leaves</i> and various things by borjes and nabakov.</p>
 </li></ul></div>
 <div class="plus-comment"><ul><li class="plus-text">
    <p><a href='http://www.blogger.com/profile/07592486691943694724'>AndyMm</a> <span class="comment-when">(November 29, 2010 2:00 PM)</span> In Javascript using Integers.<br /><br />c=[59,21,51,,53,19,62,71,74,0,57,21,58,21,51,53,19,57,20,14,13,19,57,3,3,1,58,3,21,57,54,11,23,<br />43,76,74,65,70,63,6,62,74,71,69,27,64,57,74,27,71,60,61,0,59,51,3,57,53,3,12,8,1,18,59,19];<br />for(a=b=[];a&lt;65;a++)b+=a^3?String.fromCharCode(c[+a]+40):c;<br /><br />using RegExp. Seen people use RegExp in more crazier ways, but here is a simple one.<br /><br />unescape(q=/unescape%28q=%2FQ%2F%5B-1%5D%29.replace%28%2FQ%2F,q%29/[-1]).replace(/Q/,q)</p>
 </li></ul></div>
 <div class="plus-comment"><ul><li class="plus-text">
    <p><a href='http://rhialto.livejournal.com/'>rhialto</a> <span class="comment-when">(January 7, 2011 1:50 PM)</span> &quot;The 13th floor&quot; is a film version of a book by Daniel Galouye, &quot;Simulacron 3&quot;. http://en.wikipedia.org/wiki/Simulacron-3<br />Also made into a film by Fassbinder.</p>
 </li></ul></div>
 <div class="plus-comment"><ul><li class="plus-text">
    <p><a href='http://www.blogger.com/profile/15415271353055520422'>Michael Mol</a> <span class="comment-when">(March 8, 2011 8:44 AM)</span> Over at Rosetta Code, we <a href="http://rosettacode.org/wiki/Quine" rel="nofollow">have a page on Quines</a>.</p>
 </li></ul></div>
 <div class="plus-comment"><ul><li class="plus-text">
    <p><a href='http://www.blogger.com/profile/06551280499853953390'>cacoyi</a> <span class="comment-when">(March 15, 2011 2:47 AM)</span> I&#39;m trying to compile your code so I can modify it to get similar results to this http://www.steike.com/code/useless/zip-file-quine/, but I&#39;m getting these errors:<br /><br />rgzip.go:347: undefined: bytes.Add<br />rgzip.go:700: too many arguments to panic: panic(&quot;cannot encode REP&quot;, n)<br />rgzip.go:710: undefined: flate.NewDeflater<br />rgzip.go:1057: cannot use &amp;f.codebits (type *[19]int) as type []int in function argument<br /><br />being new to go, can you point me in the right direction?</p>
 </li></ul></div>
 <div class="plus-comment"><ul><li class="plus-text">
    <p>Anonymous <span class="comment-when">(April 7, 2011 6:49 AM)</span> @cacoyi:<br />bytes.Add was deleted from language.  Changed to append<br />panic interprets literal as two arguments.  Eleminated &quot;,n&quot;<br />flate.NewDeflater no longer exists.  Changed to flate.NewWriter<br />codebits[numCodes]int drives program crazy.  changed to codebits []int<br /><br />Compiles now.  Don&#39;t know if it works.</p>
 </li></ul></div>
 <div class="plus-comment"><ul><li class="plus-text">
    <p>Anonymous <span class="comment-when">(April 7, 2011 6:59 AM)</span> @cacoyi:<br />bytes.Add was deleted from language.  Changed to append<br />panic interprets literal as two arguments.  Eleminated &quot;,n&quot;<br />flate.NewDeflater no longer exists.  Changed to flate.NewWriter<br />codebits[numCodes]int drives program crazy.  changed to codebits []int<br /><br />Compiles now.  Don&#39;t know if it works.</p>
 </li></ul></div>
 <div class="plus-comment"><ul><li class="plus-text">
    <p>Anonymous <span class="comment-when">(June 10, 2011 7:39 PM)</span> I took your advice and tried to create one myself. I tried it with php, and it turned out to be trivial.<br /><br />Simply put:<br /><br />Will do it.<br /><br />But I guess you are trying to make a different point.</p>
 </li></ul></div>
 <div class="plus-comment"><ul><li class="plus-text">
    <p>Anonymous <span class="comment-when">(June 10, 2011 7:40 PM)</span> I took your advice and tried to create one myself. I tried it with php, and it turned out to be trivial.<br /><br />Simply put:<br />&lt;? php<br /> <br /> print (file_get_contents(__FILE__));<br />?&gt; <br />Will do it.<br /><br />But I guess you are trying to make a different point.</p>
 </li></ul></div>
 <div class="plus-comment"><ul><li class="plus-text">
    <p><a href='http://www.blogger.com/profile/06241580365483553926'>Kela</a> <span class="comment-when">(July 17, 2011 9:48 AM)</span> Unix Shell:<br />z=\&#39; a=&#39;z=\\$z a=$z$a$z\; eval echo \$a&#39;; eval echo $a</p>
 </li></ul></div>
 <div class="plus-comment"><ul><li class="plus-text">
    <p>Cody <span class="comment-when">(November 21, 2011 5:52 AM)</span> I wrote about this the other day. As for the C versions, some of them have the problem of non compliance of the C standard (say, no int for main&#39;s return type). Another example is the implicit declaration of printf (no #include &lt;stdio.h&gt;)<br /><br />So I fixed that stuff too (hopefully it pastes ok):<br /><br />#include &lt;stdio.h&gt;<br />int main(){ char*p=&quot;#include &lt;stdio.h&gt;%cint main(){ char*p=%c%s%c; printf(p,10,34,p,34,10,10); return 0; %c}%c&quot;; printf(p,10,34,p,34,10,10); return 0;<br />}<br /><br />wc ran on that source file, for what its worth :<br /><br />3  16 173 quine2.c<br />(For windows folks, that means : 3 lines, 16 words, 173 characters)<br /><br />As for the person who tried it in php and included the file directly, indeed the point is very different. That&#39;s cheating and isn&#39;t a quine. If you include the file by reading it in in the source, that&#39;s hardly (as you point out) a challenge.<br /><br />As for the author of this post, thanks for this - was interesting and fun. (I found it by way of looking up the zip file format for some reason I can&#39;t remember now; was I think referred to from wiki.)</p>
 </li></ul></div>

<div class="plus-comment"><ul><li class="plus-text">
    <p>Cody <span class="comment-when">(November 21, 2011 6:04 AM)</span> One other thing I forgot to reply to.<br/><br/>
About antiviruses and recursive zip files: it's generally, at least from what I've seen, a user defined variable. Its not hard coded. So its not really flawed. The fact is that there's some things that will be hard to find out if it's ok or not on first look (and some av's may report it ok when others not, and so on). Even antidebugging tricks can make an antivirus detection engine think its malware when its not. Of course, the more 'scary' trick was piggybacking - that's when the malware would infect files/whatever as the av engine was scanning them.<br/><br/>
Still, false positives are just as bad as a false negatives (another similar thing - badly configured firewalls can be really bad) when it comes to security. That's just how it goes, and we all have to make the best of it some times. Of course, if a file is zipped up many times it may bring about suspicion, and perhaps it should. What do they have to hide? So in the end it is a matter of using some common sense, understanding how things work, and antiviruses along with it does a pretty good job if all work together.</p>
 </li></ul></div>

 <div class="plus-comment"><ul><li class="plus-text">
    <p><a href='http://www.cs.berkeley.edu/%7Edaw/'>David Wagner</a> <span class="comment-when">(January 28, 2012 10:10 PM)</span> This is awesome!  Thank you for posting this puzzle.<br /><br />I had fun looking at the simplified version, where you are only allowed L<i>n</i> and R<i>n</i> opcodes (R<i>n,m</i> not allowed).  I was curious what was the shortest quine.<br /><br />For fun, I decided to throw a SAT solver at it.  Here&#39;s what I found.  The shortest quine is 16 bytes long:<br />L0 L0 L0 L2 L0 L0 L2 L0 L2 R3 R2 L2 R3 R2 R3 R2<br />Or, in parsed form:<br />L0<br />L0<br />L0<br />L2 L0 L0    <br />L2 L0 L2    <br />R3          <br />R2          <br />L2 R3 R2    <br />R3          <br />R2          <br /><br />Assuming my SAT code is correct, there is no shorter quine.  There is also no quine of length 17.  However, there appear to be quines of all larger lengths.<br /><br />If you&#39;re curious how I encoded this as SAT, here&#39;s the approach I took to search for a quine of length <i>n</i>:<br /><br />I defined a <i>n</i>-byte array of unknowns, call it In, so In(<i>i</i>) is the <i>i</i>th byte of the input.  (We&#39;ll add constraints to force it to also be the <i>i</i>th byte of the output.)<br /><br />Then, I defined a (<i>n</i>+1) x (<i>n</i>+1) array of boolean unknowns, active(.,.), where<br /><br />active(<i>i</i>,<i>j</i>) is true if In(0..<i>i</i>-1) is a well-parsed sequence of bytes (i.e., it doesn&#39;t end in the middle of an unfinished string literal) and decompressing In(0..<i>i</i>-1) produces the output In(0..<i>j</i>-1).<br /><br />It is not too difficult to write down a set of constraints that define the entries of active(.,.) in terms of the entries of In(.).  I then emit constraints to require active(0,0) be true, and to require that active(<i>n</i>, <i>n</i>) be true.  I then invoke the SAT solver to find a solution that respects all of these constraints.<br /><br />This was fun!  Thank you for sharing this puzzle.</p>
 </li></ul></div>


    </div>
  </div>
</div>

      </div>
      
      
    </div>

    
<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
var pageTracker = _gat._getTracker("UA-3319603-2");
pageTracker._initData();
pageTracker._trackPageview();
</script>

    
    
  </body>
</html>
















