<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <title>research!rsc: Go Proposal Process: Enabling Experiments (Go Proposals, Part 5)</title>
    <link rel="alternate" type="application/atom+xml" title="research!rsc - Atom" href="http://research.swtch.com/feed.atom" />
    
<meta name="viewport" content="width=device-width, initial-scale=1">
<link href='https://fonts.googleapis.com/css?family=Inconsolata:400,700' rel='stylesheet' type='text/css'>
<script type="text/javascript" src="https://use.typekit.com/skm6yij.js"></script>
<script type="text/javascript">try{Typekit.load();}catch(e){}</script>
<style>
  body {
    padding: 0;
    margin: 0;
    font-size: 100%;
    font-family: 'Minion Pro';
  }
  @media print {
    img {page-break-inside: avoid;}
    div.nosplit {page-break-inside: avoid;}
  }
  img.center {
    display: block;
    margin: 0 auto;
  }
  .pad {
    padding-top: 1em;
    padding-bottom: 1em;
  }
  a.anchor, a.back, a.footnote {
    color: black !important;
    text-decoration: none !important;
  }
  a.back {
    font-size: 50%;
  }
  @media print {
    a.back {display: none;}
  }
  .header {
    height: 1.25em;
    background-color: #dff;
    margin: 0;
    padding: 0.1em 0.1em 0.2em;
    border-top: 1px solid black;
    border-bottom: 1px solid #8ff;
  }
  .header h3 {
    margin: 0;
    padding: 0 2em;
    display: inline-block;
    padding-right: 2em;
    font-style: italic;
    font-size: 90%;
  }
  .rss {
    float: right;
    padding-top: 0.2em;
    padding-right: 2em;
    display: none;
  }
  .toc {
    margin-top: 2em;
  }
  .toc-title {
    font-family: "caflisch-script-pro";
    font-size: 300%;
    line-height: 50%;
  }
  .toc-subtitle {
    display: block;
    margin-bottom: 1em;
    font-size: 83%;
  }
  @media only screen and (max-width: 550px) { .toc-subtitle { display: none; } }
  .header h3 a {
    color: black;
  }
  .header h4 {
    margin: 0;
    padding: 0;
    display: inline-block;
    font-weight: normal;
    font-size: 83%;
  }
  @media only screen and (max-width: 550px) { .header h4 { display: none; } }
  .main {
    padding: 0 2em;
  }
  @media only screen and (max-width: 479px) { .article { font-size: 120%; } }
  .article h1 {
    text-align: center;
    font-size: 200%;
  }
  .copyright {
    font-size: 83%;
  }
  .subtitle {
      font-size: 65%;
  }
  .normal {
    font-size: medium;
    font-weight: normal;
  }
  .when {
    text-align: center;
    font-size: 100%;
    margin: 0;
    padding: 0;
  }
  .when p {
    margin: 0;
    padding: 0;
  }
  .article h2 {
    font-size: 125%;
    padding-top: 0.25em;
  }
  .article h3 {
    font-size: 100%;
  }
  pre {
    margin-left: 4em;
    margin-right: 4em;
  }
  pre, code {
    font-family: 'Inconsolata', monospace;
    font-size: 100%;
  }
  .footer {
    margin-top: 10px;
    font-size: 83%;
    font-family: sans-serif;
  }
  .comments {
    margin-top: 2em;
    background-color: #ffe;
    border-top: 1px solid #aa4;
    border-left: 1px solid #aa4;
    border-right: 1px solid #aa4;
  }
  .comments-header {
    padding: 0 5px 0 5px;
  }
  .comments-header p {
    padding: 0;
    margin: 3px 0 0 0;
  }
  .comments-body {
    padding: 5px 5px 5px 5px;
  }
  #plus-comments {
    border-bottom: 1px dotted #ccc;
  }
  .plus-comment {
    width: 100%;
    font-size: 14px;
    border-top: 1px dotted #ccc;
  }
  .me {
    background-color: #eec;
  }
  .plus-comment ul {
    margin: 0;
    padding: 0;
    list-style: none;
    width: 100%;
    display: inline-block;
  }
  .comment-when {
    color:#999;
    width:auto;
    padding:0 5px;
  }
  .old {
    font-size: 83%;
  }
  .plus-comment ul li {
    display: inline-block;
    vertical-align: top;
    margin-top: 5px;
    margin-bottom: 5px;
    padding: 0;
  }
  .plus-icon {
    width: 45px;
  }
  .plus-img {
    float: left;
    margin: 4px 4px 4px 4px;
    width: 32px;
    height: 32px;
  }
  .plus-comment p {
    margin: 0;
    padding: 0;
  }
  .plus-clear {
    clear: left;
  }
  .toc-when {
    font-size: 83%;
    color: #999;
  }
  .toc {
    list-style: none;
  }
  .toc li {
    margin-bottom: 0.5em;
  }
  .toc-head {
    margin-bottom: 1em !important;
    font-size: 117%;
  }
  .toc-summary {
    margin-left: 2em;
  }
  .favorite {
    font-weight: bold;
  }
  .article p, .article ol {
    line-height: 144%;
  }
  sup, sub {
    vertical-align: baseline;
    position: relative;
    font-size: 83%;
  }
  sup {
    bottom: 1ex;
  }
  sub {
    top: 0.8ex;
  }

  .main {
    position: relative;
    margin: 0 auto;
    padding: 0;
    width: 900px;
  }
  @media only screen and (min-width: 768px) and (max-width: 959px) { .main { width: 708px; } }
  @media only screen and (min-width: 640px) and (max-width: 767px) { .main { width: 580px; } }
  @media only screen and (min-width: 480px) and (max-width: 639px) { .main { width: 420px; } }
  @media only screen and (max-width: 479px) { .main { width: 300px; } }

</style>

  </head>
  <body>
    
<div class="header">
  <h3><a href="/">research!rsc</a></h3>
  <h4>Thoughts and links about programming,
    by <a href="https://swtch.com/~rsc/" rel="author">Russ Cox</a> </h4>
  <a class="rss" href="/feed.atom"><img src="/feed-icon-14x14.png" /></a>
</div>

    <div class="main">
      <div class="article">
        <h1>Go Proposal Process: Enabling Experiments
        
        <div class="subtitle">(<i><a href="proposals">Go Proposals</a>, Part 5</i>)</div>
        
        <div class="normal">
        <div class="when">
          
            Posted on Monday, September 23, 2019.
            
           <font size="-1"><a href="proposals-experiment.pdf">PDF</a></font>
        </div>
        </div>
        </h1>
        

<p>
[<i>I’ve been thinking a lot recently about the
<a href="https://golang.org/s/proposal">Go proposal process</a>,
which is the way we propose, discuss, and decide
changes to Go itself.
Like <a href="https://blog.golang.org/experiment">nearly everything about Go</a>,
the proposal process is an experiment,
so it makes sense to reflect on what we’ve
learned and try to improve it.
This post is the fifth in <a href="https://research.swtch.com/proposals">a series of posts</a>
about what works well and,
more importantly,
what we might want to change.</i>]

<p>
Communicating a proposed change precisely and clearly is difficult,
on both sides of the communication.
Technical details
are easy to write and to read incorrectly without realizing it,
and implications are easy to misunderstand.
After all, this is why our programs are filled with bugs.
The best way I know to address this problem for a large change
is to implement it and try it.
(See my GopherCon talk, “<a href="https://blog.golang.org/experiment">Experiment, Simplify, Ship</a>.”)

<p>
Being able to try out a possible new feature,
whether it is in the design draft or the final proposal stage,
is extremely helpful for understanding the feature.
Understanding the feature is in turn critical for being able
to give meaningful, concrete feedback.
Anything we can do to help everyone (including the authors)
understand proposals better sooner is a way to improve the overall process.
<a class=anchor href="#proto"><h2 id="proto">Prototypes</h2></a>


<p>
Multiple contributors at the summit brought up the Go modules proposal
as an example of how much it helped to have a working prototype:
being able to learn about modules by trying <code>vgo</code>
was very helpful for them,
instead of having to imagine the experience by reading documents alone.
There is a balance to be struck here.
It certainly helped to have <code>vgo</code> available for the initial public discussion,
but other problems were caused by waiting until then to discuss
the ideas publicly.
We published the design drafts last summer without working
prototypes specifically to avoid that mistake, of discussing ideas too late.
But, when we get farther along,
especially with generics,
it will also be important to make working prototypes
available for experimentation well before we reach the final proposal decision.
<a class=anchor href="#short"><h2 id="short">Short Experiments</h2></a>


<p>
We had already recognized the need for experimenting
before making a final decision,
which motivated the
<a href="https://blog.golang.org/go2-here-we-come">procedure we introduced</a>
for language changes starting in Go 1.13.
In short, that procedure is:
have an initial discussion about whether to move forward;
if so, check in the implementation at the start of the three-month development cycle;
have a final discussion at the end of the development cycle;
if the feature is not ready yet, remove it for the freeze
and the release; repeat if needed.
This three-month window worked reasonably well for
small features like signed shift counts.
For larger features, it is clear that three months is too short
and a different approach providing a longer window is needed.
We spent a while at the summit talking about possible
ways to make features available on a longer-term experimental basis,
and the various concerns that must be balanced.
<a class=anchor href="#long"><h2 id="long">Longer, Opt-In Experiments</h2></a>


<p>
For <code>vgo</code> the way to opt in to experimenting
was to download and run a separate command,
not the <code>go</code> command.
And <code>vgo</code> could “compile out” use of modules by preparing a <code>vendor</code> directory.
For <code>try</code>, Robert Griesemer wrote a simple converter, <code>tryhard</code>,
that looked for opportunities to add <code>try</code> expressions;
we intended to have a <code>tryhard</code> <code>-u</code> that removed them as well,
so that people who wanted to experiment with <code>try</code> could write code
using it and
“compile” that down to pure Go when publishing it.
A separate command is heavy-weight but has the significant
benefit of being independent of the underlying toolchain,
the same as non-experimental tools like <code>goyacc</code>
and <code>stringer</code>.

<p>
There is also a mechanism for experiments within the main toolchain.
The environment variable
<code>GOEXPERIMENT</code> can be set during the toolchain build
(that is, during <code>all.bash</code> or <code>make.bash</code>)
to enable unfinished or experimental features
in that toolchain.
This mechanism restricts the use of these features
to developers who build the Go toolchain itself from source,
which is not most users.
Indeed, <code>GOEXPERIMENT</code> is intended mainly for
use by the developers of those in-progress features,
typically invisible implementation details,
not semantic language changes.
(For example, use of register <code>RBP</code> to hold a frame pointer
on x86-64 was added as an experiment flag until we were
sure it was robust enough to enable by default.)

<p>
As a lighter-weight mechanism,
people at the contributor summit raised the idea of
opting in to an experimental feature
with a line in in <code>go.mod</code> or with a Python-like special import
(<code>import</code> <code>_</code> <code>"experimental/try"</code>).
<a class=anchor href="#restrict"><h2 id="restrict">Restricting Experiments</h2></a>


<p>
The biggest question about experimental
features is how to restrict them—that is, how to contain their impact—to
ensure the overall ecosystem does not
depend on them before they are stable.
On the one hand, you want to make it possible
for people to try the feature in real-world use cases,
meaning production uses.
So you want to be using an otherwise release-quality toolchain
where the only change is that the feature is added.
(Separate tools and the <code>GOEXPERIMENT</code> settings both make this possible.)
On the other hand, any production usage creates
a reliance on the feature that will translate
into breakage if the feature is changed or removed.
The ability to gather production experience with the feature
and the stability of the usual Go compatibility promise
are in direct conflict.
Even if users understand that there is no
compatibility for an experimental feature,
it still hurts them when their code breaks.

<p>
A critical aspect of containing experimental
features is thinking about how they interact with
dependencies.
Is it okay for a dependency to opt in to
using an experimental feature?
If the feature is removed, that might break
packages that didn't even realize they depended on it.
And what about tools?
Do editing environments or tools like <code>gopls</code> have to
understand the experimental feature as well?
It gets complicated fast.

<p>
We especially want to avoid breaking people who don't
even know they were using the feature.
Since the feature is experimental and <i>will</i> break,
that means trying to prevent a situation where
people are using it without knowing,
or where people are coerced into using it
by an important dependency.
Avoiding this problem is the main reason
that we have used heavier weight mechanisms
like separate tools or the <code>GOEXPERIMENT</code> flag
to limit the scope of experiments in Go.

<p>
At the contributor summit,
a few contributors with Rust experience said that a while back
many Rust crates simply required the use of
Rust's unstable toolchain, which has in-progress features enabled.
They also said that the situation has improved,
in part because of attention to the problem
and in part because some of the most important in-progress features
were completed and moved into the stable toolchain.

<p>
One problem we had in Go along similar lines was in
the introduction of experimental vendoring support in Go 1.5.
For that release, vendoring had to be enabled
using the <code>GO15VENDOREXPERIMENT=on</code>
environment variable. The Go 1.6 release changed
the default to be opt-out, and Go 1.7 removed the setting entirely.
But that meant projects with a significant number
of developers had to tell each developer to opt in
in order for the project to use it,
which made it harder to try and adopt than we realized.
Understanding this problem is one of the reasons that
modules have defaulted to an “automatic”
mode triggered by the presence of a <code>go.mod</code> file
for the past couple releases.
Although the <code>GO111MODULE</code> variable allows finer-grained control,
it can be ignored by most users.
Want to try modules? Create a <code>go.mod</code> (which you needed to do anyway).
<a class=anchor href="#todo"><h2 id="todo">What To Do</h2></a>


<p>
I don't see a <a href="http://worrydream.com/refs/Brooks-NoSilverBullet.pdf">silver bullet</a> here.
We will probably have to decide for each change what the
appropriate experiment mechanism is.

<p>
It is critically important to allow users to experiment with
proposed features, to better understand them and to
find problems early.
Significant changes should continue to be backed by prototypes.

<p>
On the other hand, it is equally (if not more) important
that experimental features not become unchangeable
de facto features due to dependency network effects.
A lightweight mechanism
(like <code>import</code> <code>_</code> <code>"experimental/try"</code>)
may be appropriate when a feature is near final
and we are willing to support the current semantics in all future toolchains.
Before then, such a mechanism is inappropriate:
all it takes is one important dependency to make the
feature impossible to change.

<p>
The most likely answer to the right way to experiment is “it depends.”
A trivial, well understood change like binary number literals
is probably fine to do using the <a href="#short">“short” release cycle</a> mechanism.
Larger changes like modules or <code>try</code> (or generics!)
probably need external tools or very careful use of
<code>GOEXPERIMENT</code> to avoid unwanted network effects.

<p>
Even so, we should be careful to remember to provide for
some experimentation mechanism for any non-trivial change,
well before that change leaves the <a href="proposals-discuss">design draft stage</a>
and becomes a formal proposal.
<a class=anchor href="#next"><h2 id="next">Next</h2></a>


<p>
Again, this is the fourth post <a href="proposals">in a series of posts</a>
thinking and brainstorming about the Go proposal process.
Everything about these posts is very rough.
The point of posting this series—thinking out loud
instead of thinking quietly—is so that
anyone who is interested can join the thinking.

<p>
I encourage feedback, whether in the form of comments on these posts,
comments on the newly filed issues,
mail to rsc@golang.org,
or your own blog posts (please leave links in the comments).
Thanks for taking the time to read these and think with me.

<p>
It's been a month since the last post, because
I was away for three weeks with my kids before school started
and then spent last week catching up.
I have at least two more posts planned.

<p>
The <a href="proposals-representation">next post</a> is about overall representation in the
proposal process and the Go language effort more broadly:
who is here, who is missing, and what can we do about it?
      </div>
      
      
      <div id="disqus_thread"></div>
      <script>
      var disqus_config = function () {
          this.page.url = "https://research.swtch.com/proposals-experiment";  
          this.page.identifier = "blog/proposals-experiment"; 
      };
      (function() { 
          var d = document, s = d.createElement('script');
          s.src = '//swtch.disqus.com/embed.js';
          s.setAttribute('data-timestamp', +new Date());
          (d.head || d.body).appendChild(s);
      })();
      </script>
      <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
      </div>
      
    </div>

    
<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
var pageTracker = _gat._getTracker("UA-3319603-2");
pageTracker._initData();
pageTracker._trackPageview();
</script>

    
    
  </body>
</html>
















