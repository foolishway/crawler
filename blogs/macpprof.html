<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <title>research!rsc: Hacking the OS X Kernel for Fun and Profiles</title>
    <link rel="alternate" type="application/atom+xml" title="research!rsc - Atom" href="http://research.swtch.com/feed.atom" />
    
<meta name="viewport" content="width=device-width, initial-scale=1">
<link href='https://fonts.googleapis.com/css?family=Inconsolata:400,700' rel='stylesheet' type='text/css'>
<script type="text/javascript" src="https://use.typekit.com/skm6yij.js"></script>
<script type="text/javascript">try{Typekit.load();}catch(e){}</script>
<style>
  body {
    padding: 0;
    margin: 0;
    font-size: 100%;
    font-family: 'Minion Pro';
  }
  @media print {
    img {page-break-inside: avoid;}
    div.nosplit {page-break-inside: avoid;}
  }
  img.center {
    display: block;
    margin: 0 auto;
  }
  .pad {
    padding-top: 1em;
    padding-bottom: 1em;
  }
  a.anchor, a.back, a.footnote {
    color: black !important;
    text-decoration: none !important;
  }
  a.back {
    font-size: 50%;
  }
  @media print {
    a.back {display: none;}
  }
  .header {
    height: 1.25em;
    background-color: #dff;
    margin: 0;
    padding: 0.1em 0.1em 0.2em;
    border-top: 1px solid black;
    border-bottom: 1px solid #8ff;
  }
  .header h3 {
    margin: 0;
    padding: 0 2em;
    display: inline-block;
    padding-right: 2em;
    font-style: italic;
    font-size: 90%;
  }
  .rss {
    float: right;
    padding-top: 0.2em;
    padding-right: 2em;
    display: none;
  }
  .toc {
    margin-top: 2em;
  }
  .toc-title {
    font-family: "caflisch-script-pro";
    font-size: 300%;
    line-height: 50%;
  }
  .toc-subtitle {
    display: block;
    margin-bottom: 1em;
    font-size: 83%;
  }
  @media only screen and (max-width: 550px) { .toc-subtitle { display: none; } }
  .header h3 a {
    color: black;
  }
  .header h4 {
    margin: 0;
    padding: 0;
    display: inline-block;
    font-weight: normal;
    font-size: 83%;
  }
  @media only screen and (max-width: 550px) { .header h4 { display: none; } }
  .main {
    padding: 0 2em;
  }
  @media only screen and (max-width: 479px) { .article { font-size: 120%; } }
  .article h1 {
    text-align: center;
    font-size: 200%;
  }
  .copyright {
    font-size: 83%;
  }
  .subtitle {
      font-size: 65%;
  }
  .normal {
    font-size: medium;
    font-weight: normal;
  }
  .when {
    text-align: center;
    font-size: 100%;
    margin: 0;
    padding: 0;
  }
  .when p {
    margin: 0;
    padding: 0;
  }
  .article h2 {
    font-size: 125%;
    padding-top: 0.25em;
  }
  .article h3 {
    font-size: 100%;
  }
  pre {
    margin-left: 4em;
    margin-right: 4em;
  }
  pre, code {
    font-family: 'Inconsolata', monospace;
    font-size: 100%;
  }
  .footer {
    margin-top: 10px;
    font-size: 83%;
    font-family: sans-serif;
  }
  .comments {
    margin-top: 2em;
    background-color: #ffe;
    border-top: 1px solid #aa4;
    border-left: 1px solid #aa4;
    border-right: 1px solid #aa4;
  }
  .comments-header {
    padding: 0 5px 0 5px;
  }
  .comments-header p {
    padding: 0;
    margin: 3px 0 0 0;
  }
  .comments-body {
    padding: 5px 5px 5px 5px;
  }
  #plus-comments {
    border-bottom: 1px dotted #ccc;
  }
  .plus-comment {
    width: 100%;
    font-size: 14px;
    border-top: 1px dotted #ccc;
  }
  .me {
    background-color: #eec;
  }
  .plus-comment ul {
    margin: 0;
    padding: 0;
    list-style: none;
    width: 100%;
    display: inline-block;
  }
  .comment-when {
    color:#999;
    width:auto;
    padding:0 5px;
  }
  .old {
    font-size: 83%;
  }
  .plus-comment ul li {
    display: inline-block;
    vertical-align: top;
    margin-top: 5px;
    margin-bottom: 5px;
    padding: 0;
  }
  .plus-icon {
    width: 45px;
  }
  .plus-img {
    float: left;
    margin: 4px 4px 4px 4px;
    width: 32px;
    height: 32px;
  }
  .plus-comment p {
    margin: 0;
    padding: 0;
  }
  .plus-clear {
    clear: left;
  }
  .toc-when {
    font-size: 83%;
    color: #999;
  }
  .toc {
    list-style: none;
  }
  .toc li {
    margin-bottom: 0.5em;
  }
  .toc-head {
    margin-bottom: 1em !important;
    font-size: 117%;
  }
  .toc-summary {
    margin-left: 2em;
  }
  .favorite {
    font-weight: bold;
  }
  .article p, .article ol {
    line-height: 144%;
  }
  sup, sub {
    vertical-align: baseline;
    position: relative;
    font-size: 83%;
  }
  sup {
    bottom: 1ex;
  }
  sub {
    top: 0.8ex;
  }

  .main {
    position: relative;
    margin: 0 auto;
    padding: 0;
    width: 900px;
  }
  @media only screen and (min-width: 768px) and (max-width: 959px) { .main { width: 708px; } }
  @media only screen and (min-width: 640px) and (max-width: 767px) { .main { width: 580px; } }
  @media only screen and (min-width: 480px) and (max-width: 639px) { .main { width: 420px; } }
  @media only screen and (max-width: 479px) { .main { width: 300px; } }

</style>

  </head>
  <body>
    
<div class="header">
  <h3><a href="/">research!rsc</a></h3>
  <h4>Thoughts and links about programming,
    by <a href="https://swtch.com/~rsc/" rel="author">Russ Cox</a> </h4>
  <a class="rss" href="/feed.atom"><img src="/feed-icon-14x14.png" /></a>
</div>

    <div class="main">
      <div class="article">
        <h1>Hacking the OS X Kernel for Fun and Profiles
        
        <div class="normal">
        <div class="when">
          
            Posted on Tuesday, August 13, 2013.
            
          
        </div>
        </div>
        </h1>
        
<style>
</style>

<p class="lp">
My last post described how user-level CPU profilers work,
and specifically how Google&rsquo;s pprof profiler gathers its CPU profiles
with the help of the operating system.
The specific feature needed from the operating system is
the profiling timer provided by <i>setitimer</i>(2) and the
<code>SIGPROF</code> signals that it delivers.
</p>

<p class="pp">
If the operating system&rsquo;s implementation of that feature doesn&rsquo;t work,
then the profiler doesn&rsquo;t work.
This post looks at a common bug in Unix implementations
of profiling signals and the fix for OS X, applied by editing
the OS X kernel binary.
</p>

<p class="pp">
If you haven&rsquo;t read &ldquo;<a href="pprof">How to Build a User-Level CPU Profiler</a>,&rsquo;&rsquo; you might want to start there.
</p>

<h3>Unix and Signals and Threads</h3>

<p class="pp">
My earlier post referred to profiling <i>programs</i>, without mention
of processes or threads.
Unix in general and SIGPROF in particular predate the idea of threads.
SIGPROF originated in the 4.2BSD release of Berkeley Unix, published in 1983.
In Unix at the time, a process was a single thread of execution.
</p>

<p class="pp">
Threads did not come easily to Unix.
Early implementations were slow and buggy and best avoided.
Each of the popular Unix variants added thread support
independently, with many shared mistakes.
</p>

<p class="pp">
Even before we get to implementation, many of the original Unix APIs
are incompatible with the idea of threads.
Multithreaded processes allow multiple threads of execution in a
single process address space.
Unix maintains much per-process state, and the kernel authors
must decide whether each piece of state should remain per-process
or change to be per-thread.
</p>

<p class="pp">For example, the single process stack must be split into per-thread stacks:
it is impossible for independently executing threads to be running on 
a single stack.
Because there are many threads, thread stacks tend to be smaller than the
one big process stack that non-threaded Unix programs had.
As a result, it can be important to define a separate stack for running
signal handlers.
That setting is per-thread, for the same reason that ordinary stacks are per-thread.
But the choice of handler is per-process.
</p>

<p class="pp">
File descriptors are per-process, but then one thread might open a file moments
before another thread forks and execs a new program. In order for the open file not
to be inherited by the new program, we must introduce a new variant of <i>open</i>(2)
that can open a file descriptor atomically marked &ldquo;close on exec.&rsquo;&rsquo; And not just open: 
every system call that creates a new file descriptor needs a variant that
creates the file descriptor &ldquo;close on exec.&rsquo;&rsquo;
</p>

<p class="pp">
Memory is per-process, so malloc must use a lock to serialize access
by independent threads. But again, one thread might acquire the malloc lock
moments before another thread forks and execs a new program.
The fork makes a new copy of the current process memory, including
the locked malloc lock, and that copy will never see the unlock by the
thread in the original program. So the child of fork can no longer use malloc
without occasional deadlocks.
</p>

<p class="pp">
That&rsquo;s just the tip of the iceberg.
There are a lot of changes to make, and it&rsquo;s easy to miss one.
</p>

<h3>Profiling Signals</h3>

<p class="pp">
Here&rsquo;s a thread-related change that is easy to miss.</p>

<p class="pp">
The goal of the profiling signal is to enable user-level profiling.
The signal is sent in response to a program using up a certain amount of CPU time.
More specifically, in a multithreaded kernel, the profiling signal is sent
when the hardware timer interrupts a thread and the timer interrupt
handler finds that the execution of that thread has caused the
thread&rsquo;s process&rsquo;s profiling timer to expire.
In order to profile the code whose execution triggered the timer,
the profiling signal must be sent to the thread that is running.
If the signal is sent to a thread that is not running, the profile will
record idleness such as being blocked on I/O or sleeping
as execution and will be neither accurate nor useful.
</p>

<p class="pp">
Modern Unix kernels support sending a signal
to a process, in which case it can be delivered to an arbitrary thread,
or to a specific thread. <i>Kill</i>(2) sends a signal to a process, and
<i>pthread_kill</i>(2) sends a signal to a specific thread within a process.

<p class="pp">
Before Unix had threads, the code that delivered a profiling signal
looked like <code>psignal(p,</code> <code>SIGPROF)</code>, where
<code>psignal</code> is a clearer name for the implementation
of the <i>kill</i>(2) system call and <code>p</code> is the process
with the timer that just expired.
If there is just one thread per process, delivering the signal to the
process cannot possibly deliver it to the wrong thread.
</p>

<p class="pp">
In multithreaded programs, the <code>SIGPROF</code> must be
delivered to the running thread: the kernel must call the internal equivalent
of <i>pthread_kill</i>(2), not <i>kill</i>(2).
</p>

<p class="pp">
FreeBSD and Linux deliver profiling signals correctly. 
Empirically, NetBSD, OpenBSD, and OS X do not.
(Here is a <a href="sigtest.c">simple C test program</a>.)
Without correct delivery of profiling signals, it is impossible
to build a correct profiler.
</p>

<h3>OS X Signal Delivery</h3>

<p class="lp">
To Apple&rsquo;s credit, the OS X kernel sources are published and open source, 
so we can look more closely at the buggy OS X implementation.
</p>

<p class="pp">
The profiling signals are delivered by the function <code>bsd_ast</code>
in the file <a href="http://www.opensource.apple.com/source/xnu/xnu-2050.22.13/bsd/kern/kern_sig.c">kern_sig.c</a>.
Here is the relevant bit of code:
</p>

<pre>
void
bsd_ast(thread_t thread)
{
    proc_t p = current_proc();
    ...
    if (timerisset(&amp;p-&gt;p_vtimer_prof.it_value)) {
        uint32_t    microsecs;

        task_vtimer_update(p-&gt;task, TASK_VTIMER_PROF, &amp;microsecs);

        if (!itimerdecr(p, &amp;p-&gt;p_vtimer_prof, microsecs)) {
            if (timerisset(&amp;p-&gt;p_vtimer_prof.it_value))
                task_vtimer_set(p-&gt;task, TASK_VTIMER_PROF);
            else
                task_vtimer_clear(p-&gt;task, TASK_VTIMER_PROF);

            <b>psignal(p, SIGPROF);</b>
        }
    }
    ...
}
</pre>

<p class="pp">
The <code>bsd_ast</code> function is the BSD half of the OS X timer interrupt handler.
If profiling is enabled, <code>bsd_ast</code> decrements the timer and sends the signal
if the timer expires.
The innermost if statement is resetting the the timer state,
because <i>setitimer</i>(2) allows both one-shot and periodic timers.
</p>

<p class="pp">
As predicted, the code is sending the profiling signal to the process,
not to the current thread.
There is a function <code>psignal_uthread</code> defined in
the same source file that sends a signal instead to a specific thread.
One possible fix is very simple:
change <code>psignal</code> to <code>psignal_uthread</code>.
</p>

<p class="pp">
I filed a report about this bug as <a href="http://golang.org/change/35b716c94225">Apple Bug Report #9177434</a> in March 2011,
but the bug has persisted in subsequent releases of OS X.
In my report, I suggested a different fix, inside the implementation of <code>psignal</code>,
but changing <code>psignal</code> to <code>psignal_uthread</code>
is even simpler.
Let&rsquo;s do that.
</p>

<h3>Patching the Kernel</h3>

<p class="lp">
It should be possible to rebuild the OS X kernel from the released sources.
However, I do not know whether the sources are complete, and I do not know
what configuration I need to use to recreate the kernel on my machine.
I have no confidence that I&rsquo;d end up with a kernel appropriate for my computer.
Since the fix is so simple, it should be possible to just modify the standard OS X kernel binary directly.
That binary lives in <code>/mach_kernel</code> on OS X computers.
</p>

<p class="pp">
If we run <code>gdb</code> on <code>/mach_kernel</code> we can see the compiled machine
code for <code>bsd_ast</code> and find the section we care about.
</p>

<pre>
$ gdb /mach_kernel
(gdb) disas bsd_ast
Dump of assembler code for function bsd_ast:
0xffffff8000568a50 &lt;bsd_ast+0&gt;: push   %rbp
0xffffff8000568a51 &lt;bsd_ast+1&gt;: mov    %rsp,%rbp
...
<i>if (timerisset(&amp;p-&gt;p_vtimer_prof.it_value))</i>
0xffffff8000568b7b &lt;bsd_ast+299&gt;:       cmpq   $0x0,0x1e0(%r15)
0xffffff8000568b83 &lt;bsd_ast+307&gt;:       jne    0xffffff8000568b8f &lt;bsd_ast+319&gt;
0xffffff8000568b85 &lt;bsd_ast+309&gt;:       cmpl   $0x0,0x1e8(%r15)
0xffffff8000568b8d &lt;bsd_ast+317&gt;:       je     0xffffff8000568b9f &lt;bsd_ast+335&gt;
<i>task_vtimer_set(p-&gt;task, TASK_VTIMER_PROF);</i>
0xffffff8000568b8f &lt;bsd_ast+319&gt;:       mov    0x18(%r15),%rdi
0xffffff8000568b93 &lt;bsd_ast+323&gt;:       mov    $0x2,%esi
0xffffff8000568b98 &lt;bsd_ast+328&gt;:       callq  0xffffff80002374f0 &lt;task_vtimer_set&gt;
0xffffff8000568b9d &lt;bsd_ast+333&gt;:       jmp    0xffffff8000568bad &lt;bsd_ast+349&gt;
<i>task_vtimer_clear(p-&gt;task, TASK_VTIMER_PROF);</i>
0xffffff8000568b9f &lt;bsd_ast+335&gt;:       mov    0x18(%r15),%rdi
0xffffff8000568ba3 &lt;bsd_ast+339&gt;:       mov    $0x2,%esi
0xffffff8000568ba8 &lt;bsd_ast+344&gt;:       callq  0xffffff8000237660 &lt;task_vtimer_clear&gt;
<i>psignal(p, SIGPROF);</i>
0xffffff8000568bad &lt;bsd_ast+349&gt;:       mov    %r15,%rdi
0xffffff8000568bb0 &lt;bsd_ast+352&gt;:       xor    %esi,%esi
0xffffff8000568bb2 &lt;bsd_ast+354&gt;:       xor    %edx,%edx
0xffffff8000568bb4 &lt;bsd_ast+356&gt;:       xor    %ecx,%ecx
0xffffff8000568bb6 &lt;bsd_ast+358&gt;:       mov    $0x1b,%r8d
0xffffff8000568bbc &lt;bsd_ast+364&gt;:       callq  0xffffff8000567340 &lt;threadsignal+224&gt;
...
</pre>

<p class="lp">
I&rsquo;ve annotated the assembly with the corresponding C code in italics.
The final sequence is odd. It should be a call to <code>psignal</code> but instead it is a call to
code 224 bytes beyond the start of the <code>threadsignal</code> function.
What&rsquo;s going on is that <code>psignal</code> is a thin wrapper around
<code>psignal_internal</code>, and that wrapper has been inlined.
Since <code>psignal_internal</code> is a static function, it does not appear
in the kernel symbol table, and so <code>gdb</code> doesn&rsquo;t know its name.
</p>

<p class="pp">
The definitions of <code>psignal</code> and <code>psignal_uthread</code> are:
</p>

<pre>
void
psignal(proc_t p, int signum)
{
    psignal_internal(p, NULL, NULL, 0, signum);
}

static void
psignal_uthread(thread_t thread, int signum)
{
    psignal_internal(PROC_NULL, TASK_NULL, thread, PSIG_THREAD, signum);
}
</pre>

<p class="lp">
With the constants expanded, the call we&rsquo;re seeing is <code>psignal_internal(p,</code> <code>0,</code> <code>0,</code> <code>0,</code> <code>0x1b)</code>
and the call we want to turn it into is <code>psignal_internal(0,</code> <code>0,</code> <code>thread,</code> <code>4,</code> <code>0x1b)</code>.
All we need to do is prepare the different argument list.
</p>

<p class="pp">
Unfortunately, the <code>thread</code> variable was passed to <code>bsd_ast</code> in a register,
and since it is no longer needed where we are in the function, the register has been reused
for other purposes: <code>thread</code> is gone.
</p>

<p class="pp">
Fortunately, <code>bsd_ast</code>&rsquo;s one and only invocation in the kernel is
<code>bsd_ast(current_thread())</code>, so we can reconstruct the value by calling
<code>current_thread</code> ourselves.
</p>

<p class="pp">
Unfortunately, there is no room in the 15 bytes from <code>bsd_ast+349</code> to <code>bsd_ast+364</code>
to insert such a call and still prepare the other arguments.
</p>

<p class="pp">
Fortunately, we can optimize a bit of the preceding code to make room.
Notice that the calls to <code>task_vtimer_set</code> and <code>task_vtimer_clear</code>
are passing the same argument list, and that argument list is prepared in both sides
of the conditional:
</p>

<pre class="oldcode">
...
<i>if (timerisset(&amp;p-&gt;p_vtimer_prof.it_value))</i>
0xffffff8000568b7b &lt;bsd_ast+299&gt;:       cmpq   $0x0,0x1e0(%r15)
0xffffff8000568b83 &lt;bsd_ast+307&gt;:       jne    0xffffff8000568b8f &lt;bsd_ast+319&gt;
0xffffff8000568b85 &lt;bsd_ast+309&gt;:       cmpl   $0x0,0x1e8(%r15)
0xffffff8000568b8d &lt;bsd_ast+317&gt;:       je     0xffffff8000568b9f &lt;bsd_ast+335&gt;
<i>task_vtimer_set(p-&gt;task, TASK_VTIMER_PROF);</i>
0xffffff8000568b8f &lt;bsd_ast+319&gt;:       <b>mov    0x18(%r15),%rdi</b>
0xffffff8000568b93 &lt;bsd_ast+323&gt;:       <b>mov    $0x2,%esi</b>
0xffffff8000568b98 &lt;bsd_ast+328&gt;:       callq  0xffffff80002374f0 &lt;task_vtimer_set&gt;
0xffffff8000568b9d &lt;bsd_ast+333&gt;:       jmp    0xffffff8000568bad &lt;bsd_ast+349&gt;
<i>task_vtimer_clear(p-&gt;task, TASK_VTIMER_PROF);</i>
0xffffff8000568b9f &lt;bsd_ast+335&gt;:       <b>mov    0x18(%r15),%rdi</b>
0xffffff8000568ba3 &lt;bsd_ast+339&gt;:       <b>mov    $0x2,%esi</b>
0xffffff8000568ba8 &lt;bsd_ast+344&gt;:       callq  0xffffff8000237660 &lt;task_vtimer_clear&gt;
<i>psignal(p, SIGPROF);</i>
0xffffff8000568bad &lt;bsd_ast+349&gt;:       mov    %r15,%rdi
0xffffff8000568bb0 &lt;bsd_ast+352&gt;:       xor    %esi,%esi
0xffffff8000568bb2 &lt;bsd_ast+354&gt;:       xor    %edx,%edx
0xffffff8000568bb4 &lt;bsd_ast+356&gt;:       xor    %ecx,%ecx
0xffffff8000568bb6 &lt;bsd_ast+358&gt;:       mov    $0x1b,%r8d
0xffffff8000568bbc &lt;bsd_ast+364&gt;:       callq  0xffffff8000567340 &lt;threadsignal+224&gt;
...
</pre>

<p class="lp">
We can pull that call setup above the conditional, eliminating one copy
and giving ourselves nine bytes to use for delivering the signal.
A call to <code>current_thread</code> would take five bytes, and then
moving the result into an appropriate register would take two more,
so nine is plenty.
In fact, since we have nine bytes,
we can inline the body of <code>current_thread</code>—a single nine-byte <code>mov</code> instruction—and change it to store the result to the correct register directly.
That avoids needing to prepare a position-dependent call instruction.
</p>

<p class="pp">
The final version is:
</p>

<pre class="oldcode">
...
0xffffff8000568b7b &lt;bsd_ast+299&gt;:       <b>mov    0x18(%r15),%rdi</b>
0xffffff8000568b7f &lt;bsd_ast+303&gt;:       <b>mov    $0x2,%esi</b>
0xffffff8000568b84 &lt;bsd_ast+308&gt;:       cmpq   $0x0,0x1e0(%r15)
0xffffff8000568b8c &lt;bsd_ast+316&gt;:       jne    0xffffff8000568b98 &lt;bsd_ast+328&gt;
0xffffff8000568b8e &lt;bsd_ast+318&gt;:       cmpl   $0x0,0x1e8(%r15)
0xffffff8000568b96 &lt;bsd_ast+326&gt;:       je     0xffffff8000568b9f &lt;bsd_ast+335&gt;
0xffffff8000568b98 &lt;bsd_ast+328&gt;:       callq  0xffffff80002374f0 &lt;task_vtimer_set&gt;
0xffffff8000568b9d &lt;bsd_ast+333&gt;:       jmp    0xffffff8000568ba4 &lt;bsd_ast+340&gt;
0xffffff8000568b9f &lt;bsd_ast+335&gt;:       callq  0xffffff8000237660 &lt;task_vtimer_clear&gt;
0xffffff8000568ba4 &lt;bsd_ast+340&gt;:       <b>xor    %edi,%edi</b>
0xffffff8000568ba6 &lt;bsd_ast+342&gt;:       xor    %esi,%esi
0xffffff8000568ba8 &lt;bsd_ast+344&gt;:       <b>mov    %gs:0x8,%rdx</b>
0xffffff8000568bb1 &lt;bsd_ast+353&gt;:       <b>mov    $0x4,%ecx</b>
0xffffff8000568bb6 &lt;bsd_ast+358&gt;:       mov    $0x1b,%r8d
0xffffff8000568bbc &lt;bsd_ast+364&gt;:       callq  0xffffff8000567340 &lt;threadsignal+224&gt;
...
</pre>

<p class="pp">
If we hadn&rsquo;t found the duplicate call setup to factor out,
another possible approach would have been to factor the two very similar
code blocks handling <code>SIGVTALRM</code> and <code>SIGPROF</code> into a single subroutine,
sitting in the middle of the <code>bsd_ast</code> function code, and to call it twice.
Removing the second copy of the code would leave plenty of space
for the longer <code>psignal_uthread</code> call setup.
</p>

<p class="pp">
The code we&rsquo;ve been using is from OS X Mountain Lion, but all versions of OS X have this bug,
and the relevant bits of <code>bsd_ast</code> haven&rsquo;t changed from version to version,
although the compiler and therefore the generated code do change.
Even so, all have the basic pattern and all can be fixed with the same kind of rewrite.
</p>

<h3>Using the Patch</h3>

<p>
If you use the Go or the C++ gperftools and want accurate CPU profiles on OS X, I&rsquo;ve packaged up the 
binary patcher as <a href="http://godoc.org/code.google.com/p/rsc/cmd/pprof_mac_fix">code.google.com/p/rsc/cmd/pprof_mac_fix</a>.
It can handle OS X Snow Leopard, Lion, and Mountain Lion.
Will OS X Mavericks need a fix too?
We&rsquo;ll see.
</p>

<h3>Further Reading</h3>

<p>
Binary patching is an old, venerable technique. This is just a simple instance of it.
If you liked reading about this, you may also like to read Jeff Arnold&rsquo;s paper
&ldquo;<a href="http://www.ksplice.com/doc/ksplice.pdf">Ksplice: Automatic Rebootless Kernel Updates</a>.&rsquo;&rsquo;
Ksplice can construct binary patches for Linux security vulnerabilities
and apply them on the fly to a running system.
</p>

      </div>
      
      <div class="comments">
        <div class="comments-header">
          <p>Comments?  Please join the <a href="https://plus.google.com/116810148281701144465/posts/dqfyp15z5Uf">Google+ discussion</a>.</p>
        </div>
        <div class="comments-body">
          <div id="plus-comments">
          </div>
        </div>
      </div>
      
      
    </div>

    
<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
var pageTracker = _gat._getTracker("UA-3319603-2");
pageTracker._initData();
pageTracker._trackPageview();
</script>

    
    
    
<script src="//ajax.googleapis.com/ajax/libs/jquery/1/jquery.min.js"></script>
<script>



function plusComments(me, postid, key) {
$.ajax({
type: 'GET',
url: 'https://www.googleapis.com/plus/v1/activities/'+postid+'/comments?alt=json&maxResults=100&pp=1&key='+key,
dataType: 'jsonp',
success: function(z, textStatus)
{

var items = z.items;
var countitems = 0;
for(Object in items) countitems++;
for (var i = 0; i < countitems; i++) {

var nam = z.items[i].actor.displayName;                    
var pid = z.items[i].actor.url;                           
var img = z.items[i].actor.image.url;           
var text = z.items[i].object.content;                   


(function(d){d.timeago=function(g){if(g instanceof Date){return a(g)}else{if(typeof g==="string"){return a(d.timeago.parse(g))}else{return a(d.timeago.datetime(g))}}};var f=d.timeago;d.extend(d.timeago,{settings:{refreshMillis:60000,allowFuture:false,strings:{prefixAgo:null,prefixFromNow:null,suffixAgo:"ago",suffixFromNow:"from now",seconds:"less than a minute",minute:"about a minute",minutes:"%d minutes",hour:"about an hour",hours:"about %d hours",day:"a day",days:"%d days",month:"about a month",months:"%d months",year:"about a year",years:"%d years",numbers:[]}},inWords:function(l){var m=this.settings.strings;var i=m.prefixAgo;var q=m.suffixAgo;if(this.settings.allowFuture){if(l<0){i=m.prefixFromNow;q=m.suffixFromNow}l=Math.abs(l)}var o=l/1000;var g=o/60;var n=g/60;var p=n/24;var j=p/365;function h(r,t){var s=d.isFunction(r)?r(t,l):r;var u=(m.numbers&&m.numbers[t])||t;return s.replace(/%d/i,u)}var k=o<45&&h(m.seconds,Math.round(o))||o<90&&h(m.minute,1)||g<45&&h(m.minutes,Math.round(g))||g<90&&h(m.hour,1)||n<24&&h(m.hours,Math.round(n))||n<48&&h(m.day,1)||p<30&&h(m.days,Math.floor(p))||p<60&&h(m.month,1)||p<365&&h(m.months,Math.floor(p/30))||j<2&&h(m.year,1)||h(m.years,Math.floor(j));return d.trim([i,k,q].join(" "))},parse:function(h){var g=d.trim(h);g=g.replace(/\.\d\d\d+/,"");g=g.replace(/-/,"/").replace(/-/,"/");g=g.replace(/T/," ").replace(/Z/," UTC");g=g.replace(/([\+\-]\d\d)\:?(\d\d)/," $1$2");return new Date(g)},datetime:function(h){var i=d(h).get(0).tagName.toLowerCase()==="time";var g=i?d(h).attr("datetime"):d(h).attr("title");return f.parse(g)}});d.fn.timeago=function(){var h=this;h.each(c);var g=f.settings;if(g.refreshMillis>0){setInterval(function(){h.each(c)},g.refreshMillis)}return h};function c(){var g=b(this);if(!isNaN(g.datetime)){d(this).text(a(g.datetime))}return this}function b(g){g=d(g);if(!g.data("timeago")){g.data("timeago",{datetime:f.datetime(g)});var h=d.trim(g.text());if(h.length>0){g.attr("title",h)}}return g.data("timeago")}function a(g){return f.inWords(e(g))}function e(g){return(new Date().getTime()-g.getTime())}document.createElement("abbr");document.createElement("time")}(jQuery));

var publi = ($.timeago($.trim(z.items[i].published))); 




var meclass = "";
if (pid === 'https://plus.google.com/'+me){
  meclass = " me";
}

var comment = '<div class="plus-comment'+meclass+'"><img class="plus-img" src="'+img+'" /><p><a href="'+pid+'" target="blank" title="'+nam+'\'s Google+ profile">'+nam+'</a> <span class="comment-when">('+publi+')</span> '+text+'</p><div class="plus-clear"></div></div>';

$('#plus-comments').append(comment);

}

}});
}
</script>

    <script>plusComments("116810148281701144465", "z12ydbwztq2ngzbyw04ce545ymaigp1zoec", "AIzaSyB_JO6hyAJAL659z0Dmu0RUVVvTx02ZPMM")</script>
    
  </body>
</html>
















