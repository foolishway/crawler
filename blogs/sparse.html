<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <title>research!rsc: Using Uninitialized Memory for Fun and Profit</title>
    <link rel="alternate" type="application/atom+xml" title="research!rsc - Atom" href="http://research.swtch.com/feed.atom" />
    
<meta name="viewport" content="width=device-width, initial-scale=1">
<link href='https://fonts.googleapis.com/css?family=Inconsolata:400,700' rel='stylesheet' type='text/css'>
<script type="text/javascript" src="https://use.typekit.com/skm6yij.js"></script>
<script type="text/javascript">try{Typekit.load();}catch(e){}</script>
<style>
  body {
    padding: 0;
    margin: 0;
    font-size: 100%;
    font-family: 'Minion Pro';
  }
  @media print {
    img {page-break-inside: avoid;}
    div.nosplit {page-break-inside: avoid;}
  }
  img.center {
    display: block;
    margin: 0 auto;
  }
  .pad {
    padding-top: 1em;
    padding-bottom: 1em;
  }
  a.anchor, a.back, a.footnote {
    color: black !important;
    text-decoration: none !important;
  }
  a.back {
    font-size: 50%;
  }
  @media print {
    a.back {display: none;}
  }
  .header {
    height: 1.25em;
    background-color: #dff;
    margin: 0;
    padding: 0.1em 0.1em 0.2em;
    border-top: 1px solid black;
    border-bottom: 1px solid #8ff;
  }
  .header h3 {
    margin: 0;
    padding: 0 2em;
    display: inline-block;
    padding-right: 2em;
    font-style: italic;
    font-size: 90%;
  }
  .rss {
    float: right;
    padding-top: 0.2em;
    padding-right: 2em;
    display: none;
  }
  .toc {
    margin-top: 2em;
  }
  .toc-title {
    font-family: "caflisch-script-pro";
    font-size: 300%;
    line-height: 50%;
  }
  .toc-subtitle {
    display: block;
    margin-bottom: 1em;
    font-size: 83%;
  }
  @media only screen and (max-width: 550px) { .toc-subtitle { display: none; } }
  .header h3 a {
    color: black;
  }
  .header h4 {
    margin: 0;
    padding: 0;
    display: inline-block;
    font-weight: normal;
    font-size: 83%;
  }
  @media only screen and (max-width: 550px) { .header h4 { display: none; } }
  .main {
    padding: 0 2em;
  }
  @media only screen and (max-width: 479px) { .article { font-size: 120%; } }
  .article h1 {
    text-align: center;
    font-size: 200%;
  }
  .copyright {
    font-size: 83%;
  }
  .subtitle {
      font-size: 65%;
  }
  .normal {
    font-size: medium;
    font-weight: normal;
  }
  .when {
    text-align: center;
    font-size: 100%;
    margin: 0;
    padding: 0;
  }
  .when p {
    margin: 0;
    padding: 0;
  }
  .article h2 {
    font-size: 125%;
    padding-top: 0.25em;
  }
  .article h3 {
    font-size: 100%;
  }
  pre {
    margin-left: 4em;
    margin-right: 4em;
  }
  pre, code {
    font-family: 'Inconsolata', monospace;
    font-size: 100%;
  }
  .footer {
    margin-top: 10px;
    font-size: 83%;
    font-family: sans-serif;
  }
  .comments {
    margin-top: 2em;
    background-color: #ffe;
    border-top: 1px solid #aa4;
    border-left: 1px solid #aa4;
    border-right: 1px solid #aa4;
  }
  .comments-header {
    padding: 0 5px 0 5px;
  }
  .comments-header p {
    padding: 0;
    margin: 3px 0 0 0;
  }
  .comments-body {
    padding: 5px 5px 5px 5px;
  }
  #plus-comments {
    border-bottom: 1px dotted #ccc;
  }
  .plus-comment {
    width: 100%;
    font-size: 14px;
    border-top: 1px dotted #ccc;
  }
  .me {
    background-color: #eec;
  }
  .plus-comment ul {
    margin: 0;
    padding: 0;
    list-style: none;
    width: 100%;
    display: inline-block;
  }
  .comment-when {
    color:#999;
    width:auto;
    padding:0 5px;
  }
  .old {
    font-size: 83%;
  }
  .plus-comment ul li {
    display: inline-block;
    vertical-align: top;
    margin-top: 5px;
    margin-bottom: 5px;
    padding: 0;
  }
  .plus-icon {
    width: 45px;
  }
  .plus-img {
    float: left;
    margin: 4px 4px 4px 4px;
    width: 32px;
    height: 32px;
  }
  .plus-comment p {
    margin: 0;
    padding: 0;
  }
  .plus-clear {
    clear: left;
  }
  .toc-when {
    font-size: 83%;
    color: #999;
  }
  .toc {
    list-style: none;
  }
  .toc li {
    margin-bottom: 0.5em;
  }
  .toc-head {
    margin-bottom: 1em !important;
    font-size: 117%;
  }
  .toc-summary {
    margin-left: 2em;
  }
  .favorite {
    font-weight: bold;
  }
  .article p, .article ol {
    line-height: 144%;
  }
  sup, sub {
    vertical-align: baseline;
    position: relative;
    font-size: 83%;
  }
  sup {
    bottom: 1ex;
  }
  sub {
    top: 0.8ex;
  }

  .main {
    position: relative;
    margin: 0 auto;
    padding: 0;
    width: 900px;
  }
  @media only screen and (min-width: 768px) and (max-width: 959px) { .main { width: 708px; } }
  @media only screen and (min-width: 640px) and (max-width: 767px) { .main { width: 580px; } }
  @media only screen and (min-width: 480px) and (max-width: 639px) { .main { width: 420px; } }
  @media only screen and (max-width: 479px) { .main { width: 300px; } }

</style>

  </head>
  <body>
    
<div class="header">
  <h3><a href="/">research!rsc</a></h3>
  <h4>Thoughts and links about programming,
    by <a href="https://swtch.com/~rsc/" rel="author">Russ Cox</a> </h4>
  <a class="rss" href="/feed.atom"><img src="/feed-icon-14x14.png" /></a>
</div>

    <div class="main">
      <div class="article">
        <h1>Using Uninitialized Memory for Fun and Profit
        
        <div class="normal">
        <div class="when">
          
            Posted on Friday, March 14, 2008.
            
          
        </div>
        </div>
        </h1>
        
<p><p class=lp>
This is the story of a clever trick that's been around for
at least 35 years, in which array values can be left
uninitialized and then read during normal operations,
yet the code behaves correctly no matter what garbage
is sitting in the array.
Like the best programming tricks, this one is the right tool for the 
job in certain situations.
The sleaziness of uninitialized data
access is offset by performance improvements:
some important operations change from linear 
to constant time.
</p>

<p class=pp>
Alfred Aho, John Hopcroft, and Jeffrey Ullman's 1974 book 
<i>The Design and Analysis of Computer Algorithms</i>
hints at the trick in an exercise (Chapter 2, exercise 2.12):
</p>

<blockquote>
Develop a technique to initialize an entry of a matrix to zero
the first time it is accessed, thereby eliminating the <i>O</i>(||<i>V</i>||<sup>2</sup>) time
to initialize an adjacency matrix.
</blockquote>

<p class=lp>
Jon Bentley's 1986 book <a href="http://www.cs.bell-labs.com/cm/cs/pearls/"><i>Programming Pearls</i></a> expands
on the exercise (Column 1, exercise 8; <a href="http://www.cs.bell-labs.com/cm/cs/pearls/sec016.html">exercise 9</a> in the Second Edition):
</p>

<blockquote>
One problem with trading more space for less time is that 
initializing the space can itself take a great deal of time.
Show how to circumvent this problem by designing a technique
to initialize an entry of a vector to zero the first time it is
accessed.  Your scheme should use constant time for initialization
and each vector access; you may use extra space proportional
to the size of the vector.  Because this method reduces 
initialization time by using even more space, it should be
considered only when space is cheap, time is dear, and 
the vector is sparse.
</blockquote>

<p class=lp>
Aho, Hopcroft, and Ullman's exercise talks about a matrix and 
Bentley's exercise talks about a vector, but for now let's consider
just a simple set of integers.
</p>

<p class=pp>
One popular representation of a set of <i>n</i> integers ranging
from 0 to <i>m</i> is a bit vector, with 1 bits at the
positions corresponding to the integers in the set.
Adding a new integer to the set, removing an integer
from the set, and checking whether a particular integer
is in the set are all very fast constant-time operations
(just a few bit operations each).
Unfortunately, two important operations are slow:
iterating over all the elements in the set 
takes time <i>O</i>(<i>m</i>), as does clearing the set.
If the common case is that 
<i>m</i> is much larger than <i>n</i>
(that is, the set is only sparsely
populated) and iterating or clearing the set 
happens frequently, then it could be better to
use a representation that makes those operations
more efficient.  That's where the trick comes in.
</p>

<p class=pp>
Preston Briggs and Linda Torczon's 1993 paper,
&ldquo;<a href="http://citeseer.ist.psu.edu/briggs93efficient.html"><b>An Efficient Representation for Sparse Sets</b></a>,&rdquo;
describes the trick in detail.
Their solution represents the sparse set using an integer
array named <code>dense</code> and an integer <code>n</code>
that counts the number of elements in <code>dense</code>.
The <i>dense</i> array is simply a packed list of the elements in the
set, stored in order of insertion.
If the set contains the elements 5, 1, and 4, then <code>n = 3</code> and
<code>dense[0] = 5</code>, <code>dense[1] = 1</code>, <code>dense[2] = 4</code>:
</p>

<center>
<img src="http://research.swtch.com/sparse0.png" />
</center>

<p class=pp>
Together <code>n</code> and <code>dense</code> are
enough information to reconstruct the set, but this representation
is not very fast.
To make it fast, Briggs and Torczon
add a second array named <code>sparse</code>
which maps integers to their indices in <code>dense</code>.
Continuing the example,
<code>sparse[5] = 0</code>, <code>sparse[1] = 1</code>, 
<code>sparse[4] = 2</code>.
Essentially, the set is a pair of arrays that point at
each other:
</p>

<center>
<img src="http://research.swtch.com/sparse0b.png" />
</center>

<p class=pp>
Adding a member to the set requires updating both of these arrays:
</p>

<pre class=indent>
add-member(i):
&nbsp;&nbsp;&nbsp;&nbsp;dense[n] = i
&nbsp;&nbsp;&nbsp;&nbsp;sparse[i] = n
&nbsp;&nbsp;&nbsp;&nbsp;n++
</pre>

<p class=lp>
It's not as efficient as flipping a bit in a bit vector, but it's 
still very fast and constant time. 
</p>

<p class=pp>
To check whether <code>i</code> is in the set, you verify that
the two arrays point at each other for that element:
</p>

<pre class=indent>
is-member(i):
&nbsp;&nbsp;&nbsp;&nbsp;return sparse[i] &lt; n && dense[sparse[i]] == i
</pre>

<p class=lp>
If <code>i</code> is not in the set, then <i>it doesn't matter what <code>sparse[i]</code> is set to</i>:
either <code>sparse[i]</code>
will be bigger than <code>n</code> or it will point at a value in 
<code>dense</code> that doesn't point back at it.
Either way, we're not fooled.  For example, suppose <code>sparse</code>
actually looks like:
</p>

<center>
<img src="http://research.swtch.com/sparse1.png" />
</center>

<p class=lp>
<code>Is-member</code> knows to ignore
members of sparse that point past <code>n</code> or that
point at cells in <code>dense</code> that don't point back,
ignoring the grayed out entries:

<center>
<img src="http://research.swtch.com/sparse2.png" />
</center>

<p class=pp>
Notice what just happened:
<code>sparse</code> can have <i>any arbitrary values</i> in
the positions for integers not in the set, 
those values actually get used during membership
tests, and yet the membership test behaves correctly!
(This would drive <a href="http://valgrind.org/">valgrind</a> nuts.)
</p>

<p class=pp>
Clearing the set can be done in constant time:
</p>
<pre class=indent>
clear-set():
&nbsp;&nbsp;&nbsp;&nbsp;n = 0
</pre>

<p class=lp>
Zeroing <code>n</code> effectively clears 
<code>dense</code> (the code only ever accesses
entries in dense with indices less than <code>n</code>), and
<code>sparse</code> can be uninitialized, so there's no 
need to clear out the old values.
</p>

<p class=pp>
This sparse set representation has one more trick up its sleeve:
the <code>dense</code> array allows an 
efficient implementation of set iteration.
</p>

<pre class=indent>
iterate():
&nbsp;&nbsp;&nbsp;&nbsp;for(i=0; i&lt;n; i++)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yield dense[i]
</pre>

<p class=pp>
Let's compare the run times of a bit vector 
implementation against the sparse set:
</p>
<center>
<table>
<tr>
  <td><i>Operation</i>
  <td align=center width=10>
  <td align=center><i>Bit Vector</i>
  <td align=center width=10>
  <td align=center><i>Sparse set</i>
</tr>
<tr>
  <td>is-member
  <td>
  <td align=center><i>O</i>(1)
  <td> 
  <td align=center><i>O</i>(1)
</tr>
<tr>
  <td>add-member
  <td>
  <td align=center><i>O</i>(1)
  <td>
  <td align=center><i>O</i>(1)
</tr>
<tr>
  <td>clear-set
  <td><td align=center><i>O</i>(<i>m</i>)
  <td><td align=center><i>O</i>(1)
</tr>
<tr>
  <td>iterate
  <td><td align=center><i>O</i>(<i>m</i>)
  <td><td align=center><i>O</i>(<i>n</i>)
</tr>
</table>
</center>

<p class=lp>
The sparse set is as fast or faster than bit vectors for
every operation.  The only problem is the space cost:
two words replace each bit.
Still, there are times when the speed differences are enough
to balance the added memory cost.
Briggs and Torczon point out that liveness sets used 
during register allocation inside a compiler are usually
small and are cleared very frequently, making sparse sets the
representation of choice.
</p>

<p class=pp>
Another situation where sparse sets are the better choice
is work queue-based graph traversal algorithms.
Iteration over sparse sets visits elements
in the order they were inserted (above, 5, 1, 4),
so that new entries inserted during the iteration
will be visited later in the same iteration.
In contrast, iteration over bit vectors visits elements in
integer order (1, 4, 5), so that new elements inserted
during traversal might be missed, requiring repeated
iterations.
</p>

<p class=pp>
Returning to the original exercises, it is trivial to change
the set into a vector (or matrix) by making <code>dense</code>
an array of index-value pairs instead of just indices.
Alternately, one might add the value to the <code>sparse</code>
array or to a new array.
The relative space overhead isn't as bad if you would have been
storing values anyway.
</p>

<p class=pp>
Briggs and Torczon's paper implements additional set
operations and examines performance speedups from
using sparse sets inside a real compiler.
</p></p>





<div class="comments">
  <div class="comments-header old">
    <p>(Comments originally posted via Blogger.)</p>
  </div>
  <div class="comments-body">
    <div id="plus-comments">
 <div class="plus-comment"><ul><li class="plus-text">
    <p><a href='http://www.blogger.com/profile/10803977239416503120'>valhallasw</a> <span class="comment-when">(March 14, 2008 12:58 PM)</span> is-member(i):<BR/>    return sparse[i] &lt; n && dense[sparse[i]]<BR/><BR/>Shouldn't this be<BR/>  return sparse[i] &lt; n && dense[sparse[i]]==i<BR/>, as dense can contain null elements. Obviously this only fails with a false=0 representation.</p>
 </li></ul></div>
 <div class="plus-comment me"><ul><li class="plus-text">
    <p><a href="http://swtch.com/~rsc/">Russ Cox</a> <span class="comment-when">(March 14, 2008 1:50 PM)</span> @valhallasw:  It already said<BR/>dense[sparse[i]] = i; I've changed = to == so the pseudo-code is more like C.</p>
 </li></ul></div>
 <div class="plus-comment"><ul><li class="plus-text">
    <p><a href='http://www.blogger.com/profile/10803977239416503120'>valhallasw</a> <span class="comment-when">(March 14, 2008 3:13 PM)</span> Doh. The pre-block cuts of anything that comes too far to the right, so the ==i didn't show up. Never knew pre-blocks within a div could be this evil :)</p>
 </li></ul></div>
 <div class="plus-comment me"><ul><li class="plus-text">
    <p><a href="http://swtch.com/~rsc/">Russ Cox</a> <span class="comment-when">(March 14, 2008 3:43 PM)</span> @valhallasw: Thanks for pointing that out.  Added some CSS magic to make the pre-blocks wrap.</p>
 </li></ul></div>
 <div class="plus-comment"><ul><li class="plus-text">
    <p><a href='http://www.blogger.com/profile/09764774974069617487'>drew</a> <span class="comment-when">(March 14, 2008 3:46 PM)</span> There's also constant time remove (though a <I>little</I> more work):<BR/><BR/>remove-member(i):<BR/>    if not is-member(i): return<BR/>    j = dense[n-1];<BR/>    dense[sparse[i]] = j;<BR/>    sparse[j] = sparse[i];<BR/>    n = n - 1</p>
 </li></ul></div>
 <div class="plus-comment"><ul><li class="plus-text">
    <p><a href='http://www.blogger.com/profile/01707010989897868629'>gruseom</a> <span class="comment-when">(March 15, 2008 12:17 AM)</span> Very cool. But is it correct to say that the space requirement is two words per element (by which I assume you mean 2*n)? What if one of the integers in the set is very large, wouldn't the sparse vector have to consume correspondingly large space?</p>
 </li></ul></div>
 <div class="plus-comment me"><ul><li class="plus-text">
    <p><a href="http://swtch.com/~rsc/">Russ Cox</a> <span class="comment-when">(March 15, 2008 11:06 AM)</span> @gruseom: The space cost is 2 words per potential entry (per universe member).  I've changed the wording to be clearer, I hope.  The contrast there is just supposed to be the 2 words vs 1 bit.</p>
 </li></ul></div>
 <div class="plus-comment"><ul><li class="plus-text">
    <p><a href='http://www.blogger.com/profile/03600762409582805750'>Dan</a> <span class="comment-when">(March 15, 2008 9:30 PM)</span> Took a look at this from a security perspective, since at first glance, I thought I was looking at another instance of someone thinking uninitialized RAM contains random data.  Actually, this works, and is pretty cool!  Here's how it looks, from another lens.  The canonical, trusted "array" is the dense array.  However, this is potentially slow to access.  So, a second array is created, in which the value in the array is itself used as an index into the dense array.  Now, the uninitialized memory could contain anything, but the value there will either refer back to the entry in the trusted dataset, or it will not.<BR/><BR/>One possible source of trouble is the fact that if the same i is added to the array twice, the second entry will blow away the first one in the sparse set, meaning you'll have a value in the dense set with no index entry pointing back to it.  For certain scenarios, this could be a problem.<BR/><BR/>A much bigger issue, however, is that the integer isn't called out as needing to be unsigned :)  If it isn't, the memory at sparse[i] could contain a number greater than MAXINT, which would be less than 0, and thus pass n&lt;0 membership.  Your system would (likely) crash.</p>
 </li></ul></div>
 <div class="plus-comment"><ul><li class="plus-text">
    <p><a href='http://www.blogger.com/profile/03600762409582805750'>Dan</a> <span class="comment-when">(March 15, 2008 10:28 PM)</span> Besides crashing, in the case where sparse[i] is less than 0, then dense[sparse[i]] is <B>also</B> uninitialized memory.  So, if dense[sparse[i]] <B>happens</B> to contain i, then you'll get a false positive for set membership.<BR/><BR/>(And, of course, I assume that i is constrained to be less than the size of the region malloc'd to sparse)</p>
 </li></ul></div>
 <div class="plus-comment"><ul><li class="plus-text">
    <p><a href='http://www.blogger.com/profile/03600762409582805750'>Dan</a> <span class="comment-when">(March 15, 2008 10:29 PM)</span> drew,<BR/><BR/>   Check that n>0 :)</p>
 </li></ul></div>
 <div class="plus-comment"><ul><li class="plus-text">
    <p><a href='http://www.blogger.com/profile/14714296623514958258'>Timothy Barrington-Smythe</a> <span class="comment-when">(March 15, 2008 10:33 PM)</span> 10 print "my brain hurts"<BR/>20 goto 10</p>
 </li></ul></div>
 <div class="plus-comment"><ul><li class="plus-text">
    <p><a href='http://www.blogger.com/profile/17506797414755089967'>splag</a> <span class="comment-when">(March 15, 2008 10:44 PM)</span> Hey Russ,<BR/>Came across this blog through a random link. Then I was like... hey, I know this guy! <BR/><BR/>Great blog. I've bookmarked it. Hope you're doing well.<BR/><BR/>AJ</p>
 </li></ul></div>
 <div class="plus-comment me"><ul><li class="plus-text">
    <p><a href="http://swtch.com/~rsc/">Russ Cox</a> <span class="comment-when">(March 16, 2008 5:04 AM)</span> @dan: Yes: i is unsigned, and in general add-member needs to check whether the number is already there and all the routines should check i against the size of sparse.  <BR/><BR/>I was trying to keep the presentation simple.  The paper has all the gory details.</p>
 </li></ul></div>
 <div class="plus-comment"><ul><li class="plus-text">
    <p><a href='http://www.blogger.com/profile/01013093458246712927'>datatype</a> <span class="comment-when">(March 16, 2008 7:30 AM)</span> Very cool. I will use this some day.</p>
 </li></ul></div>
 <div class="plus-comment"><ul><li class="plus-text">
    <p><a href='http://www.blogger.com/profile/11319149283079163004'>Mobius</a> <span class="comment-when">(March 16, 2008 9:27 AM)</span> Don't the elements of dense[] have to be unique integers for this to work? I</p>
 </li></ul></div>
 <div class="plus-comment me"><ul><li class="plus-text">
    <p><a href="http://swtch.com/~rsc/">Russ Cox</a> <span class="comment-when">(March 16, 2008 9:39 AM)</span> @mobius: Yes.  But a set is a data structure that only stores each element once, so that's okay.  Or if you adapt it to do what the exercises asked, dense contains the list of vector indices that have been initialized with data.  Either way, it's not a real restriction that the elements of dense be unique.</p>
 </li></ul></div>
 <div class="plus-comment"><ul><li class="plus-text">
    <p><a href='http://www.blogger.com/profile/03600762409582805750'>Dan</a> <span class="comment-when">(March 16, 2008 11:51 AM)</span> @rsc i can be unsigned all day -- it's n that must be unsigned :)  The problem is when you dereference sparse[i].  If that value happens to be greater than MAXINT, it'll miss your n&lt;0 check and Read AV.<BR/><BR/>I think it's a reasonable presumption that i will be generated in such a manner that it will fit into sparse[].  But you're making a post about how you can handle arbitrary values in memory -- you fail on half the values right now :)</p>
 </li></ul></div>
 <div class="plus-comment"><ul><li class="plus-text">
    <p><a href='http://www.blogger.com/profile/03600762409582805750'>Dan</a> <span class="comment-when">(March 16, 2008 8:46 PM)</span> Actually, I'm wrong.  It's the declaration for elements in sparse[] that must be unsigned.  Bah.</p>
 </li></ul></div>
 <div class="plus-comment"><ul><li class="plus-text">
    <p><a href='http://wikitravel.org/en/User:Rklz2'>Rklz2</a> <span class="comment-when">(April 7, 2008 11:40 PM)</span> At first I thought it's going to be a virtual memory trick. But no.<BR/>Well, actually, it could be. This reminds me of copying garbage collectors which also trade more space usage for less time allocating, and the algorithms when stripped of all the complexity have the same gist as those in the article.</p>
 </li></ul></div>
 <div class="plus-comment"><ul><li class="plus-text">
    <p><a href='http://www.blogger.com/profile/02863876217578588420'>DAGwyn</a> <span class="comment-when">(May 19, 2010 3:21 AM)</span> Note that all of sparse[] must be explicitly initialized (to what doesn&#39;t matter, might as well be 0) to ensure that a trap representation is not accessed.  Most people don&#39;t encounter platforms where that is an issue, but it is a possibility allowed by the C standard.</p>
 </li></ul></div>
 <div class="plus-comment"><ul><li class="plus-text">
    <p><a href='http://www.blogger.com/profile/06922852978321097200'>hasknewbie</a> <span class="comment-when">(July 11, 2010 12:32 PM)</span> A lot of these indexing tricks<br /> were discovered by Cray programmers<br /> that used the Cray scatter/gather instructions.   You could for example  determine if a set of integers were unique by writing out an iota to a vector (1...n) then use the set as indexes to scatter and then read the result using the set as indexes to gather.  If the results where the same 1..n then the set was unique.</p>
 </li></ul></div>
 <div class="plus-comment"><ul><li class="plus-text">
    <p><a href='http://www.blogger.com/profile/17046522562803939443'>Zooko</a> <span class="comment-when">(July 12, 2010 7:50 AM)</span> The CPython memory manager does this, and it does indeed drive valgrind nuts. But fortunately valgrind has a nice feature for suppressing warnings and CPython&#39;s valgrind suppressions file suppresses those ones.</p>
 </li></ul></div>
 <div class="plus-comment me"><ul><li class="plus-text">
    <p><a href="http://swtch.com/~rsc/">Russ Cox</a> <span class="comment-when">(January 6, 2011 10:12 AM)</span> Now that RE2 is open source I can point to this overengineered C++ implementation:<br /><br /><a href="http://code.google.com/p/re2/source/browse/util/sparse_array.h" rel="nofollow">util/sparse_array.h</a><br /><a href="http://code.google.com/p/re2/source/browse/util/sparse_set.h" rel="nofollow">util/sparse_set.h</a><br /><br />One example of the graph algorithms I mentioned at the end is the NFA simulation work lists.<br /><br /><a href="http://code.google.com/p/re2/source/browse/re2/nfa.cc?r=5e488cdeff#629" rel="nofollow">re2/nfa.cc</a></p>
 </li></ul></div>
 <div class="plus-comment"><ul><li class="plus-text">
    <p>Anonymous <span class="comment-when">(January 14, 2011 9:32 AM)</span> While this may have been true in the past, the Consumption of Cache lines on current hardware will make a bit vector outperform this method on anything but very small sets of data.</p>
 </li></ul></div>
 <div class="plus-comment me"><ul><li class="plus-text">
    <p><a href="http://swtch.com/~rsc/">Russ Cox</a> <span class="comment-when">(January 14, 2011 10:11 AM)</span> @anonymous: It all depends on how often you clear the set and start over.  If reset is rare, then sure.  If reset is common, though, you&#39;re looking at O(1) vs O(n).  As n gets large, that catches up with you no matter what you think of the memory system.</p>
 </li></ul></div>
 <div class="plus-comment"><ul><li class="plus-text">
    <p><a href='http://www.blogger.com/profile/06213995188128624860'>Jean-Denis</a> <span class="comment-when">(February 22, 2011 1:53 AM)</span> The linked paper doesn&#39;t seem to be available any more, except perhaps behind pay walls. Could anybody provide a working link, or possibly email it to me?<br /><br />Thanks,<br /><br />jdmuys at gmail dot com</p>
 </li></ul></div>
 <div class="plus-comment"><ul><li class="plus-text">
    <p><a href='http://www.laylamah.com'>Layla</a> <span class="comment-when">(March 4, 2011 9:42 PM)</span> Hi,<br /><br />Cool Post! This is a neat trick, which I&#39;ve used in the past, and the benefits for walking the set are really great (For many problems, they&#39;re far more important than the benefit of not needing to initialize the array!) But I feel I should defend Bit Vectors a little bit, since I think they&#39;re getting a bit of a bad rap on the clearing issue :-)<br /><br />Bit Vectors don&#39;t have to be O(M) to clear - they can easily be O(M/W) or O(M/(W*IPC)) where W is the Bit Width of your architecture, and IPC is the number of instructions per clock cycle.<br /><br />On a single-issue 64-bit architecture, this would be O(M/64)... on a dual-issue 128-bit SIMD architecture (like Bulldozer), this could be O(M/256).<br /><br />O(M/64) and O(M/256) still aren&#39;t O(1) for set-sizes larger than 64 and 256, respectively, but O(M/W*IPC) is still generally a lot more friendly than O(M)! :)</p>
 </li></ul></div>
 <div class="plus-comment"><ul><li class="plus-text">
    <p>Anonymous <span class="comment-when">(December 7, 2011 3:44 PM)</span> @Layla<br /><br />That presumes that the CPU can issue analogous memory operations to clear those words. You have to take the memory bus into account. Can an x64 CPU clear 256-bits with a single instruction over the bus?</p>
 </li></ul></div>
    </div>
  </div>
</div>


      </div>
      
      
    </div>

    
<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
var pageTracker = _gat._getTracker("UA-3319603-2");
pageTracker._initData();
pageTracker._trackPageview();
</script>

    
    
  </body>
</html>
















