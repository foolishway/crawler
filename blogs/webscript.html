<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <title>research!rsc: Webscript</title>
    <link rel="alternate" type="application/atom+xml" title="research!rsc - Atom" href="http://research.swtch.com/feed.atom" />
    
<meta name="viewport" content="width=device-width, initial-scale=1">
<link href='https://fonts.googleapis.com/css?family=Inconsolata:400,700' rel='stylesheet' type='text/css'>
<script type="text/javascript" src="https://use.typekit.com/skm6yij.js"></script>
<script type="text/javascript">try{Typekit.load();}catch(e){}</script>
<style>
  body {
    padding: 0;
    margin: 0;
    font-size: 100%;
    font-family: 'Minion Pro';
  }
  @media print {
    img {page-break-inside: avoid;}
    div.nosplit {page-break-inside: avoid;}
  }
  img.center {
    display: block;
    margin: 0 auto;
  }
  .pad {
    padding-top: 1em;
    padding-bottom: 1em;
  }
  a.anchor, a.back, a.footnote {
    color: black !important;
    text-decoration: none !important;
  }
  a.back {
    font-size: 50%;
  }
  @media print {
    a.back {display: none;}
  }
  .header {
    height: 1.25em;
    background-color: #dff;
    margin: 0;
    padding: 0.1em 0.1em 0.2em;
    border-top: 1px solid black;
    border-bottom: 1px solid #8ff;
  }
  .header h3 {
    margin: 0;
    padding: 0 2em;
    display: inline-block;
    padding-right: 2em;
    font-style: italic;
    font-size: 90%;
  }
  .rss {
    float: right;
    padding-top: 0.2em;
    padding-right: 2em;
    display: none;
  }
  .toc {
    margin-top: 2em;
  }
  .toc-title {
    font-family: "caflisch-script-pro";
    font-size: 300%;
    line-height: 50%;
  }
  .toc-subtitle {
    display: block;
    margin-bottom: 1em;
    font-size: 83%;
  }
  @media only screen and (max-width: 550px) { .toc-subtitle { display: none; } }
  .header h3 a {
    color: black;
  }
  .header h4 {
    margin: 0;
    padding: 0;
    display: inline-block;
    font-weight: normal;
    font-size: 83%;
  }
  @media only screen and (max-width: 550px) { .header h4 { display: none; } }
  .main {
    padding: 0 2em;
  }
  @media only screen and (max-width: 479px) { .article { font-size: 120%; } }
  .article h1 {
    text-align: center;
    font-size: 200%;
  }
  .copyright {
    font-size: 83%;
  }
  .subtitle {
      font-size: 65%;
  }
  .normal {
    font-size: medium;
    font-weight: normal;
  }
  .when {
    text-align: center;
    font-size: 100%;
    margin: 0;
    padding: 0;
  }
  .when p {
    margin: 0;
    padding: 0;
  }
  .article h2 {
    font-size: 125%;
    padding-top: 0.25em;
  }
  .article h3 {
    font-size: 100%;
  }
  pre {
    margin-left: 4em;
    margin-right: 4em;
  }
  pre, code {
    font-family: 'Inconsolata', monospace;
    font-size: 100%;
  }
  .footer {
    margin-top: 10px;
    font-size: 83%;
    font-family: sans-serif;
  }
  .comments {
    margin-top: 2em;
    background-color: #ffe;
    border-top: 1px solid #aa4;
    border-left: 1px solid #aa4;
    border-right: 1px solid #aa4;
  }
  .comments-header {
    padding: 0 5px 0 5px;
  }
  .comments-header p {
    padding: 0;
    margin: 3px 0 0 0;
  }
  .comments-body {
    padding: 5px 5px 5px 5px;
  }
  #plus-comments {
    border-bottom: 1px dotted #ccc;
  }
  .plus-comment {
    width: 100%;
    font-size: 14px;
    border-top: 1px dotted #ccc;
  }
  .me {
    background-color: #eec;
  }
  .plus-comment ul {
    margin: 0;
    padding: 0;
    list-style: none;
    width: 100%;
    display: inline-block;
  }
  .comment-when {
    color:#999;
    width:auto;
    padding:0 5px;
  }
  .old {
    font-size: 83%;
  }
  .plus-comment ul li {
    display: inline-block;
    vertical-align: top;
    margin-top: 5px;
    margin-bottom: 5px;
    padding: 0;
  }
  .plus-icon {
    width: 45px;
  }
  .plus-img {
    float: left;
    margin: 4px 4px 4px 4px;
    width: 32px;
    height: 32px;
  }
  .plus-comment p {
    margin: 0;
    padding: 0;
  }
  .plus-clear {
    clear: left;
  }
  .toc-when {
    font-size: 83%;
    color: #999;
  }
  .toc {
    list-style: none;
  }
  .toc li {
    margin-bottom: 0.5em;
  }
  .toc-head {
    margin-bottom: 1em !important;
    font-size: 117%;
  }
  .toc-summary {
    margin-left: 2em;
  }
  .favorite {
    font-weight: bold;
  }
  .article p, .article ol {
    line-height: 144%;
  }
  sup, sub {
    vertical-align: baseline;
    position: relative;
    font-size: 83%;
  }
  sup {
    bottom: 1ex;
  }
  sub {
    top: 0.8ex;
  }

  .main {
    position: relative;
    margin: 0 auto;
    padding: 0;
    width: 900px;
  }
  @media only screen and (min-width: 768px) and (max-width: 959px) { .main { width: 708px; } }
  @media only screen and (min-width: 640px) and (max-width: 767px) { .main { width: 580px; } }
  @media only screen and (min-width: 480px) and (max-width: 639px) { .main { width: 420px; } }
  @media only screen and (max-width: 479px) { .main { width: 300px; } }

</style>

  </head>
  <body>
    
<div class="header">
  <h3><a href="/">research!rsc</a></h3>
  <h4>Thoughts and links about programming,
    by <a href="https://swtch.com/~rsc/" rel="author">Russ Cox</a> </h4>
  <a class="rss" href="/feed.atom"><img src="/feed-icon-14x14.png" /></a>
</div>

    <div class="main">
      <div class="article">
        <h1>Webscript
        
        <div class="normal">
        <div class="when">
          
            Posted on Wednesday, September 8, 2010.
            
          
        </div>
        </div>
        </h1>
        
<p><p class="lp">
Back in 2005, before JavaScript was required for everything on the web,
I created a toy language called webscript, to let you script automatic
web interactions.  I wanted to use webscript to replace some clunky
wget-based shell scripts we were using to do things like track packages
and reboot computers.  Two real webscript programs illustrate the language.
</p>

<p class="pp">
This used to work for tracking UPS packages:
</p>
<pre class="indent">
#!./webscript

load "http://www.ups.com/WebTracking/track?loc=en_US"
find textbox "InquiryNumber1"
input "1z30557w0340175623"
find next checkbox
input "yes"
find prev form
submit
if(find "Delivery Information"){
 find outer table
 print
}else if(find "One or more"){
 print
}else{
 print "Unexpected results."
 find page
 print
}
</pre>

<p class="lp">And this used to work to connect to a APC power strip and reboot the computer named <code>yoshimi</code>:
</p>

<pre class="indent">
#!./webscript

load "http://apc-reset/outlets.htm"
print
print "\n=============\n"
find "yoshimi"
find outer row
find next select
input "Immediate Reboot"
submit
print
</pre>

<p class="lp">I say that the scripts used to work because I haven't run them in a few years.
One of the goals of webscript was to let the programmer describe the
interactions with the web page instead of working with the raw form
parameters, so that scripts would even as the hidden plumbing behind
the web page changed.  Even so the UPS script mentions <code>InquiryNumber1</code>.
</p>

<p class="pp">Every few years I go looking for a replacement for
webscript, but I never find anything.  As more web sites require
JavaScript to do anything useful, the job of implementing something
like webscript gets harder.  I think you'd essentially have to link
against a browser to make it work.
</p>

<p class="pp">Do you know of a tool like
webscript that works with today's web pages?  Do you know an
easy way to make one?  (I know about AppleScript and <a href="http://groups.csail.mit.edu/uid/chickenfoot/index.php">Chickenfoot</a>,
but I'd prefer something that can run and produce output 
as a command line program, without even displaying a web
browser on my screen, so that it can be used in shell scripts
and cron jobs.)
</p></p>





<div class="comments">
  <div class="comments-header old">
    <p>(Comments originally posted via Blogger.)</p>
  </div>
  <div class="comments-body">
    <div id="plus-comments">
 <div class="plus-comment"><ul><li class="plus-text">
    <p><a href='http://www.blogger.com/profile/11628417257537497590'>Fedor Soreks</a> <span class="comment-when">(September 8, 2010 7:06 AM)</span> Perl (via cpan) has http://search.cpan.org/dist/WWW-Mechanize/ which seems to do the thing. <br /><br />Other langs may have something similar.</p>
 </li></ul></div>
 <div class="plus-comment"><ul><li class="plus-text">
    <p><a href='http://www.blogger.com/profile/01283557892488990606'>Marshall</a> <span class="comment-when">(September 8, 2010 8:02 AM)</span> Maybe <a href="http://htmlunit.sourceforge.net/" rel="nofollow">HtmlUnit</a>?  I have it used it, but I ran across it a while ago, and the elevator pitch looks like what you want.</p>
 </li></ul></div>
 <div class="plus-comment"><ul><li class="plus-text">
    <p><a href='http://www.blogger.com/profile/10740626841132661339'>jnwhiteh</a> <span class="comment-when">(September 8, 2010 8:03 AM)</span> There was an interesting article on TUAW a few days ago that talks about bringing Automator-level scripts to Mac OS X with an application called &#39;Fake.app&#39;. It&#39;s no scripting language, but it&#39;s an interesting take on the idea:<br /><br /><a href="http://www.tuaw.com/2010/09/06/fake-app-makes-powerful-web-automation-easy/" rel="nofollow">http://www.tuaw.com/2010/09/06/fake-app-makes-powerful-web-automation-easy/</a></p>
 </li></ul></div>
 <div class="plus-comment"><ul><li class="plus-text">
    <p><a href='http://www.blogger.com/profile/05307602198223780471'>radar</a> <span class="comment-when">(September 8, 2010 8:11 AM)</span> Ruby&#39;s Mechanize tool:<br /><br />http://mechanize.rubyforge.org/mechanize/GUIDE_rdoc.html<br /><br />For example:<br /><br /><br /> require &#39;rubygems&#39;<br /> require &#39;mechanize&#39;<br /><br /> agent = Mechanize.new<br /> page = agent.get(&#39;http://google.com/&#39;)<br /> google_form = page.form(&#39;f&#39;)<br /> google_form.q = &#39;ruby mechanize&#39;<br /> page = agent.submit(google_form)<br /> pp page</p>
 </li></ul></div>
 <div class="plus-comment"><ul><li class="plus-text">
    <p><a href='http://www.blogger.com/profile/00839344798030831980'>rog peppe</a> <span class="comment-when">(September 8, 2010 9:16 AM)</span> i&#39;m glad you mentioned this. i had a vague memory of reading a paper about this (i though i remembered it in a usenix proceedings) but totally failed to find it when i looked for it.<br /><br />i&#39;d love something like this. maybe there&#39;s a way of twisting webkit towards this purpose.<br /><br />none of the solutions listed above seem to quite fit the bill: either they don&#39;t support javascript, or they require a connection to a real graphical browser.</p>
 </li></ul></div>
 <div class="plus-comment"><ul><li class="plus-text">
    <p><a href='http://www.blogger.com/profile/14618340371367353616'>Michael</a> <span class="comment-when">(September 8, 2010 12:27 PM)</span> Michael Bolin, creator of Chickenfoot here. In the Related Work chapter of my thesis (the main topic was Chickenfoot, but the title was &quot;End-User Programming for the Web&quot; http://bolinfest.com/Michael_Bolin_Thesis_Chickenfoot.pdf), I discuss a lot of alternatives of Chickenfoot and their shortcomings. The main problem with browserless approaches such as Mech and HtmlUnit is that so many pages are dynamically generated with the browser these days that you really need the rendering engine and the JavaScript interpreter to properly produce them. That being said, it would be reasonable to run a browser off-screen in VNC or something (which I have done when using Chickenfoot for automated testing) and then communicate with Chickenfoot through that via a command-line interface. If I had more cycles, I would certainly like to invest the time in making that happen. Even better would be to have the Chickenfoot API working on top of WebDriver so it could be used across browsers.</p>
 </li></ul></div>
 <div class="plus-comment"><ul><li class="plus-text">
    <p><a href='http://www.blogger.com/profile/00839344798030831980'>rog peppe</a> <span class="comment-when">(September 9, 2010 6:49 AM)</span> @Michael: is there a reason that the rendering engine needs to actually render the grapics? couldn&#39;t it just remember where the various objects are without drawing the pixels?</p>
 </li></ul></div>
 <div class="plus-comment"><ul><li class="plus-text">
    <p><a href='http://www.blogger.com/profile/14618340371367353616'>Michael</a> <span class="comment-when">(September 9, 2010 6:58 AM)</span> @rog Probably, but I imagine that requires messing with the Firefox source code. Offhand, I would bet that if you tried to launch Firefox on a Linux machine that did not have XWindows installed, it would crash. Though maybe someone has added a mode to support headless Firefox already? In the absence of having an extension installed (or having some programmatic API to use once it were running), it is not clear as to what you could do with headless mode. So yes, I absolutely believe it should be possible, but requires some hacking on somebody&#39;s part.</p>
 </li></ul></div>
 <div class="plus-comment"><ul><li class="plus-text">
    <p><a href='http://www.blogger.com/profile/01863908675256558774'>Maht</a> <span class="comment-when">(September 9, 2010 10:51 AM)</span> <span class='deleted-comment'>This post has been removed by the author.</span></p>
 </li></ul></div>
 <div class="plus-comment"><ul><li class="plus-text">
    <p><a href='http://www.blogger.com/profile/01863908675256558774'>Maht</a> <span class="comment-when">(September 9, 2010 10:55 AM)</span> node.js / Jsdom / jQuery is what you want<br /><br />http://blog.nodejitsu.com/jsdom-jquery-in-5-lines-on-nodejs<br /><br />Which runs server side, no rendering.</p>
 </li></ul></div>
 <div class="plus-comment"><ul><li class="plus-text">
    <p><a href='http://www.blogger.com/profile/13206024250829484576'>Kevin Krouse</a> <span class="comment-when">(September 9, 2010 1:41 PM)</span> Envjs (http://env-js.appspot.com/) runs a headless simulated browser in javascript.  You can write scripts for it using Rhino and jQuery.</p>
 </li></ul></div>
 <div class="plus-comment"><ul><li class="plus-text">
    <p><a href='http://www.blogger.com/profile/00839344798030831980'>rog peppe</a> <span class="comment-when">(September 10, 2010 12:16 AM)</span> jQuery still doesn&#39;t scratch the original webscript itch, because it requires knowing how a page is implemented internally rather than just how it looks. (which is not to say that this approach couldn&#39;t be useful)</p>
 </li></ul></div>
 <div class="plus-comment"><ul><li class="plus-text">
    <p><a href='http://www.blogger.com/profile/08540566813510508054'>charmless</a> <span class="comment-when">(September 10, 2010 2:58 PM)</span> Have a look at Selenium and it&#39;s Selenium IDE. The IDE is a visual tool that lets you record (pretty much straight-line) interactions with a website. (it&#39;s primary purpose is as a testing tool.) <br /><br />But you can output the selenium test to any number of languages, and have as much structured control flow as you like. This is accomplished by running a server program that actually launches a browser and directs it&#39;s actions step-by-step, so it&#39;s certainly more authentic than most of the browser-simulating toolkits.</p>
 </li></ul></div>
 <div class="plus-comment"><ul><li class="plus-text">
    <p><a href='http://www.blogger.com/profile/01283557892488990606'>Marshall</a> <span class="comment-when">(September 12, 2010 10:55 AM)</span> @Michael I&#39;m not sure what the problem is w/ HtmlUnit regarding pages which dynamically generate themselves with JavaScript -- the project claims it has &quot;fairly good JavaScript support (which is constantly improving) and is able to work even with quite complex AJAX libraries.&quot;<br /><br />If that isn&#39;t good enough, there&#39;s always WebKit.  The Qt bindings to WebKit don&#39;t require actually rendering the page and provide various DOM manipulation functions up to and including executing JavaScript in the context of a page element.  Due to Qt randomness, it does require successful communication w/ an X server to run, even if you never actually create a window or paint to the screen.</p>
 </li></ul></div>
 <div class="plus-comment"><ul><li class="plus-text">
    <p><a href='http://www.blogger.com/profile/01283557892488990606'>Marshall</a> <span class="comment-when">(September 12, 2010 10:55 AM)</span> <span class='deleted-comment'>This post has been removed by the author.</span></p>
 </li></ul></div>
 <div class="plus-comment"><ul><li class="plus-text">
    <p><a href='http://www.blogger.com/profile/05121721102795724874'>gertrud</a> <span class="comment-when">(September 30, 2010 3:55 AM)</span> Russ, do you have your original implementation lying around? <br />I would like to play with it. My pc is too slow for all these java scripts anyway, so I&#39;ve been using mostly awk and sed for my web scripts.<br /><br />Next we want flash support, and captcha recognition...</p>
 </li></ul></div>
 <div class="plus-comment"><ul><li class="plus-text">
    <p><a href='http://www.blogger.com/profile/12275921831209319945'>dhobsd</a> <span class="comment-when">(December 10, 2010 9:40 AM)</span> Hey Russ,<br /><br />You might like to take a look at Selenium, which is designed to be a browser testing framework, but I imagine could similarly be instrumented to do general browser automation as well. It works with many browsers:<br /><br />http://seleniumhq.org/<br /><br />--dho</p>
 </li></ul></div>
 <div class="plus-comment"><ul><li class="plus-text">
    <p><a href='http://www.blogger.com/profile/16556953218810348871'>zsbana</a> <span class="comment-when">(January 28, 2011 7:58 AM)</span> There&#39;s also the new perl module WWW::Mechanize::Firefox which is one of those tools that run a full-blown browser.</p>
 </li></ul></div>
    </div>
  </div>
</div>


      </div>
      
      
    </div>

    
<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
var pageTracker = _gat._getTracker("UA-3319603-2");
pageTracker._initData();
pageTracker._trackPageview();
</script>

    
    
  </body>
</html>
















